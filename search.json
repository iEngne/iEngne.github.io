[{"title":"github fork 项目同步上游","url":"/2022/01/13/fork-merge/","content":"<p>虽然github已经在网页上增加了<strong>fetch upstream</strong>功能，但如果有冲突，只能手动merge.<br>以下记录一次手动合并的过程：</p>\n<span id=\"more\"></span>\n<hr>\n<ul>\n<li>clone 自己fork的仓库<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-16:47:17-&gt;&gt;~/workspace<span class=\"comment\"># git clone git@github.com:iEngne/now-subconverter.git</span></span><br><span class=\"line\">Cloning into <span class=\"string\">&#x27;now-subconverter&#x27;</span>...</span><br><span class=\"line\">remote: Enumerating objects: 1514, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Counting objects: 100% (121/121), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Compressing objects: 100% (110/110), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Total 1514 (delta 24), reused 57 (delta 5), pack-reused 1393</span><br><span class=\"line\">Receiving objects: 100% (1514/1514), 46.51 MiB | 991.00 KiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Resolving deltas: 100% (636/636), <span class=\"keyword\">done</span>.</span><br></pre></td></tr></table></figure></li>\n<li>确认当前分支是否是要合并的分支，<code>git brakch -a</code>，如果不是切换到相应的分支。<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:11:23-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git branch  -a</span></span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/HEAD -&gt; origin/master</span><br></pre></td></tr></table></figure></li>\n<li>设置<strong>upstream</strong>.<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-16:48:43-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git remote add upstream https://github.com/zhongfly/now-subconverter.git</span></span><br><span class=\"line\">♥root-16:51:15-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git remote -v</span></span><br><span class=\"line\">origin  git@github.com:iEngne/now-subconverter.git (fetch)</span><br><span class=\"line\">origin  git@github.com:iEngne/now-subconverter.git (push)</span><br><span class=\"line\">upstream        https://github.com/zhongfly/now-subconverter.git (fetch)</span><br><span class=\"line\">upstream        https://github.com/zhongfly/now-subconverter.git (push)</span><br></pre></td></tr></table></figure></li>\n<li>从远程取出<strong>upstream</strong><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-16:51:20-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git fetch upstream</span></span><br><span class=\"line\">remote: Enumerating objects: 32, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Counting objects: 100% (32/32), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Compressing objects: 100% (20/20), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Total 26 (delta 15), reused 17 (delta 6), pack-reused 0</span><br><span class=\"line\">Unpacking objects: 100% (26/26), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">From https://github.com/zhongfly/now-subconverter</span><br><span class=\"line\"> * [new branch]      master     -&gt; upstream/master</span><br></pre></td></tr></table></figure></li>\n<li>查看下分支情况，<code>git branch -a</code><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:29:13-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git branch  -a</span></span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/HEAD -&gt; origin/master</span><br><span class=\"line\">  remotes/origin/master</span><br><span class=\"line\">  remotes/upstream/master</span><br></pre></td></tr></table></figure></li>\n<li>执行合并<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:31:27-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git merge upstream/master</span></span><br><span class=\"line\">warning: Cannot merge binary files: subconverter/subconverter.exe (HEAD vs. upstream/master)</span><br><span class=\"line\">Auto-merging subconverter/subconverter.exe</span><br><span class=\"line\">CONFLICT (content): Merge conflict <span class=\"keyword\">in</span> subconverter/subconverter.exe</span><br><span class=\"line\">Auto-merging subconverter/snippets/emoji.toml</span><br><span class=\"line\">CONFLICT (add/add): Merge conflict <span class=\"keyword\">in</span> subconverter/snippets/emoji.toml</span><br><span class=\"line\">Auto-merging subconverter/pref.example.toml</span><br><span class=\"line\">CONFLICT (add/add): Merge conflict <span class=\"keyword\">in</span> subconverter/pref.example.toml</span><br><span class=\"line\">Automatic merge failed; fix conflicts and <span class=\"keyword\">then</span> commit the result.</span><br></pre></td></tr></table></figure></li>\n<li>查看冲突<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:31:44-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git status</span></span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># You have unmerged paths.</span></span><br><span class=\"line\"><span class=\"comment\">#   (fix conflicts and run &quot;git commit&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Unmerged paths:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#       both added:         subconverter/pref.example.toml</span></span><br><span class=\"line\"><span class=\"comment\">#       both added:         subconverter/snippets/emoji.toml</span></span><br><span class=\"line\"><span class=\"comment\">#       both modified:      subconverter/subconverter.exe</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">no changes added to commit (use <span class=\"string\">&quot;git add&quot;</span> and/or <span class=\"string\">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n<li>直接从GUI界面打开文件修改冲突，或者使用<code>git mergetool</code>命令从命令行打开merge工具，如果有装VIM默认调用vimdiff.  </li>\n<li>修改后<strong>commit</strong>和<strong>push</strong>就OK.</li>\n</ul>\n","categories":["开发日常"],"tags":["github"]},{"title":"vscode ssh 远程登录天坑,使用密钥后仍需要输入密码","url":"/2022/01/12/vscode-ssh/","content":"<p><strong>问题</strong>：使用ssh-keygen生成了密钥对后，把公钥直接重命名成<code>authorized_keys</code>拷贝到服务器<code>~/.ssh</code>目录，发现vscode ssh登录还是提示需要输入密码，还以为密钥对搞错了，反复重试都一样，这就费解了。</p>\n<span id=\"more\"></span>\n<hr>\n<p><strong>解决</strong>  </p>\n<blockquote>\n<p>Make sure the permissions on the <code>~/.ssh</code> directory and its contents are proper. When I first set up my ssh key auth, I didn’t have the <code>~/.ssh</code> folder properly set up, and it yelled at me.</p>\n<ul>\n<li>Your home directory <code>~</code>, your <code>~/.ssh</code> directory and the <code>~/.ssh/authorized_keys</code> file on the remote machine must be writable only by you: <code>rwx------</code> and <code>rwxr-xr-x</code> are fine, but <code>rwxrwx---</code> is no good¹, even if you are the only user in your group (if you prefer numeric modes: <code>700</code> or <code>755</code>, not <code>775</code>).<br>If <code>~/.ssh</code> or <code>authorized_keys</code> is a symbolic link, <a href=\"https://unix.stackexchange.com/questions/152417/why-cant-i-use-public-private-key-authentication-with-ssh-on-arch-linux\">the canonical path (with symbolic links expanded) is checked.</a></li>\n<li>Your <code>~/.ssh/authorized_keys</code> file (on the remote machine) must be readable (at least <code>400</code>), but you’ll need it to be also writable (<code>600</code>) if you will add any more keys to it.</li>\n<li>Your private key file (on the local machine) must be readable and writable only by you: <code>rw-------</code>, i.e. <code>600</code>.  </li>\n<li>Also, if SELinux is set to enforcing, you may need to run <code>restorecon -R -v ~/.ssh</code> (see e.g. <a href=\"https://bugs.launchpad.net/ubuntu/+source/openssh/+bug/965663\">Ubuntu bug 965663</a> and <a href=\"https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=658675\">Debian bug report #658675</a>; this is <a href=\"https://wiki.centos.org/Manuals/ReleaseNotes/CentOS6.2#head-652041430eedc0752937ec8252c52132e574fd2a\">patched in CentOS 6).</a></li>\n</ul>\n<p>¹ Except on some distributions (Debian and derivatives) which have patched the code to allow group writability if you are the only user in your group.  </p>\n</blockquote>\n<p><strong>原文链接</strong>:<a href=\"https://unix.stackexchange.com/questions/36540/why-am-i-still-getting-a-password-prompt-with-ssh-with-public-key-authentication\">https://unix.stackexchange.com/questions/36540/why-am-i-still-getting-a-password-prompt-with-ssh-with-public-key-authentication</a>  </p>\n<p><strong>意思就是</strong>，一般情况下要求 <code>authorized_keys</code> 文件最好设置为只有所有者有读权限或者读写权限(400或者600)，其他情况可能导致不能访问。某些打了补丁的系统也允许当属组成员只有你一个时，<code>authorized_keys</code>设置属组写权限，也允许ssh登录。  </p>\n<p>果然我服务器<code>authorized_keys</code>权限是<code>-rwxr--r--</code>(<code>744</code>).我是通过samba把服务器目录共享到Windows的，拷贝过去默认变成了<code>-rwxr--r--</code>  </p>\n<p>所以一句  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 600 authorized_keys</span><br></pre></td></tr></table></figure>\n<p>解决</p>\n","categories":["开发日常"],"tags":["linux","vscode"]},{"title":"C语言中复杂类型的声明","url":"/2022/04/28/c-complex-declaration/","content":"<p>犹记得当第一次看见c的signal函数的原型的时候，懵逼了，这是个啥啊</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"title function_\">void</span> <span class=\"params\">(*<span class=\"type\">sighandler_t</span>)</span><span class=\"params\">(<span class=\"type\">int</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">sighandler_t</span> <span class=\"title function_\">signal</span><span class=\"params\">(<span class=\"type\">int</span> signum, <span class=\"type\">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>现在知道了，借助typedef声明了一个函数指针类型取名叫sighandler_t，这个函数指针<br>返回值是void，入参是int。然后声明了signal函数，signal函数的返回值是sighandler_t<br>这个类型的函数指针。<br>typedef可以帮我们简化复杂类型的声明，在不借助typedef的情况下，c语言应该怎么声明复杂的类型呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 复习关于C语言复杂类型的声明定义</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * c语言语法中，[]、()的优先级最高，[]、()写在标识符的右侧，*号和基本类型，如int,char,struct等</span></span><br><span class=\"line\"><span class=\"comment\">     * 写在标识符左侧,对声明定义的解析是右左原则。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指针p指向一个有20个char类型元素的数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">char</span> (*p)[<span class=\"number\">20</span>];</span><br><span class=\"line\">    p=(<span class=\"type\">char</span>(*)[<span class=\"number\">20</span>])<span class=\"built_in\">malloc</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> (*p_a)[<span class=\"number\">20</span>] = &amp;a;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 二级指针就多加个*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (**pp_a)[<span class=\"number\">20</span>] = &amp;p_a;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"title function_\">int</span><span class=\"params\">(*p_array)</span>[];</span><br><span class=\"line\">    p_array * p_c = &amp;p_a;<span class=\"comment\">// 跟int (**pp_a)[20] = &amp;p_a;等效</span></span><br><span class=\"line\">    p_array** p_d = &amp;p_c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> *b[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> *(*p_b)[<span class=\"number\">20</span>] = &amp;b;</span><br><span class=\"line\">    <span class=\"type\">int</span> *(**p_e)[<span class=\"number\">20</span>] = &amp;p_b;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*************************************/</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个数组，数组有20个元素，每个元素是指向int类型的二级指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>** f[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个指针，该指针指向一个数组，该数组有20个元素，每个元素是指向int类型的二级指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>** (*p_f)[<span class=\"number\">20</span>] = &amp;f;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个20个元素的数组g，该数组的每个元素是一个指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该指针指向一个有10个元素的数组,该数组的元素是指向char*</span></span><br><span class=\"line\"><span class=\"comment\">     * 类型的指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">char</span> *(*g[<span class=\"number\">20</span>])[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个20个元素的数组，数组的每一个元素是一个指针，该指针是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该函数指针指向的函数，入参为int,返回值是int</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*h[<span class=\"number\">20</span>])(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个函数指针func，指向的函数没有入参，返回值是一个指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该指针指向一个二维数组，该二维数组的每一元素是一个int* 指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *(*(*func)(<span class=\"type\">void</span>))[][<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个函数指针func_a，指向的函数入参是int,返回值是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该函数指针指向的函数入参是int,返回值是int*</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.首先是个指针,所以在左侧加*号，得到*func_a</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.变成函数指针，入参是int，得到(*func_a)(int)</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.返回值是函数指针，那么把2的结果作为一个整体看待，看作是标识符,</span></span><br><span class=\"line\"><span class=\"comment\">     *   再在左侧加*号，后边加(int),得到(*(*func_)(int))(int)</span></span><br><span class=\"line\"><span class=\"comment\">     * 4.返回值的函数指针指向的函数返回值是int*，所以再在左边加上int*，</span></span><br><span class=\"line\"><span class=\"comment\">     * 最后得到 int *(*(*func_a)(int))(int)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *(*(*func_a)(<span class=\"type\">int</span>))(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个数组指针pg，该指针指向一个20个元素的数组，该数组的元素是</span></span><br><span class=\"line\"><span class=\"comment\">     * 函数指针，该函数指针指向的函数，入参是int,返回值是int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">     <span class=\"type\">int</span> (*(*pg)[<span class=\"number\">20</span>])(<span class=\"type\">int</span>);</span><br><span class=\"line\">     pg = &amp;h;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个函数指针func_b，指向的函数入参是int，返回值是一个指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该指针指向一个20个元素的数组，该数组的元素是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该函数指针指向的函数，入参是int,返回值是int.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">     <span class=\"type\">int</span> (*(*(*func_b)(<span class=\"type\">int</span> b))[<span class=\"number\">20</span>])(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 定义一个数组指针ph,指向一个有20个元素的数组，该数组的元素是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">      * 该指针指向一个函数，该函数的入参是int,返回值是指针，该指针指向一个10</span></span><br><span class=\"line\"><span class=\"comment\">      * 个元素的数组，该元素char *</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"type\">char</span>* (*(*(*ph)[<span class=\"number\">20</span>])(<span class=\"type\">int</span>))[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 定义一个函数指针func_d，入参是int,返回值是函数指针，该函数指针指向的函数</span></span><br><span class=\"line\"><span class=\"comment\">      * 入参是short, 返回值是一个指向包含15个char*类型的数组的指针</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">      <span class=\"type\">char</span> *(*(*(*func_d)(<span class=\"type\">int</span>))(<span class=\"type\">short</span>))[<span class=\"number\">15</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["开发日常"],"tags":["C语言"]},{"title":"实现伸展树","url":"/2022/04/29/splay-tree/","content":"<blockquote>\n<p>伸展树（英语：Splay Tree）是一种能够自我平衡的二叉查找树，它能在均摊O(log n)的时间内完成基于伸展（Splay）操作的插入、查找、修改和删除操作。它是由丹尼尔·斯立特（Daniel Sleator）和罗伯特·塔扬在1985年发明的。 </p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行调整，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。<br>它的优势在于不需要记录用于平衡树的冗余信息。<br>-—  Wikipedia</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @file splay_tree_traverse_BFS_DFS.c</span></span><br><span class=\"line\"><span class=\"comment\"> * @author your name (you@domain.com)</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 实现伸展树,实现队列和栈用于广度优先遍历和深度优先遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * @version 0.1</span></span><br><span class=\"line\"><span class=\"comment\"> * @date 2022-04-21</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @copyright Copyright (c) 2022</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">/**&lt; 相同元素计数 */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span>* <span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span>* <span class=\"title\">right</span>;</span></span><br><span class=\"line\">&#125; BinTreeNode;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*********************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用链表实现stack用于深度优先搜索</span></span><br><span class=\"line\"><span class=\"comment\"> ********************************************************/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    BinTreeNode* bin_tree_node;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; ListNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">Stack</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">is_empty</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">push_stack</span><span class=\"params\">(Stack* <span class=\"built_in\">stack</span>, BinTreeNode* tree_node)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode* node = (ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ListNode));</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;bin_tree_node = tree_node;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*<span class=\"built_in\">stack</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *<span class=\"built_in\">stack</span> = node;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    node-&gt;next = *<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    *<span class=\"built_in\">stack</span> = node;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BinTreeNode* <span class=\"title function_\">pop_stack</span><span class=\"params\">(Stack* <span class=\"built_in\">stack</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*<span class=\"built_in\">stack</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* backup = *<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">        BinTreeNode* ret = (*<span class=\"built_in\">stack</span>)-&gt;bin_tree_node;</span><br><span class=\"line\">        *<span class=\"built_in\">stack</span> = (*<span class=\"built_in\">stack</span>)-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(backup);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">make_stack_empty</span><span class=\"params\">(Stack* <span class=\"built_in\">stack</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">stack</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* backup;</span><br><span class=\"line\">        backup = *<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">        *<span class=\"built_in\">stack</span> = (*<span class=\"built_in\">stack</span>)-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(backup);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BinTreeNode* <span class=\"title function_\">get_top_elem</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>-&gt;bin_tree_node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/****************************</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现队列用于广度优先算法</span></span><br><span class=\"line\"><span class=\"comment\"> ***************************/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Queue</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    ListNode* front;</span><br><span class=\"line\">    ListNode* rear;</span><br><span class=\"line\">&#125; Queue;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">enqueue</span><span class=\"params\">(Queue* <span class=\"built_in\">queue</span>, BinTreeNode* tree_node)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error queue is NULL\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode* node = (ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ListNode));</span><br><span class=\"line\">    node-&gt;bin_tree_node = tree_node;</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>-&gt;rear)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;rear = node;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;front = <span class=\"built_in\">queue</span>-&gt;rear;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;rear-&gt;next = node;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;rear = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BinTreeNode* <span class=\"title function_\">dequeue</span><span class=\"params\">(Queue* <span class=\"built_in\">queue</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error: queue does not exist\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>-&gt;front)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error: queue is empty\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* list_node = <span class=\"built_in\">queue</span>-&gt;front;</span><br><span class=\"line\">        BinTreeNode* tree_node = list_node-&gt;bin_tree_node;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;front == <span class=\"built_in\">queue</span>-&gt;rear)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">queue</span>-&gt;front = <span class=\"built_in\">queue</span>-&gt;rear = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">queue</span>-&gt;front = <span class=\"built_in\">queue</span>-&gt;front-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(list_node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree_node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*******************************************</span></span><br><span class=\"line\"><span class=\"comment\"> *  实现伸展树 </span></span><br><span class=\"line\"><span class=\"comment\"> *******************************************/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span>* <span class=\"title\">SplayTree</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span>* <span class=\"title\">Position</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 插入操作就跟二叉搜索树插入一样，不做平衡操作</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param splay_tree </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return SplayTree </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">(SplayTree* root, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BinTreeNode* node = (BinTreeNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BinTreeNode));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    node-&gt;val = x;</span><br><span class=\"line\">    node-&gt;count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    node-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *root = node;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SplayTree pos = *root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; pos-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos = pos-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos-&gt;left = node;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; pos-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos = pos-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos-&gt;right = node;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos-&gt;val == x)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ++pos-&gt;count;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 二叉查找树的查找操作</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return Position </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Position <span class=\"title function_\">find_search_tree</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:not found\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; root-&gt;val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_search_tree(root-&gt;left, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; root-&gt;val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_search_tree(root-&gt;right, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">find_max</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_max(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">find_min</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_min(root-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 删除元素，删除操作跟二叉查找树的删除一致</span></span><br><span class=\"line\"><span class=\"comment\"> * 为了保持删除元素后的树依然是查找树，需要将删除节点的左子树的最大值</span></span><br><span class=\"line\"><span class=\"comment\"> * 或者右子树中的最小值移动到删除的地方，移动有两种方案：</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. 仅移动链表节点中的值</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. 移动链表的节点</span></span><br><span class=\"line\"><span class=\"comment\"> * 这里使用第1种方案, 第2种有点麻烦</span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return Position </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Position <span class=\"title function_\">delete</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:not found\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; root-&gt;val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = delete(root-&gt;left, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; root-&gt;val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = delete(root-&gt;right, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;count &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                --root-&gt;count;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Position tmp = find_min(root-&gt;right);</span><br><span class=\"line\">                root-&gt;val = tmp-&gt;val;</span><br><span class=\"line\">                root-&gt;count = tmp-&gt;count;</span><br><span class=\"line\">                root-&gt;right = delete(root-&gt;right, tmp-&gt;val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Position tmp = root;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!root-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 清空树，释放内存</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @return Position </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Position <span class=\"title function_\">delete_all</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            root-&gt;left = delete_all(root-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            root-&gt;right =  delete_all(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(root);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">splay_left_left</span><span class=\"params\">(Position g, Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    g-&gt;left = p-&gt;right;</span><br><span class=\"line\">    p-&gt;left = cur-&gt;right;</span><br><span class=\"line\">    p-&gt;right = g;</span><br><span class=\"line\">    cur-&gt;right = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">splay_left_right</span><span class=\"params\">(Position g, Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* cur跟p互换 */</span></span><br><span class=\"line\">    p-&gt;right = cur-&gt;left;</span><br><span class=\"line\">    cur-&gt;left = p;</span><br><span class=\"line\">    g-&gt;left = cur;</span><br><span class=\"line\">    <span class=\"comment\">/* cur跟g互换 */</span></span><br><span class=\"line\">    g-&gt;left = cur-&gt;right;</span><br><span class=\"line\">    cur-&gt;right = g;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">splay_right_left</span><span class=\"params\">(Position g, Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* cur跟p互换 */</span></span><br><span class=\"line\">    p-&gt;left = cur-&gt;right;</span><br><span class=\"line\">    cur-&gt;right = p;</span><br><span class=\"line\">    g-&gt;right = cur;</span><br><span class=\"line\">    <span class=\"comment\">/* cur跟g互换 */</span></span><br><span class=\"line\">    g-&gt;left = cur-&gt;left;</span><br><span class=\"line\">    cur-&gt;left = g;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">splay_right_right</span><span class=\"params\">(Position g, Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    g-&gt;right = p-&gt;left;</span><br><span class=\"line\">    p-&gt;right = cur-&gt;left;</span><br><span class=\"line\">    p-&gt;left = g;</span><br><span class=\"line\">    cur-&gt;left = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">rotate_left</span><span class=\"params\">(Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    p-&gt;left = cur-&gt;right;</span><br><span class=\"line\">    cur-&gt;right = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">rotate_right</span><span class=\"params\">(Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    p-&gt;right = cur-&gt;left;</span><br><span class=\"line\">    cur-&gt;left = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 伸展树的查找操作要求将找到的元素伸展到根节点</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param cur_pos </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return Position </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Position <span class=\"title function_\">find</span><span class=\"params\">(SplayTree cur_pos, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cur_pos)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack <span class=\"built_in\">stack</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; cur_pos-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur_pos-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                push_stack(&amp;<span class=\"built_in\">stack</span>, cur_pos);</span><br><span class=\"line\">                cur_pos = cur_pos-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:not found\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; cur_pos-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur_pos-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                push_stack(&amp;<span class=\"built_in\">stack</span>, cur_pos);</span><br><span class=\"line\">                cur_pos = cur_pos-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:not found\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;find it\\n&quot;</span>);</span><br><span class=\"line\">            Position p, q, r;</span><br><span class=\"line\">            p = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">            q = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">            r = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">            <span class=\"comment\">/* 找到元素后通过伸展将元素放到根节点*/</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* 栈里没有元素，那么cur_pos就是根节点 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!p &amp;&amp; !q &amp;&amp; !r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/* 说明当前cur_pos变量保存的节点的父节点是根节点,旋转一次就行 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p &amp;&amp; !q &amp;&amp; !r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (p-&gt;left == cur_pos)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        cur_pos = rotate_right(p, cur_pos);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        cur_pos = rotate_left(p, cur_pos);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/* zig-zig模式 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (q-&gt;left == p &amp;&amp; p-&gt;left == cur_pos)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cur_pos = splay_left_left(q, p ,cur_pos);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q-&gt;right == p &amp;&amp; p-&gt;right == cur_pos)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cur_pos = splay_right_right(q, p ,cur_pos);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/* zig-zag模式 */</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q-&gt;left == p &amp;&amp; p-&gt;right == cur_pos)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cur_pos = splay_left_right(q, p ,cur_pos);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q-&gt;right == p &amp;&amp; p-&gt;left == cur_pos)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cur_pos = splay_right_left(q, p, cur_pos);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r-&gt;left == q)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    r-&gt;left = cur_pos;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    r-&gt;right = cur_pos;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                p = r;</span><br><span class=\"line\">                q = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">                r = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cur_pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 随机生成一棵二叉查找树</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param size </span></span><br><span class=\"line\"><span class=\"comment\"> * @return SplayTree </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SplayTree <span class=\"title function_\">make_random_bin_tree</span><span class=\"params\">(<span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span></span><br><span class=\"line\">    gettimeofday(&amp;tv, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    srand((<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)(tv.tv_usec));</span><br><span class=\"line\">    SplayTree tree = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[random:]&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (size--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x = rand() % <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, x);</span><br><span class=\"line\">        insert(&amp;tree, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 深度优先遍历(后序遍历)</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">traverse_DFS</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Stack <span class=\"built_in\">stack</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = push_stack(&amp;<span class=\"built_in\">stack</span>, root);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;push_stack error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!is_empty(<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        BinTreeNode* ret = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:ret is NULL\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, ret-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            push_stack(&amp;<span class=\"built_in\">stack</span>, ret-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret-&gt;left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            push_stack(&amp;<span class=\"built_in\">stack</span>, ret-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">is_empty_queue</span><span class=\"params\">(Queue* <span class=\"built_in\">queue</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>-&gt;front == <span class=\"built_in\">queue</span>-&gt;rear &amp;&amp; <span class=\"built_in\">queue</span>-&gt;front == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 广度优先遍历(层序遍历)</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">traverse_BFS</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Queue <span class=\"built_in\">queue</span> = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    enqueue(&amp;<span class=\"built_in\">queue</span>, root);</span><br><span class=\"line\">    <span class=\"type\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!is_empty_queue(&amp;<span class=\"built_in\">queue</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        BinTreeNode* node = dequeue(&amp;<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            enqueue(&amp;<span class=\"built_in\">queue</span>, node-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            enqueue(&amp;<span class=\"built_in\">queue</span>, node-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 前序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param level </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">pre_order_traverse</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d &quot;</span>, level, root-&gt;val);</span><br><span class=\"line\">        pre_order_traverse(root-&gt;left, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        pre_order_traverse(root-&gt;right, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 中序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param level </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">in_order_traverse</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        in_order_traverse(root-&gt;left, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d &quot;</span>, level, root-&gt;val);</span><br><span class=\"line\">        in_order_traverse(root-&gt;right, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 后序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param level </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">post_order_traverse</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        post_order_traverse(root-&gt;left, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        post_order_traverse(root-&gt;right, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d-%p &quot;</span>, level, root-&gt;val, root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//SplayTree root = make_random_bin_tree(10);</span></span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">2</span>,<span class=\"number\">84</span>,<span class=\"number\">69</span>,<span class=\"number\">98</span>,<span class=\"number\">73</span>,<span class=\"number\">62</span>,<span class=\"number\">20</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    SplayTree root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insert(&amp;root, arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root = find(root, <span class=\"number\">73</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;--%p--\\n&quot;</span>, find_search_tree(root, <span class=\"number\">62</span>));</span><br><span class=\"line\">    delete(root, <span class=\"number\">50</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;---------------------\\n&quot;</span>);</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    in_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    post_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    traverse_DFS(root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    traverse_BFS(root);</span><br><span class=\"line\">    delete_all(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构与算法"],"tags":["二叉查找树","栈","队列","伸展树"]},{"title":"AVL-tree","url":"/2022/04/29/AVL-tree/","content":"<blockquote>\n<p>AVL树（Adelson-Velsky and Landis Tree）是计算机科学中最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @file AVLTree.c</span></span><br><span class=\"line\"><span class=\"comment\"> * @author your name (you@domain.com)</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 实现AVL树</span></span><br><span class=\"line\"><span class=\"comment\"> * @version 0.1</span></span><br><span class=\"line\"><span class=\"comment\"> * @date 2022-04-11</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @copyright Copyright (c) 2022</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;errno.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;string.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;math.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _Search_Tree_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _Search_Tree_H</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> <span class=\"title\">TreeNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">SearchTRee</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">Position</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ERorateDir</span>&#123;</span></span><br><span class=\"line\">    ROTATE_L = <span class=\"number\">1</span>,</span><br><span class=\"line\">    ROTATE_R,</span><br><span class=\"line\">&#125;ERorateDir;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> elem;</span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">/**&lt; 一个节点相同元素计数 */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> height; <span class=\"comment\">///&lt; 树的高度</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">right</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">releaseSTree</span><span class=\"params\">(TreeNode* t)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!t)&#123;</span><br><span class=\"line\">        TreeNode* left = (t)-&gt;left;</span><br><span class=\"line\">        TreeNode* right = (t)-&gt;right;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(t);</span><br><span class=\"line\">        releaseSTree(left);</span><br><span class=\"line\">        releaseSTree(right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">height</span><span class=\"params\">(Position root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Line:%d, error:node does not exist\\n&quot;</span>, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmax(root-&gt;left-&gt;height, root-&gt;right-&gt;height) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;left-&gt;height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;right-&gt;height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">height_lr_diff</span><span class=\"params\">(Position root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right &amp;&amp; root-&gt;left)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;left-&gt;height &gt; root-&gt;left-&gt;height? \\</span><br><span class=\"line\">               root-&gt;left-&gt;height - root-&gt;right-&gt;height: \\</span><br><span class=\"line\">               root-&gt;right-&gt;height - root-&gt;left-&gt;height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;left-&gt;height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;right-&gt;height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">singleRotate</span><span class=\"params\">(Position k, ERorateDir dir)</span>&#123;</span><br><span class=\"line\">    Position k1;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dir == ROTATE_L)&#123;</span><br><span class=\"line\">        k1 = k-&gt;left;</span><br><span class=\"line\">        k-&gt;left = k1-&gt;right;</span><br><span class=\"line\">        k1-&gt;right = k;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dir == ROTATE_R)&#123;</span><br><span class=\"line\">        k1 = k-&gt;right;</span><br><span class=\"line\">        k-&gt;right = k1-&gt;left;</span><br><span class=\"line\">        k1-&gt;left = k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    k-&gt;height = height(k);</span><br><span class=\"line\">    k1-&gt;height = height(k1);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> k1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">doubleRotateWithLeft</span><span class=\"params\">(Position k)</span>&#123;</span><br><span class=\"line\">    k-&gt;left = singleRotate(k-&gt;left, ROTATE_R);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleRotate(k, ROTATE_L);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">doubleRotateWithRight</span><span class=\"params\">(Position k)</span>&#123;</span><br><span class=\"line\">    k-&gt;right = singleRotate(k-&gt;right, ROTATE_L);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleRotate(k, ROTATE_R);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 插入操作，插入后做平衡调整</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param tree </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return TreeNode*，新树的root节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">TreeNode* <span class=\"title function_\">insert</span><span class=\"params\">(TreeNode* tree, <span class=\"type\">int</span> x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">        tree = (TreeNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(TreeNode));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:out of memory\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tree-&gt;elem = x;</span><br><span class=\"line\">        tree-&gt;count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        tree-&gt;height = <span class=\"number\">0</span>;</span><br><span class=\"line\">        tree-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        tree-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> diff_height;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; tree-&gt;elem)&#123;</span><br><span class=\"line\">            tree-&gt;left = insert(tree-&gt;left, x);</span><br><span class=\"line\">            diff_height = height_lr_diff(tree);</span><br><span class=\"line\">            <span class=\"comment\">/* 插入之后判断是否需要调整平衡 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff_height == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">/* L-L型 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x &lt; tree-&gt;left-&gt;elem)&#123;</span><br><span class=\"line\">                    tree = singleRotate(tree, ROTATE_L);</span><br><span class=\"line\">                <span class=\"comment\">/* L-R型 */</span></span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; tree-&gt;left-&gt;elem)&#123;</span><br><span class=\"line\">                    tree = doubleRotateWithLeft(tree);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; tree-&gt;elem)&#123;</span><br><span class=\"line\">            tree-&gt;right = insert(tree-&gt;right, x);</span><br><span class=\"line\">            diff_height = height_lr_diff(tree);</span><br><span class=\"line\">            <span class=\"comment\">/* 插入之后判断是否需要调整平衡 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff_height == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">/* R-R型 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x &gt; tree-&gt;right-&gt;elem)&#123;</span><br><span class=\"line\">                    tree = singleRotate(tree, ROTATE_R);</span><br><span class=\"line\">                <span class=\"comment\">/* R-L型 */</span></span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &lt; tree-&gt;right-&gt;elem)&#123;</span><br><span class=\"line\">                    tree = doubleRotateWithRight(tree);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ++ tree-&gt;count;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree-&gt;height = height(tree);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TreeNode* <span class=\"title function_\">find</span><span class=\"params\">(TreeNode* tree, <span class=\"type\">int</span> x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == tree-&gt;elem)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &lt; tree-&gt;elem)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(tree-&gt;left, x);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(tree-&gt;right, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TreeNode* <span class=\"title function_\">findMin</span><span class=\"params\">(TreeNode* tree)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree-&gt;left)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findMin(tree-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TreeNode* <span class=\"title function_\">findMax</span><span class=\"params\">(TreeNode* tree)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree-&gt;right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findMax(tree-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief AVL树的删除，删除后需要做调整平衡</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param tree </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return TreeNode* ,新树的root节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">TreeNode* </span><br><span class=\"line\"><span class=\"title function_\">delete</span><span class=\"params\">(root, x)</span></span><br><span class=\"line\">TreeNode* root;<span class=\"type\">int</span> x;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Lline:%d, error: node does not exist\\n&quot;</span>, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> height_diff;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; root-&gt;elem)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = delete(root-&gt;left, x);</span><br><span class=\"line\">        height_diff = height_lr_diff(root);</span><br><span class=\"line\">        <span class=\"comment\">/* 1.如果被删除的元素不是叶子节点，是去高的子树中去找的替代的叶子节点，</span></span><br><span class=\"line\"><span class=\"comment\">        然后删除叶子节点。</span></span><br><span class=\"line\"><span class=\"comment\">        2.如果本来要删除的就是叶子节点，那跟上面的后半部分动作一致。</span></span><br><span class=\"line\"><span class=\"comment\">        所以只有叶子节点被删除之后才会需要调整 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (height_diff == <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* x是删除的元素,删除后O是最小不平衡子树的root</span></span><br><span class=\"line\"><span class=\"comment\">                O</span></span><br><span class=\"line\"><span class=\"comment\">              /   \\</span></span><br><span class=\"line\"><span class=\"comment\">             x     o</span></span><br><span class=\"line\"><span class=\"comment\">                  /</span></span><br><span class=\"line\"><span class=\"comment\">                 o</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            <span class=\"comment\">/* 这种情况必须用双旋转，单旋转不能改变深度 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!root-&gt;right-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = doubleRotateWithRight(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">                O                       O   </span></span><br><span class=\"line\"><span class=\"comment\">              /   \\                   /   \\</span></span><br><span class=\"line\"><span class=\"comment\">             x     o         或者    x     o</span></span><br><span class=\"line\"><span class=\"comment\">                    \\                    /  \\</span></span><br><span class=\"line\"><span class=\"comment\">                     o                  o    o</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            <span class=\"comment\">/* 单旋转 */</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = singleRotate(root, ROTATE_R);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; root-&gt;elem)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = delete(root-&gt;right, x);</span><br><span class=\"line\">        height_diff = height_lr_diff(root);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (height_diff == <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* x是删除的元素,删除后O是最小不平衡子树的root</span></span><br><span class=\"line\"><span class=\"comment\">                   O</span></span><br><span class=\"line\"><span class=\"comment\">                 /   \\</span></span><br><span class=\"line\"><span class=\"comment\">                o     x</span></span><br><span class=\"line\"><span class=\"comment\">                 \\</span></span><br><span class=\"line\"><span class=\"comment\">                  o</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            <span class=\"comment\">/* 这种情况必须用双旋转，单旋转不能改变深度 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!root-&gt;left-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = doubleRotateWithLeft(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/*       O                  O</span></span><br><span class=\"line\"><span class=\"comment\">                   /   \\              /   \\</span></span><br><span class=\"line\"><span class=\"comment\">                  o     x   或者     o     x</span></span><br><span class=\"line\"><span class=\"comment\">                /   \\               /</span></span><br><span class=\"line\"><span class=\"comment\">               o     o             o</span></span><br><span class=\"line\"><span class=\"comment\">           */</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = singleRotate(root, ROTATE_L);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 左右子树都存在 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;count &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                --root-&gt;count;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 从高的子树中找到元素替换将要删除的节点位置，保证左右子树是平衡的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;left-&gt;height &gt; root-&gt;right-&gt;height)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">/* 在左子树中找到最大的值，也就是左子树是空的节点，将它移到将要删除的节点位置 */</span></span><br><span class=\"line\">                    TreeNode* tmp = findMax(root-&gt;left);</span><br><span class=\"line\">                    root-&gt;elem = tmp-&gt;elem;</span><br><span class=\"line\">                    root-&gt;count -= tmp-&gt;count;</span><br><span class=\"line\">                    <span class=\"comment\">/* 删除移动了元素的节点 */</span></span><br><span class=\"line\">                    root-&gt;left = delete(root-&gt;left, tmp-&gt;elem);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">/* 在右子树中找到最小的值，也就是左子树是空的节点，将它移到将要删除的节点位置 */</span></span><br><span class=\"line\">                    TreeNode* tmp = findMin(root-&gt;right);</span><br><span class=\"line\">                    root-&gt;elem = tmp-&gt;elem;</span><br><span class=\"line\">                    root-&gt;count -= tmp-&gt;count;</span><br><span class=\"line\">                    <span class=\"comment\">/* 删除移动了元素的节点 */</span></span><br><span class=\"line\">                    root-&gt;right = delete(root-&gt;right, tmp-&gt;elem);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 只存在一个子树,或者不存在子树 */</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TreeNode* tmpNode = root;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!root-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* 如果两个子树都是空，将right给root也没问题，因为right就是NULL */</span></span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(tmpNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;height = height(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 前序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param level </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">pre_order_traverse</span><span class=\"params\">(SearchTRee root, <span class=\"type\">int</span> level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d &quot;</span>, level, root-&gt;elem);</span><br><span class=\"line\">        pre_order_traverse(root-&gt;left, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        pre_order_traverse(root-&gt;right, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">2</span>,<span class=\"number\">84</span>,<span class=\"number\">69</span>,<span class=\"number\">98</span>,<span class=\"number\">73</span>,<span class=\"number\">62</span>,<span class=\"number\">20</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">    SearchTRee root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root = insert(root, arr[i]);</span><br><span class=\"line\">        pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    root = delete(root, <span class=\"number\">50</span>);</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    root = delete(root, <span class=\"number\">32</span>);</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    root = delete(root, <span class=\"number\">62</span>);</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    releaseSTree(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构与算法"],"tags":["查找二叉树","平衡查找二叉树"]},{"title":"质数判断和筛质数","url":"/2022/04/29/prime-number/","content":"<p>给定一定范围的自然数，找出里面所有的质数主要有2种方式：</p>\n<ol>\n<li>遍历每一个数并判断是不是质数，如果是就存起来。</li>\n<li>借助一定的算法直接筛选。<span id=\"more\"></span></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdbool.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;math.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/******************判断质数**********************/</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 枚举法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 版本1：根据质数的定义，对于大于2的自然数n，从2开始到n-1看是否存在能整除n的数，</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果存在，则是合数，否则为质数</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 版本2：无需判断从2~n-1的所有数，只需要判断2~n的平方根的数是否能整除就行</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 版本3：对于所有大于3的质数具有6n+1(n &gt;= 1)或者6n-1的性质</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 结合2和3的代码示例，时间复杂度O(sqrt(n))</span></span><br><span class=\"line\"><span class=\"comment\">// leetcode中，计算从1到709486有几个质数，耗时28ms</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">isPrime3</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span> || n == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n % <span class=\"number\">6</span> != <span class=\"number\">1</span> &amp;&amp; n % <span class=\"number\">6</span> != <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">5</span>; i &lt;= j; i += <span class=\"number\">6</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 形如6k+1(k &gt;= 1)或者6k-1的合数，一定可以被6m+1或者6m-1的数所整除</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为合数肯定可以因式分解，而所有的质数都形如6m + 1 或者6m - 1(m &gt;=1)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n % i == <span class=\"number\">0</span> || n % (i + <span class=\"number\">2</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 分解质因数-短除法</span></span><br><span class=\"line\"><span class=\"comment\"> * 版本1：要从最小的质数除起（依次除于质数2 3 5....)一直到n，时间复杂度为O(n)</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 版本2：n中最多只含有一个大于sqrt(n)的质因子。</span></span><br><span class=\"line\"><span class=\"comment\"> *       证明：通过反证法：如果有两个大于sqrt(n)的因子，那么相乘会大于n，矛盾。证毕</span></span><br><span class=\"line\"><span class=\"comment\"> *       于是我们发现最多只有一个大于sqrt(n)的因子，对其进行优化。先考虑比sqrt(n)小的，代码和质数的判定类似</span></span><br><span class=\"line\"><span class=\"comment\"> *       最后如果n还是&gt;1，说明此时的n就是大于sqrt(n)的唯一质因子，输出即可，时间复杂度O(sqrt(n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 这种方法，运算次数太多，还不如枚举法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">divide1</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 证明一下循环里面的i一定是一个质数：假如 i 是一个合数，</span></span><br><span class=\"line\">        <span class=\"comment\">// 那么它一定可以分解成多个质因子相乘的形式，</span></span><br><span class=\"line\">        <span class=\"comment\">// 这多个质因子同时也是 n 的质因子且比i要小，</span></span><br><span class=\"line\">        <span class=\"comment\">// 而比i小的数在之前的循环过程中一定是被条件除完了的，所以i不可能是合数，只可能是质数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n % i == <span class=\"number\">0</span>)<span class=\"comment\">//i一定是质数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(n % i == <span class=\"number\">0</span>)<span class=\"comment\">//短除法分解质因数</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                n /= i;</span><br><span class=\"line\">                ++s;<span class=\"comment\">//统计质因数的个数</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s &gt; <span class=\"number\">1</span>? <span class=\"literal\">false</span>:<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用此方法，leetcode中，计算从1到709486有几个质数，耗时408ms</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">divide2</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n / i; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n % i == <span class=\"number\">0</span>)<span class=\"comment\">//i一定是质数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//s = 0;</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(n % i == <span class=\"number\">0</span>)<span class=\"comment\">//短除法分解质因数</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                n /= i;</span><br><span class=\"line\">                ++s;<span class=\"comment\">//统计质因数的个数</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//printf(&quot;%d %d\\n&quot;, i, s);</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//if(n &gt; 1) printf(&quot;%d %d\\n&quot;, n, 1);//当n没有变化的时候，输出本身和1</span></span><br><span class=\"line\">    n &gt; <span class=\"number\">1</span>? ++s:s; <span class=\"comment\">// n还是大于1的，说明此时的n就是一个质数，s需要加1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s &gt; <span class=\"number\">1</span>? <span class=\"literal\">false</span>:<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">countPrimes</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">        divide1(i)?++res:res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///////////////////////////筛质数///////////////////////////</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 朴素筛法</span></span><br><span class=\"line\"><span class=\"comment\"> * 枚举i：2~n，从前往后把每个数对应的倍数都删除掉，这样筛过之后，所有剩下的数都是质数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//朴素筛法-O(nlogn)</span></span><br><span class=\"line\"><span class=\"comment\">// leetcode n=709486时耗时28ms</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">countPrimes1</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储质数</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* primeNums = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(n * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 标记</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* flag = (<span class=\"type\">int</span>*)<span class=\"built_in\">calloc</span>(n + <span class=\"number\">1</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag[i])&#123;</span><br><span class=\"line\">            primeNums[count++] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将所有i的倍数都标记，这些标记的数肯定是合数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i + i; j &lt; n; j += i)&#123;</span><br><span class=\"line\">            flag[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(primeNums);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(flag);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">埃氏筛法是对朴素筛法的一种优化方式，我们并不需要把2~n的每一个数的倍数都删掉，可以只把所有质数的倍数删掉！</span></span><br><span class=\"line\"><span class=\"comment\">因为合数的倍数，肯定也是比这个合数小的质数的某个倍数</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度：O(n * loglogn)，近似O(n)</span></span><br><span class=\"line\"><span class=\"comment\"> * // leetcode n = n=709486时耗时8ms</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">countPrimes2</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储质数</span></span><br><span class=\"line\">    <span class=\"comment\">//int* primeNums = (int*)malloc(n * sizeof(int));</span></span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 标记</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* flag = (<span class=\"type\">int</span>*)<span class=\"built_in\">calloc</span>(n, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 进入这个if条件的都是质数，合数都在之前的循环中被标记为true了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag[i])&#123;</span><br><span class=\"line\">            <span class=\"comment\">// primeNums[count++] = i;</span></span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">            <span class=\"comment\">// 将所有i的倍数都标记，这些标记的数肯定是合数</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i + i; j &lt; n; j += i)&#123;</span><br><span class=\"line\">                flag[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//free(primeNums);</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(flag);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">线性（欧拉）筛法</span></span><br><span class=\"line\"><span class=\"comment\">埃氏筛法的缺陷 ：对于一个合数，有可能被筛多次。例如 30 = 2 * 15 = 3 * 10 = 5*6……</span></span><br><span class=\"line\"><span class=\"comment\">那么如何确保每个合数只被筛选一次呢？我们只要用它的最小质因子来筛选即可，这便是欧拉筛法。</span></span><br><span class=\"line\"><span class=\"comment\">欧拉筛法的基本思想 ：在埃氏筛法的基础上，让每个合数只被它的最小质因子筛选一次，以达到不重复的目的。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">countPrimes3</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储质数</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* primeNums = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(n * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 标记合数</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* flag = (<span class=\"type\">int</span>*)<span class=\"built_in\">calloc</span>(n, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将数从小到大遍历的过程中，没被标记的数一定是质数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag[i])&#123;</span><br><span class=\"line\">            primeNums[count++] = i;</span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 以下这组循环，意思是以一个固定的倍数i去乘以不同的质数，并加上0 == i % primeNums[j]判断来保证</span></span><br><span class=\"line\">        <span class=\"comment\">// 这些数是以primeNums[j]为最小质因数的合数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; i * primeNums[j] &lt; n; ++j)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// primeNums[]存放的是从小到大排列的质数，i在内循环中都是不变的，</span></span><br><span class=\"line\">            <span class=\"comment\">// i作为一个倍数去乘以质数来得到不同的合数。当j从0开始遍历的时候，</span></span><br><span class=\"line\">            <span class=\"comment\">// 一开始的一次或几次循环中，i * primeNums[j]得到的合数，肯定是以</span></span><br><span class=\"line\">            <span class=\"comment\">// primeNums[j]为最小质因数的。那么这些数都可以打上标记。i % primeNums[j] == 0</span></span><br><span class=\"line\">            <span class=\"comment\">// 是在判断primeNums[j]是不是i的最小质因数。当j继续增大，</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果出现某个i0可以被某个primeNums[j0]整除，说明此时i0可以分解成</span></span><br><span class=\"line\">            <span class=\"comment\">// primeNums[j0]和一个比primeNums[j0]大的质数的乘积，我们将这个比primeNums[j0]大</span></span><br><span class=\"line\">            <span class=\"comment\">// 的数称为primeNums[j1]。此时，</span></span><br><span class=\"line\">            <span class=\"comment\">// i0 * primeNums[j0] = primeNums[j0] * primeNums[j1] * primeNums[j0](其中j1 &gt; j0)。</span></span><br><span class=\"line\">            <span class=\"comment\">// primeNums[j0]的值还是i0 * primeNums[j0]这个合数的最小质因数，但是下一次循环，</span></span><br><span class=\"line\">            <span class=\"comment\">// 也就是i0 * primeNums[k0](其中k0 = j0 + 1)，却不是以primeNums[k0]为最小质因数的合数了，</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为i0 * primeNums[k0] = primeNums[j0] * primeNums[j1] * primeNums[k0],</span></span><br><span class=\"line\">            <span class=\"comment\">// 这里最小的质数是primeNums[j0],i0已经可以被上一次循环的primeNums[j0]因式分解。</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果仍然标记flag[i0 * primeNums[k0]] = 1,会造成重复标记。因为</span></span><br><span class=\"line\">            <span class=\"comment\">// 令i_ = primeNums[j1] * primeNums[k0] &gt; i0, i0 * primeNums[k0] = i_ * primeNums[j0],</span></span><br><span class=\"line\">            <span class=\"comment\">// 即当外层循环递增i_时，又会标记一次i0 * primeNums[k0]这个合数。</span></span><br><span class=\"line\">            <span class=\"comment\">// 所以当i % primeNums[j] == 0时，应该推出循环了。</span></span><br><span class=\"line\">            flag[i * primeNums[j]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// j继续增大，会不会一直找不到primeNums[j]可以整除i,不可能，为什么？</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为小于等于i的质数都在primeNums中，</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果i是合数，合数一定可以因式分解，一定存在小于i的质数能整除i，</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果i是质数，那么i已经放在了primeNums中，正好是最后一个，</span></span><br><span class=\"line\">            <span class=\"comment\">// 质数当然可以被自己整除。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"number\">0</span> == i % primeNums[j]))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(primeNums);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(flag);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">709486</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        n = atoi(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;count:%d\\n&quot;</span>, countPrimes2(n));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构与算法"],"tags":["数学","质数"]}]