[{"title":"AVL-tree","url":"/2022/04/29/AVL-tree/","content":"<blockquote>\n<p>AVL树（Adelson-Velsky and Landis Tree）是计算机科学中最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @file AVLTree.c</span></span><br><span class=\"line\"><span class=\"comment\"> * @author your name (you@domain.com)</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 实现AVL树</span></span><br><span class=\"line\"><span class=\"comment\"> * @version 0.1</span></span><br><span class=\"line\"><span class=\"comment\"> * @date 2022-04-11</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @copyright Copyright (c) 2022</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;errno.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;string.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;math.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _Search_Tree_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _Search_Tree_H</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> <span class=\"title\">TreeNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">SearchTRee</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">Position</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ERorateDir</span>&#123;</span></span><br><span class=\"line\">    ROTATE_L = <span class=\"number\">1</span>,</span><br><span class=\"line\">    ROTATE_R,</span><br><span class=\"line\">&#125;ERorateDir;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> elem;</span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">/**&lt; 一个节点相同元素计数 */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> height; <span class=\"comment\">///&lt; 树的高度</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">right</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">releaseSTree</span><span class=\"params\">(TreeNode* t)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!t)&#123;</span><br><span class=\"line\">        TreeNode* left = (t)-&gt;left;</span><br><span class=\"line\">        TreeNode* right = (t)-&gt;right;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(t);</span><br><span class=\"line\">        releaseSTree(left);</span><br><span class=\"line\">        releaseSTree(right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 计算树的高度 */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">height</span><span class=\"params\">(Position root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Line:%d, error:node does not exist\\n&quot;</span>, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmax(root-&gt;left-&gt;height, root-&gt;right-&gt;height) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;left-&gt;height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;right-&gt;height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 计算左右子树的高度差 */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">height_lr_diff</span><span class=\"params\">(Position root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right &amp;&amp; root-&gt;left)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;left-&gt;height &gt; root-&gt;left-&gt;height? \\</span><br><span class=\"line\">               root-&gt;left-&gt;height - root-&gt;right-&gt;height: \\</span><br><span class=\"line\">               root-&gt;right-&gt;height - root-&gt;left-&gt;height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;left-&gt;height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;right-&gt;height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 单旋转 */</span></span><br><span class=\"line\">Position <span class=\"title function_\">singleRotate</span><span class=\"params\">(Position k, ERorateDir dir)</span>&#123;</span><br><span class=\"line\">    Position k1;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dir == ROTATE_L)&#123;</span><br><span class=\"line\">        k1 = k-&gt;left;</span><br><span class=\"line\">        k-&gt;left = k1-&gt;right;</span><br><span class=\"line\">        k1-&gt;right = k;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dir == ROTATE_R)&#123;</span><br><span class=\"line\">        k1 = k-&gt;right;</span><br><span class=\"line\">        k-&gt;right = k1-&gt;left;</span><br><span class=\"line\">        k1-&gt;left = k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    k-&gt;height = height(k);</span><br><span class=\"line\">    k1-&gt;height = height(k1);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> k1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* L_R型双旋转 */</span></span><br><span class=\"line\">Position <span class=\"title function_\">doubleRotateWithLeft</span><span class=\"params\">(Position k)</span>&#123;</span><br><span class=\"line\">    k-&gt;left = singleRotate(k-&gt;left, ROTATE_R);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleRotate(k, ROTATE_L);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* R-L型双旋转 */</span></span><br><span class=\"line\">Position <span class=\"title function_\">doubleRotateWithRight</span><span class=\"params\">(Position k)</span>&#123;</span><br><span class=\"line\">    k-&gt;right = singleRotate(k-&gt;right, ROTATE_L);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleRotate(k, ROTATE_R);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 插入操作，插入后做平衡调整</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param tree </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return TreeNode*，新树的root节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">TreeNode* <span class=\"title function_\">insert</span><span class=\"params\">(TreeNode* tree, <span class=\"type\">int</span> x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">        tree = (TreeNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(TreeNode));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:out of memory\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tree-&gt;elem = x;</span><br><span class=\"line\">        tree-&gt;count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        tree-&gt;height = <span class=\"number\">0</span>;</span><br><span class=\"line\">        tree-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        tree-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> diff_height;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; tree-&gt;elem)&#123;</span><br><span class=\"line\">            tree-&gt;left = insert(tree-&gt;left, x);</span><br><span class=\"line\">            diff_height = height_lr_diff(tree);</span><br><span class=\"line\">            <span class=\"comment\">/* 插入之后判断是否需要调整平衡 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff_height == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">/* L-L型 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x &lt; tree-&gt;left-&gt;elem)&#123;</span><br><span class=\"line\">                    tree = singleRotate(tree, ROTATE_L);</span><br><span class=\"line\">                <span class=\"comment\">/* L-R型 */</span></span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; tree-&gt;left-&gt;elem)&#123;</span><br><span class=\"line\">                    tree = doubleRotateWithLeft(tree);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; tree-&gt;elem)&#123;</span><br><span class=\"line\">            tree-&gt;right = insert(tree-&gt;right, x);</span><br><span class=\"line\">            diff_height = height_lr_diff(tree);</span><br><span class=\"line\">            <span class=\"comment\">/* 插入之后判断是否需要调整平衡 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff_height == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">/* R-R型 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x &gt; tree-&gt;right-&gt;elem)&#123;</span><br><span class=\"line\">                    tree = singleRotate(tree, ROTATE_R);</span><br><span class=\"line\">                <span class=\"comment\">/* R-L型 */</span></span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &lt; tree-&gt;right-&gt;elem)&#123;</span><br><span class=\"line\">                    tree = doubleRotateWithRight(tree);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ++ tree-&gt;count;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree-&gt;height = height(tree);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TreeNode* <span class=\"title function_\">find</span><span class=\"params\">(TreeNode* tree, <span class=\"type\">int</span> x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == tree-&gt;elem)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &lt; tree-&gt;elem)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(tree-&gt;left, x);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(tree-&gt;right, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TreeNode* <span class=\"title function_\">findMin</span><span class=\"params\">(TreeNode* tree)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree-&gt;left)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findMin(tree-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TreeNode* <span class=\"title function_\">findMax</span><span class=\"params\">(TreeNode* tree)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree-&gt;right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findMax(tree-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief AVL树的删除，删除后需要做调整平衡</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param tree </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return TreeNode* ,新树的root节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">TreeNode* </span><br><span class=\"line\"><span class=\"title function_\">delete</span><span class=\"params\">(root, x)</span></span><br><span class=\"line\">TreeNode* root;<span class=\"type\">int</span> x;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Line:%d, error: node does not exist\\n&quot;</span>, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> height_diff;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; root-&gt;elem)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = delete(root-&gt;left, x);</span><br><span class=\"line\">        height_diff = height_lr_diff(root);</span><br><span class=\"line\">        <span class=\"comment\">/* 1.如果被删除的元素不是叶子节点，需要去高的子树中去找替代的叶子节点，</span></span><br><span class=\"line\"><span class=\"comment\">        然后删除叶子节点。</span></span><br><span class=\"line\"><span class=\"comment\">        2.如果本来要删除的就是叶子节点，那跟上面的后半部分动作一致。</span></span><br><span class=\"line\"><span class=\"comment\">        所以只有叶子节点被删除之后才会需要调整 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (height_diff == <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* x是删除的元素,删除后O是最小不平衡子树的root</span></span><br><span class=\"line\"><span class=\"comment\">                O</span></span><br><span class=\"line\"><span class=\"comment\">              /   \\</span></span><br><span class=\"line\"><span class=\"comment\">             x     o</span></span><br><span class=\"line\"><span class=\"comment\">                  /</span></span><br><span class=\"line\"><span class=\"comment\">                 o</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            <span class=\"comment\">/* 这种情况必须用双旋转，单旋转不能改变深度 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!root-&gt;right-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = doubleRotateWithRight(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">                O                       O   </span></span><br><span class=\"line\"><span class=\"comment\">              /   \\                   /   \\</span></span><br><span class=\"line\"><span class=\"comment\">             x     o         或者    x     o</span></span><br><span class=\"line\"><span class=\"comment\">                    \\                    /  \\</span></span><br><span class=\"line\"><span class=\"comment\">                     o                  o    o</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            <span class=\"comment\">/* 单旋转 */</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = singleRotate(root, ROTATE_R);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; root-&gt;elem)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = delete(root-&gt;right, x);</span><br><span class=\"line\">        height_diff = height_lr_diff(root);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (height_diff == <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* x是删除的元素,删除后O是最小不平衡子树的root</span></span><br><span class=\"line\"><span class=\"comment\">                   O</span></span><br><span class=\"line\"><span class=\"comment\">                 /   \\</span></span><br><span class=\"line\"><span class=\"comment\">                o     x</span></span><br><span class=\"line\"><span class=\"comment\">                 \\</span></span><br><span class=\"line\"><span class=\"comment\">                  o</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            <span class=\"comment\">/* 这种情况必须用双旋转，单旋转不能改变深度 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!root-&gt;left-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = doubleRotateWithLeft(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/*       O                  O</span></span><br><span class=\"line\"><span class=\"comment\">                   /   \\              /   \\</span></span><br><span class=\"line\"><span class=\"comment\">                  o     x   或者     o     x</span></span><br><span class=\"line\"><span class=\"comment\">                /   \\               /</span></span><br><span class=\"line\"><span class=\"comment\">               o     o             o</span></span><br><span class=\"line\"><span class=\"comment\">           */</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = singleRotate(root, ROTATE_L);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 左右子树都存在 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;count &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                --root-&gt;count;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 从高的子树中找到元素替换将要删除的节点位置，保证左右子树是平衡的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;left-&gt;height &gt; root-&gt;right-&gt;height)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">/* 在左子树中找到最大的值，也就是右子树是空的节点，将它移到将要删除的节点位置 */</span></span><br><span class=\"line\">                    TreeNode* tmp = findMax(root-&gt;left);</span><br><span class=\"line\">                    root-&gt;elem = tmp-&gt;elem;</span><br><span class=\"line\">                    root-&gt;count -= tmp-&gt;count;</span><br><span class=\"line\">                    <span class=\"comment\">/* 删除移动了元素的节点 */</span></span><br><span class=\"line\">                    root-&gt;left = delete(root-&gt;left, tmp-&gt;elem);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">/* 在右子树中找到最小的值，也就是左子树是空的节点，将它移到将要删除的节点位置 */</span></span><br><span class=\"line\">                    TreeNode* tmp = findMin(root-&gt;right);</span><br><span class=\"line\">                    root-&gt;elem = tmp-&gt;elem;</span><br><span class=\"line\">                    root-&gt;count -= tmp-&gt;count;</span><br><span class=\"line\">                    <span class=\"comment\">/* 删除移动了元素的节点 */</span></span><br><span class=\"line\">                    root-&gt;right = delete(root-&gt;right, tmp-&gt;elem);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 只存在一个子树,或者不存在子树 */</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TreeNode* tmpNode = root;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!root-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* 如果两个子树都是空，将right给root也没问题，因为right就是NULL */</span></span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(tmpNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;height = height(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 前序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param level </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">pre_order_traverse</span><span class=\"params\">(SearchTRee root, <span class=\"type\">int</span> level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d &quot;</span>, level, root-&gt;elem);</span><br><span class=\"line\">        pre_order_traverse(root-&gt;left, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        pre_order_traverse(root-&gt;right, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">2</span>,<span class=\"number\">84</span>,<span class=\"number\">69</span>,<span class=\"number\">98</span>,<span class=\"number\">73</span>,<span class=\"number\">62</span>,<span class=\"number\">20</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">    SearchTRee root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root = insert(root, arr[i]);</span><br><span class=\"line\">        pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    root = delete(root, <span class=\"number\">50</span>);</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    root = delete(root, <span class=\"number\">32</span>);</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    root = delete(root, <span class=\"number\">62</span>);</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    releaseSTree(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构与算法"],"tags":["查找二叉树","平衡查找二叉树"]},{"title":"win10下挂载阿里云网盘用于同步文件","url":"/2022/05/10/aliyun-driver-webdav/","content":"<p>收集了一些电子书，大部分是PDF文件，看的时候会直接在PDF文件上划一些重点和标注，这就需要一种能同步修改的方法。显然普通的存储网盘达不到要求，普通网盘要同步只能有点修改就上传，太麻烦。</p>\n<span id=\"more\"></span>\n<h3 id=\"尝试一-git仓库\"><a href=\"#尝试一-git仓库\" class=\"headerlink\" title=\"尝试一 git仓库\"></a>尝试一 git仓库</h3><p>首先想到的是github或者gitlab存储，修改后通过git push保存修改内容。但是书有2个G多，github单个仓库限额1G,gitlab虽然页面写着<code>git push and GitLab project imports are limited to 5 GB per request through Cloudflare.</code>但是实际测试了下，发现还是失败了。况且实际使用时还挺麻烦，还得自己commit，push，最终放弃了。</p>\n<h3 id=\"尝试二-百度网盘、坚果云、和彩云等的同步功能。\"><a href=\"#尝试二-百度网盘、坚果云、和彩云等的同步功能。\" class=\"headerlink\" title=\"尝试二 百度网盘、坚果云、和彩云等的同步功能。\"></a>尝试二 百度网盘、坚果云、和彩云等的同步功能。</h3><p>百度网盘自带有同步盘功能—同步空间。试了下还不错，还有同步记录，但是有流量限制，每个月1G，我这2G的电子书，完成同步需要2个月，太费劲了。包括坚果云也一样，有流量限制，放弃了。和彩云没有流量限制，但是网盘空间只给20G，太少了，万一以后东西多了之后，存不下。</p>\n<h3 id=\"尝试三-阿里云盘本地挂载\"><a href=\"#尝试三-阿里云盘本地挂载\" class=\"headerlink\" title=\"尝试三 阿里云盘本地挂载\"></a>尝试三 阿里云盘本地挂载</h3><p>想起之前给路由器刷OpenWrt的时候，有可以将阿里云盘挂载到路由器的插件，搜了搜，发现有win10下挂载阿里云盘的方法，挂载后在windows资源管理器中有盘符，跟访问本地磁盘一样，类似挂载samba的效果，可以说非常棒了。</p>\n<h4 id=\"一-需要的软件\"><a href=\"#一-需要的软件\" class=\"headerlink\" title=\"一.需要的软件\"></a>一.需要的软件</h4><ol>\n<li><a href=\"https://github.com/messense/aliyundrive-webdav\">https://github.com/messense/aliyundrive-webdav</a></li>\n<li><a href=\"https://www.raidrive.com/\">https://www.raidrive.com</a></li>\n</ol>\n<p><strong>基本的原理是，aliyundrive-webdav实现了阿里云盘的webdav,然后使用raildirve挂载webdav</strong>。</p>\n<h4 id=\"二-获取refresh-token\"><a href=\"#二-获取refresh-token\" class=\"headerlink\" title=\"二.获取refresh-token\"></a>二.获取refresh-token</h4><p>参考：<a href=\"https://github.com/messense/aliyundrive-webdav#%E8%8E%B7%E5%8F%96-refresh_token\">https://github.com/messense/aliyundrive-webdav#%E8%8E%B7%E5%8F%96-refresh_token</a><br>具体方法：  </p>\n<ol>\n<li>登录阿里云盘网页版，建议使用chromium内核的浏览器，chrome或者edge。</li>\n<li>按F12进调试模式，在<code>控制台</code>中输入<code>JSON.parse(localStorage.token).refresh_token</code>,即可看到refresh-token。<br><img src=\"https://user-images.githubusercontent.com/12248888/150632769-ea6b7a0f-4170-44d6-bafb-92b2a7c1726b.png\" alt=\"获取refresh-token\" title=\"refresh-token\"></li>\n</ol>\n<h4 id=\"三-下载aliyundrive-webdav-exe\"><a href=\"#三-下载aliyundrive-webdav-exe\" class=\"headerlink\" title=\"三.下载aliyundrive-webdav.exe\"></a>三.下载aliyundrive-webdav.exe</h4><p>前往<a href=\"https://github.com/messense/aliyundrive-webdav/releases\">https://github.com/messense/aliyundrive-webdav/releases</a>下载windows下的可执行文件压缩包，我的是64位win10，所以下载<code>aliyundrive-webdav-v1.3.2.x86_64-pc-windows-msvc.zip</code>，下载后解压得到<code>aliyundrive-webdav.exe</code>。</p>\n<h4 id=\"四-开机启动aliyundrive-webdav-exe\"><a href=\"#四-开机启动aliyundrive-webdav-exe\" class=\"headerlink\" title=\"四.开机启动aliyundrive-webdav.exe\"></a>四.开机启动aliyundrive-webdav.exe</h4><ol>\n<li>使用bat脚本运行aliyundrive-webdav.exe。新建txt文件，并写入：<figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\">::隐藏<span class=\"built_in\">cmd</span>窗口,但仍然会闪一下</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off </span><br><span class=\"line\"><span class=\"keyword\">if</span> &quot;%<span class=\"number\">1</span>&quot; == &quot;h&quot; <span class=\"keyword\">goto</span> begin </span><br><span class=\"line\">    mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;%~nx0 h&quot;,<span class=\"number\">0</span>)(window.close)&amp;&amp;<span class=\"keyword\">exit</span> </span><br><span class=\"line\">:begin </span><br><span class=\"line\">::下面是要执行的命令</span><br><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">Users</span>\\<span class=\"title\">Frank</span>\\<span class=\"title\">Downloads</span>\\<span class=\"title\">aliyundrive</span>-<span class=\"title\">webdav</span>-<span class=\"title\">v1</span>.3.2.<span class=\"title\">x86_64</span>-<span class=\"title\">pc</span>-<span class=\"title\">windows</span>-<span class=\"title\">msvc</span>\\<span class=\"title\">aliyundrive</span>-<span class=\"title\">webdav.exe</span> ^</span></span><br><span class=\"line\"><span class=\"function\">--<span class=\"title\">refresh</span>-<span class=\"title\">token</span> <span class=\"title\">xxxxxxxxxxxxxxx</span> ^</span></span><br><span class=\"line\"><span class=\"function\">--<span class=\"title\">port</span> 8080 ^</span></span><br><span class=\"line\"><span class=\"function\">--<span class=\"title\">auth</span>-<span class=\"title\">user</span> <span class=\"title\">admin</span> ^</span></span><br><span class=\"line\"><span class=\"function\">--<span class=\"title\">auth</span>-<span class=\"title\">password</span> <span class=\"title\">admin123</span> ^</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>说明：</p>\n<ul>\n<li><code>aliyundrive-webdav.exe</code>的路径根据自己的实际情况修改。</li>\n<li><code>refresh-token</code>就是第一步中获取的值</li>\n<li><code>port</code>端口号不要跟其他服务冲突</li>\n<li><code>auth-user</code>，<code>auth-password</code>的内容可以自定，这两项会在后面的RaiDrive软件中用到。</li>\n</ul>\n<ol start=\"2\">\n<li>将txt文件命名为<code>run_aliyun_dirver_webdav.bat</code>，并保存到合适的位置，右键单击创建一个快捷方式。</li>\n<li>按住<code>Ctrl + r</code>启动”运行”, 输入<code>shell:startup</code>并回车，会打开windows的开机启动文件夹，将快捷方式放入其中。</li>\n<li>双击快捷方式启动aliyundrive-webdav.exe</li>\n</ol>\n<h4 id=\"安装配置RaiDrive\"><a href=\"#安装配置RaiDrive\" class=\"headerlink\" title=\"安装配置RaiDrive\"></a>安装配置RaiDrive</h4><ol>\n<li>安装<br>不用多说了，去上面的官网下载安装就行。</li>\n<li>配置<br><img src=\"https://gitlab.com/iEngne/images/-/raw/main/2022/5/RaiDrive.png\" alt=\"RaiDrive配置\" title=\"RaiDrive配置界面\"></li>\n</ol>\n<ul>\n<li>storage选<code>NAS</code>-&gt;<code>WebDAV</code></li>\n<li><code>不要勾选&#39;Address&#39;</code>，否则变成https连接了。</li>\n<li>地址填”127.0.0.1”本地地址，端口号就是bat脚本中的端口号。</li>\n<li>Account就是bat脚本中的auth-user和auth-password。</li>\n<li>点击<code>connect</code></li>\n</ul>\n<p>资源管理器出现以下磁盘就表示成功了：<br><img src=\"https://gitlab.com/iEngne/images/-/raw/main/2022/5/aliyun-WebDAV.png\" alt=\"网盘挂载成功\" title=\"网盘挂载成功\"></p>\n<h4 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h4><ul>\n<li>直接从挂载盘打开PDF文件会有点慢，保存文件也会比较慢，复制大文件到挂载的盘速度挺快的，但是小文件速度很慢。</li>\n<li>修改文件后保存，会在文件相同目录生成一个隐藏文件夹，应该是同步文件的时候用的，但是没有删除，文件夹名应该是哈希值，<br><img src=\"https://gitlab.com/iEngne/images/-/raw/main/2022/5/WebDAV-bug1.png\"></li>\n<li>2022.05.12，发现重大bug，保存后部分文件内容被删了，PDF后面的页面都变成空白的了,不知道是aliyundrive-webdav的问题还是raidrive的问题，都不知道该往哪家提issue，算了，这个同步盘的方式放弃了。<br> <img src=\"https://gitlab.com/iEngne/images/-/raw/main/2022/5/WebDAV-bug.png\"></li>\n</ul>\n<p> <code>PS</code>:不过，WebDAV挂载阿里云盘拿来只读问题还是不错的，比如拿来看阿里云盘里的影视剧。<br>最终还是选择使用百度网盘的同步空间功能，使用这种成品稳定点，虽然只有1G的同步流量，这么多电子我也不会短时间内全部看完，先看到哪本同步哪本吧。</p>\n","categories":["瞎折腾"],"tags":["阿里云盘","WebDAV"]},{"title":"字节序中的位序","url":"/2022/06/09/bit_order/","content":"<h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><p>关于字节序很多书都有讲到，去网上搜字节序或者大端序、小端序，有很多介绍的文章，<br>但是这些文章基本只讲到大端序或者小端序中字节层面数据是如何存储的，没有讲到<br>位序是如何的。之前也没想过位序的问题，直到前段时间看到linux kernel中linux&#x2F;tcp.h的定义：</p>\n<span id=\"more\"></span>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcphdr</span> &#123;</span></span><br><span class=\"line\">\t__u16\tsource;</span><br><span class=\"line\">\t__u16\tdest;</span><br><span class=\"line\">\t__u32\tseq;</span><br><span class=\"line\">\t__u32\tack_seq;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(__LITTLE_ENDIAN_BITFIELD)</span></span><br><span class=\"line\">\t__u16\tres1:<span class=\"number\">4</span>,</span><br><span class=\"line\">\t\tdoff:<span class=\"number\">4</span>,</span><br><span class=\"line\">\t\tfin:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\tsyn:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\trst:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\tpsh:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\tack:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\turg:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\tece:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\tcwr:<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined(__BIG_ENDIAN_BITFIELD)</span></span><br><span class=\"line\">\t__u16\tdoff:<span class=\"number\">4</span>,</span><br><span class=\"line\">\t\tres1:<span class=\"number\">4</span>,</span><br><span class=\"line\">\t\tcwr:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\tece:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\turg:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\tack:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\tpsh:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\trst:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\tsyn:<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\tfin:<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">error</span>\t<span class=\"string\">&quot;Adjust your &lt;asm/byteorder.h&gt; defines&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span>\t</span></span><br><span class=\"line\">\t__u16\twindow;</span><br><span class=\"line\">\t__u16\tcheck;</span><br><span class=\"line\">\t__u16\turg_ptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到头文件使用两个宏(__LITTLE_ENDIAN_BITFIELD和__BIG_ENDIAN_BITFIELD)。<br>我们知道tcp头的结构如下：<img src=\"https://gitlab.com/iEngne/images/-/raw/main/2022/6/tcp_header_en.png\"><br>中文版：<img src=\"https://gitlab.com/iEngne/images/-/raw/main/2022/6/tcp_header.png\"><br>对比图片和上面定义的头文件可以看出，针对大端和小端系统，进行了不同的定义，说明在不同字节序中位序也是不同的。<br>具体可以看这两篇参考：</p>\n<blockquote>\n<p><a href=\"https://www.fileformat.info/mirror/egff/ch06_04.htm\">https://www.fileformat.info/mirror/egff/ch06_04.htm</a><br><a href=\"https://www.linuxjournal.com/article/6788\">https://www.linuxjournal.com/article/6788</a><br><a href=\"https://en.wikipedia.org/wiki/Endianness\">https://en.wikipedia.org/wiki/Endianness</a></p>\n</blockquote>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p><code>大端系统中的位序也是&quot;大端&quot;，小端系统中的位序也是&quot;小端&quot;</code>。<br>即对于<code>0x0a0b0c0d</code>这个四字节的整数，在内存中是如下存储的：<br>大端：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+-------------------------------------------------------+  </span><br><span class=\"line\">|               低地址    ----&gt;    高地址                |  </span><br><span class=\"line\">|-------------------------------------------------------|</span><br><span class=\"line\">|      0      |      1      |      2      |      3      |  </span><br><span class=\"line\">|-------------------------------------------------------|</span><br><span class=\"line\">|bit0 --&gt; bit7|bit0 --&gt; bit7|bit0 --&gt; bit7|bit0 --&gt; bit7|  </span><br><span class=\"line\">|-------------------------------------------------------|</span><br><span class=\"line\">|  00001010   |  00001011   |  00001100   |  00001101   |  </span><br><span class=\"line\">+-------------------------------------------------------+  </span><br></pre></td></tr></table></figure>\n<p>小端：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+-------------------------------------------------------+  </span><br><span class=\"line\">|               低地址    ----&gt;    高地址                |  </span><br><span class=\"line\">|-------------------------------------------------------|</span><br><span class=\"line\">|      0      |      1      |      2      |      3      |  </span><br><span class=\"line\">|-------------------------------------------------------|</span><br><span class=\"line\">|bit0 --&gt; bit7|bit0 --&gt; bit7|bit0 --&gt; bit7|bit0 --&gt; bit7|  </span><br><span class=\"line\">|-------------------------------------------------------|</span><br><span class=\"line\">|  10110000   |  00110000   |  11010000   |  01010000   |  </span><br><span class=\"line\">+-------------------------------------------------------+  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"验证大端系统中的位序\"><a href=\"#验证大端系统中的位序\" class=\"headerlink\" title=\"验证大端系统中的位序\"></a>验证大端系统中的位序</h2><p>我们现在接触到的大部分系统是小端系统，小端系统很好验证，大端系统就比较麻烦，为了验证大端系统，得通过qemu装大端的虚拟机来验证。<br>参考：</p>\n<blockquote>\n<p><a href=\"https://stackoverflow.com/questions/2839087/how-to-test-your-code-on-a-machine-with-big-endian-architecture\">https://stackoverflow.com/questions/2839087/how-to-test-your-code-on-a-machine-with-big-endian-architecture</a><br><a href=\"https://stackoverflow.com/questions/3337896/imitate-emulate-a-big-endian-behavior-in-c\">https://stackoverflow.com/questions/3337896/imitate-emulate-a-big-endian-behavior-in-c</a>  </p>\n</blockquote>\n<h3 id=\"0x00-安装qemu\"><a href=\"#0x00-安装qemu\" class=\"headerlink\" title=\"0x00. 安装qemu\"></a>0x00. 安装qemu</h3><p>去<a href=\"https://www.qemu.org/download/#windows\">https://www.qemu.org/download/#windows</a> 这个页面下载windows下的qemu,并安装，安装完后记得添加环境变量</p>\n<h3 id=\"0x01-下载模拟mips的debian镜像\"><a href=\"#0x01-下载模拟mips的debian镜像\" class=\"headerlink\" title=\"0x01. 下载模拟mips的debian镜像\"></a>0x01. 下载模拟mips的debian镜像</h3><p>mips芯片是大端的，所以我们模拟这个芯片去验证。<br>去<a href=\"https://people.debian.org/~aurel32/qemu/mips/\">https://people.debian.org/~aurel32/qemu/mips/</a>下载<code>vmlinux-3.2.0-4-5kc-malta</code>和<code>debian_wheezy_mips_standard.qcow2</code><br>根据页面的说明，打开cmd输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">qemu-system-mips64 -M malta -kernel vmlinux-3.2.0-4-5kc-malta -hda debian_wheezy_mips_standard.qcow2 -append <span class=\"string\">&quot;root=/dev/sda1 console=tty0&quot;</span> -m 256</span><br></pre></td></tr></table></figure>\n<p>来启动虚拟机，这里怕内存不够，加了<code>-m 256</code>的启动参数，测试发现即使使用|<code>-m 512</code>实际使用的内存也只有256M。</p>\n<h3 id=\"0x02-启动后发现没法联网\"><a href=\"#0x02-启动后发现没法联网\" class=\"headerlink\" title=\"0x02. 启动后发现没法联网\"></a>0x02. 启动后发现没法联网</h3><p>启动后想安装gcc，发现没法联网，这是第一次使用qemu，联网搞了半天。<br>找到以下解决方法，</p>\n<blockquote>\n<p>在 Windows 上使用 qemu 虚拟机，通过此配置，可以使 qemu 中的虚拟机能连接互联网，并且也可以和 Windows 主机通信。此方式类似于 Vmware 和 VitrualBox 中的桥接网卡。配置方法如下：</p>\n<ol>\n<li>在 Windows 主机上安装 TAP 网卡驱动: 可下载 openvpn 客户端软件，只安装其中的 TAP 驱动；在网络连接中，会看到一个新的网卡，属性类似于 TAP-Win32 Adapter…，将其名称修改为 tap0。</li>\n<li>将 tap0 虚拟网卡和 Windows 上连接互联网的真实网卡桥接: 选中这两块网卡，右键，桥接。此时，Windows 主机将不能连接互联网，需要在网桥上配置 IP 地址和域名等信息，才能使 Windows 主机连接互联网。</li>\n<li>qemu 配置: 在虚拟机启动命令行添加以下参数：–net nic -net tap,ifname&#x3D;tap0；启动虚拟机，并配置虚拟机中的网卡，则虚拟机也可以和 Windows 主机一样，连接互联网和 Windows 主机。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>参考：<a href=\"https://my.oschina.net/Czl6BQ6SEmYt/blog/164308\">https://my.oschina.net/Czl6BQ6SEmYt/blog/164308</a><br>我把TAP网卡重命名为my-tap，所以我的启动参数改为：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">qemu-system-mips64 -M malta -kernel vmlinux-3.2.0-4-5kc-malta -hda debian_wheezy_mips_standard.qcow2 -append <span class=\"string\">&quot;root=/dev/sda1 console=tty0&quot;</span> -m 256 -net nic -net tap,ifname=my-tap</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>，<code>tap和ifname之间只有一个逗号，不要加空格</code>，否则报错</p>\n<h3 id=\"0x03-换软件源\"><a href=\"#0x03-换软件源\" class=\"headerlink\" title=\"0x03. 换软件源\"></a>0x03. 换软件源</h3><p>终于能联网了，发现官方源失效了<img src=\"https://gitlab.com/iEngne/images/-/raw/main/2022/6/1.png\"><br>于是找到阿里云的镜像站中wheezy(Debian7.x)的源替换。<br>备份官方源  </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@debian-mips:~<span class=\"comment\"># cp /etc/apt/sources.list /etc/apt/sources.list.backup</span></span><br></pre></td></tr></table></figure>\n<p>创建新文件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@debian-mips:~<span class=\"comment\"># vi /etc/apt/sources.list</span></span><br></pre></td></tr></table></figure>\n<p>写入</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># deb http://ftp.debian.org/debian wheezy main</span></span><br><span class=\"line\">deb http://mirrors.aliyun.com/debian-archive/debian/ wheezy main non-free contrib</span><br><span class=\"line\">deb http://mirrors.aliyun.com/debian-archive/debian/ wheezy-proposed-updates main non-free contrib</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/debian-archive/debian/ wheezy main non-free contrib</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/debian-archive/debian/ wheezy-proposed-updates main non-free contrib</span><br></pre></td></tr></table></figure>\n<p>更新apt缓存，安装gcc</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@debian-mips:~<span class=\"comment\"># apt-get update</span></span><br><span class=\"line\">root@debian-mips:~<span class=\"comment\"># apt-get install gcc</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"0x04-开始验证\"><a href=\"#0x04-开始验证\" class=\"headerlink\" title=\"0x04. 开始验证\"></a>0x04. 开始验证</h3><p>测试代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">int</span> a:<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">int</span> b:<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">int</span> c:<span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">int</span> d:<span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span> &#123;</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">int</span> a:<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">int</span> b:<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">int</span> c:<span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">int</span> d:<span class=\"number\">6</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">C</span> &#123;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> a;</span><br><span class=\"line\">        <span class=\"type\">int</span> b;</span><br><span class=\"line\">        <span class=\"type\">int</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">foo</span><span class=\"params\">(<span class=\"type\">int</span> *p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> a2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&amp;a1:%p, &amp;a2:%p\\n&quot;</span>, &amp;a1, &amp;a2);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x[]=&#123;<span class=\"number\">0b10101010110010101000101110110011</span>, <span class=\"number\">0xbbbbbbbb</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> h, i, j;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&amp;h:%p, &amp;i:%p, &amp;j:%p\\n&quot;</span>, &amp;h, &amp;i ,&amp;j);</span><br><span class=\"line\">        <span class=\"type\">char</span> y[] = &#123;<span class=\"number\">0b11010</span>, <span class=\"number\">0b11011</span>, <span class=\"number\">0b11100</span>, <span class=\"number\">0b11101</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span>* p = (<span class=\"type\">int</span>*)y;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*p = %#x\\n&quot;</span>, *p);</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span>* <span class=\"title\">m</span> =</span> (<span class=\"keyword\">struct</span> A*)&amp;x;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span>* <span class=\"title\">n</span> =</span> (<span class=\"keyword\">struct</span> B*)&amp;x;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;m:%p\\n&quot;</span>, m);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;n:%p\\n&quot;</span>, n);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;m:%#x, %#x,%#x, %#x,%#x\\n&quot;</span>, m-&gt;a,m-&gt;b, m-&gt;c, m-&gt;d);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;n:%#x, %#x,%#x, %#x,%#x\\n&quot;</span>, n-&gt;a,n-&gt;b, n-&gt;c, n-&gt;d);</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">C</span> <span class=\"title\">c</span>;</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&amp;c.a:%p, &amp;c.b:%p, &amp;c.c:%p\\n&quot;</span>, &amp;c.a, &amp;c.b, &amp;c.c);</span><br><span class=\"line\">        foo(p);</span><br><span class=\"line\">        <span class=\"type\">int</span> * po1 = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> * po2 = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;po1:%p, po2%p\\n&quot;</span>, po1, po2);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(po1);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(po2);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@debian-mips:~<span class=\"comment\"># ./a.out</span></span><br><span class=\"line\">&amp;h:0x7fba3df4, &amp;i:0x7fba3df8, &amp;j:0x7fba3dfc</span><br><span class=\"line\">*p = 0x1a1b1c1d</span><br><span class=\"line\">m:0x7fba3dec</span><br><span class=\"line\">n:0x7fba3dec</span><br><span class=\"line\">m:0x5, 0, 0xa, 0x19,0x77667000</span><br><span class=\"line\">n:0x5, 0x1, 0xb, 0xa,0x77667000</span><br><span class=\"line\">&amp;c.a:0x7fba3e04, &amp;c.b:0x7fba3e08, &amp;c.c:0x7fba3e0c</span><br><span class=\"line\">&amp;a1:0x7fba3da8, &amp;a2:0x7fba3dac</span><br><span class=\"line\">po1:0x81f008, po20x81f020</span><br></pre></td></tr></table></figure>\n<p>因为使用位序的结构体成员不能通过&amp;符号取到地址，所以只能再使用一个struct C来验证结构体内的成员地址是怎么分配的，从c.a,c.b,c.c的地址是递增的，说明在大端系统中，结构体内的成员的地址按照书写顺序递增的。<br>m-&gt;a占3bit，数值是<code>0x5</code> —–&gt; <code>101</code>01010110010101000101110110011<br>m-&gt;b占1bit，数值是<code>0x0</code> —–&gt; 101<code>0</code>1010110010101000101110110011<br>m-&gt;c占4bit，数值是<code>0xa</code> —–&gt; 1010<code>1010</code>110010101000101110110011<br>m-&gt;d占5bit，数值是<code>0x19</code> —-&gt; 10101010<code>11001</code>0101000101110110011<br>从以上可以看出，m中a,b,c,d四个成员变量的地址应该是递增，它们对应的数值在二进制也是依次从高位往低位排。这说明，在内存中，<code>二进制数10101010110010101000101110110011的高位数值在低地址的低bit位</code>。即  </p>\n<p>在小端系统中的结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">●●●E:\\workspace\\code\\alg_practice\\<span class=\"built_in\">test</span>*master&gt;$ .\\a.exe</span><br><span class=\"line\">&amp;h:000000a1089ffb48, &amp;i:000000a1089ffb44, &amp;j:000000a1089ffb40</span><br><span class=\"line\">sizeof(struct A):4</span><br><span class=\"line\">m:000000a1089ffb50</span><br><span class=\"line\">n:000000a1089ffb50</span><br><span class=\"line\">m:0x3, 0, 0xb, 0xb</span><br><span class=\"line\">n:0x3, 0x2, 0x1d, 0x22</span><br><span class=\"line\">*p:0x1d1c1b1a</span><br><span class=\"line\">000000a1089ffb4c, 000000a1089ffb4d, 000000a1089ffb4e, 000000a1089ffb4f&amp;c.a:000000a1089ffb34, &amp;c.b:000000a1089ffb38, &amp;c.c:000000a1089ffb3c</span><br><span class=\"line\">&amp;a1:000000a1089ffaec, &amp;a2:000000a1089ffae8</span><br><span class=\"line\">po1:000002858a656cd0, po2000002858a656cf0</span><br></pre></td></tr></table></figure>\n<p>m-&gt;a占3bit，数值是<code>0x3</code> —–&gt; 10101010110010101000101110110<code>011</code><br>m-&gt;b占1bit，数值是<code>0x0</code> —–&gt; 1010101011001010100010111011<code>0</code>011<br>m-&gt;c占4bit，数值是<code>0xb</code> —–&gt; 101010101100101010001011<code>1011</code>0011<br>m-&gt;d占5bit，数值是<code>0xb</code> —–&gt; 10101010110010101000<code>1011</code>10110011<br>说明小端字节序的位序也是小端的。</p>\n","categories":["开发日常"],"tags":["C语言"]},{"title":"C语言中复杂类型的声明","url":"/2022/04/28/c-complex-declaration/","content":"<p>犹记得当第一次看见c的signal函数的原型的时候，懵逼了，这是个啥啊</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"title function_\">void</span> <span class=\"params\">(*<span class=\"type\">sighandler_t</span>)</span><span class=\"params\">(<span class=\"type\">int</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">sighandler_t</span> <span class=\"title function_\">signal</span><span class=\"params\">(<span class=\"type\">int</span> signum, <span class=\"type\">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>现在知道了，借助typedef声明了一个函数指针类型取名叫sighandler_t，这个函数指针<br>返回值是void，入参是int。然后声明了signal函数，signal函数的返回值是sighandler_t<br>这个类型的函数指针。<br>typedef可以帮我们简化复杂类型的声明，在不借助typedef的情况下，c语言应该怎么声明复杂的类型呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 复习关于C语言复杂类型的声明定义</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * c语言语法中，[]、()的优先级最高，[]、()写在标识符的右侧，*号和基本类型，如int,char,struct等</span></span><br><span class=\"line\"><span class=\"comment\">     * 写在标识符左侧,对声明定义的解析是右左原则。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指针p指向一个有20个char类型元素的数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">char</span> (*p)[<span class=\"number\">20</span>];</span><br><span class=\"line\">    p=(<span class=\"type\">char</span>(*)[<span class=\"number\">20</span>])<span class=\"built_in\">malloc</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> (*p_a)[<span class=\"number\">20</span>] = &amp;a;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 二级指针就多加个*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (**pp_a)[<span class=\"number\">20</span>] = &amp;p_a;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"title function_\">int</span><span class=\"params\">(*p_array)</span>[];</span><br><span class=\"line\">    p_array * p_c = &amp;p_a;<span class=\"comment\">// 跟int (**pp_a)[20] = &amp;p_a;等效</span></span><br><span class=\"line\">    p_array** p_d = &amp;p_c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> *b[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> *(*p_b)[<span class=\"number\">20</span>] = &amp;b;</span><br><span class=\"line\">    <span class=\"type\">int</span> *(**p_e)[<span class=\"number\">20</span>] = &amp;p_b;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*************************************/</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个数组，数组有20个元素，每个元素是指向int类型的二级指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>** f[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个指针，该指针指向一个数组，该数组有20个元素，每个元素是指向int类型的二级指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>** (*p_f)[<span class=\"number\">20</span>] = &amp;f;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个20个元素的数组g，该数组的每个元素是一个指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该指针指向一个有10个元素的数组,该数组的元素是指向char*</span></span><br><span class=\"line\"><span class=\"comment\">     * 类型的指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">char</span> *(*g[<span class=\"number\">20</span>])[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个20个元素的数组，数组的每一个元素是一个指针，该指针是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该函数指针指向的函数，入参为int,返回值是int</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*h[<span class=\"number\">20</span>])(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个函数指针func，指向的函数没有入参，返回值是一个指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该指针指向一个二维数组，该二维数组的每一元素是一个int* 指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *(*(*func)(<span class=\"type\">void</span>))[][<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个函数指针func_a，指向的函数入参是int,返回值是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该函数指针指向的函数入参是int,返回值是int*</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.首先是个指针,所以在左侧加*号，得到*func_a</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.变成函数指针，入参是int，得到(*func_a)(int)</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.返回值是函数指针，那么把2的结果作为一个整体看待，看作是标识符,</span></span><br><span class=\"line\"><span class=\"comment\">     *   再在左侧加*号，后边加(int),得到(*(*func_)(int))(int)</span></span><br><span class=\"line\"><span class=\"comment\">     * 4.返回值的函数指针指向的函数返回值是int*，所以再在左边加上int*，</span></span><br><span class=\"line\"><span class=\"comment\">     * 最后得到 int *(*(*func_a)(int))(int)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *(*(*func_a)(<span class=\"type\">int</span>))(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个数组指针pg，该指针指向一个20个元素的数组，该数组的元素是</span></span><br><span class=\"line\"><span class=\"comment\">     * 函数指针，该函数指针指向的函数，入参是int,返回值是int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">     <span class=\"type\">int</span> (*(*pg)[<span class=\"number\">20</span>])(<span class=\"type\">int</span>);</span><br><span class=\"line\">     pg = &amp;h;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个函数指针func_b，指向的函数入参是int，返回值是一个指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该指针指向一个20个元素的数组，该数组的元素是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该函数指针指向的函数，入参是int,返回值是int.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">     <span class=\"type\">int</span> (*(*(*func_b)(<span class=\"type\">int</span> b))[<span class=\"number\">20</span>])(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 定义一个数组指针ph,指向一个有20个元素的数组，该数组的元素是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">      * 该指针指向一个函数，该函数的入参是int,返回值是指针，该指针指向一个10</span></span><br><span class=\"line\"><span class=\"comment\">      * 个元素的数组，该元素char *</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"type\">char</span>* (*(*(*ph)[<span class=\"number\">20</span>])(<span class=\"type\">int</span>))[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 定义一个函数指针func_d，入参是int,返回值是函数指针，该函数指针指向的函数</span></span><br><span class=\"line\"><span class=\"comment\">      * 入参是short, 返回值是一个指向包含15个char*类型的数组的指针</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">      <span class=\"type\">char</span> *(*(*(*func_d)(<span class=\"type\">int</span>))(<span class=\"type\">short</span>))[<span class=\"number\">15</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["开发日常"],"tags":["C语言"]},{"title":"github fork 项目同步上游","url":"/2022/01/13/fork-merge/","content":"<p>虽然github已经在网页上增加了<strong>fetch upstream</strong>功能，但如果有冲突，只能手动merge.<br>以下记录一次手动合并的过程：</p>\n<span id=\"more\"></span>\n<hr>\n<ul>\n<li>clone 自己fork的仓库<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-16:47:17-&gt;&gt;~/workspace<span class=\"comment\"># git clone git@github.com:iEngne/now-subconverter.git</span></span><br><span class=\"line\">Cloning into <span class=\"string\">&#x27;now-subconverter&#x27;</span>...</span><br><span class=\"line\">remote: Enumerating objects: 1514, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Counting objects: 100% (121/121), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Compressing objects: 100% (110/110), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Total 1514 (delta 24), reused 57 (delta 5), pack-reused 1393</span><br><span class=\"line\">Receiving objects: 100% (1514/1514), 46.51 MiB | 991.00 KiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Resolving deltas: 100% (636/636), <span class=\"keyword\">done</span>.</span><br></pre></td></tr></table></figure></li>\n<li>确认当前分支是否是要合并的分支，<code>git brakch -a</code>，如果不是切换到相应的分支。<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:11:23-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git branch  -a</span></span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/HEAD -&gt; origin/master</span><br></pre></td></tr></table></figure></li>\n<li>设置<strong>upstream</strong>.<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-16:48:43-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git remote add upstream https://github.com/zhongfly/now-subconverter.git</span></span><br><span class=\"line\">♥root-16:51:15-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git remote -v</span></span><br><span class=\"line\">origin  git@github.com:iEngne/now-subconverter.git (fetch)</span><br><span class=\"line\">origin  git@github.com:iEngne/now-subconverter.git (push)</span><br><span class=\"line\">upstream        https://github.com/zhongfly/now-subconverter.git (fetch)</span><br><span class=\"line\">upstream        https://github.com/zhongfly/now-subconverter.git (push)</span><br></pre></td></tr></table></figure></li>\n<li>从远程取出<strong>upstream</strong><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-16:51:20-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git fetch upstream</span></span><br><span class=\"line\">remote: Enumerating objects: 32, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Counting objects: 100% (32/32), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Compressing objects: 100% (20/20), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Total 26 (delta 15), reused 17 (delta 6), pack-reused 0</span><br><span class=\"line\">Unpacking objects: 100% (26/26), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">From https://github.com/zhongfly/now-subconverter</span><br><span class=\"line\"> * [new branch]      master     -&gt; upstream/master</span><br></pre></td></tr></table></figure></li>\n<li>查看下分支情况，<code>git branch -a</code><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:29:13-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git branch  -a</span></span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/HEAD -&gt; origin/master</span><br><span class=\"line\">  remotes/origin/master</span><br><span class=\"line\">  remotes/upstream/master</span><br></pre></td></tr></table></figure></li>\n<li>执行合并<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:31:27-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git merge upstream/master</span></span><br><span class=\"line\">warning: Cannot merge binary files: subconverter/subconverter.exe (HEAD vs. upstream/master)</span><br><span class=\"line\">Auto-merging subconverter/subconverter.exe</span><br><span class=\"line\">CONFLICT (content): Merge conflict <span class=\"keyword\">in</span> subconverter/subconverter.exe</span><br><span class=\"line\">Auto-merging subconverter/snippets/emoji.toml</span><br><span class=\"line\">CONFLICT (add/add): Merge conflict <span class=\"keyword\">in</span> subconverter/snippets/emoji.toml</span><br><span class=\"line\">Auto-merging subconverter/pref.example.toml</span><br><span class=\"line\">CONFLICT (add/add): Merge conflict <span class=\"keyword\">in</span> subconverter/pref.example.toml</span><br><span class=\"line\">Automatic merge failed; fix conflicts and <span class=\"keyword\">then</span> commit the result.</span><br></pre></td></tr></table></figure></li>\n<li>查看冲突<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:31:44-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git status</span></span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># You have unmerged paths.</span></span><br><span class=\"line\"><span class=\"comment\">#   (fix conflicts and run &quot;git commit&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Unmerged paths:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#       both added:         subconverter/pref.example.toml</span></span><br><span class=\"line\"><span class=\"comment\">#       both added:         subconverter/snippets/emoji.toml</span></span><br><span class=\"line\"><span class=\"comment\">#       both modified:      subconverter/subconverter.exe</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">no changes added to commit (use <span class=\"string\">&quot;git add&quot;</span> and/or <span class=\"string\">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n<li>直接从GUI界面打开文件修改冲突，或者使用<code>git mergetool</code>命令从命令行打开merge工具，如果有装VIM默认调用vimdiff.  </li>\n<li>修改后<strong>commit</strong>和<strong>push</strong>就OK.</li>\n</ul>\n","categories":["开发日常"],"tags":["github"]},{"title":"二叉堆","url":"/2022/05/05/heap/","content":"<blockquote>\n<p>二叉堆（英语：binary heap）是一种特殊的堆，二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足堆特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。<br>当父节点的键值总是大于或等于任何一个子节点的键值时为“最大堆”。当父节点的键值总是小于或等于任何一个子节点的键值时为“最小堆”。—-Wikipedia</p>\n</blockquote>\n<span id=\"more\"></span>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @file heap.c</span></span><br><span class=\"line\"><span class=\"comment\"> * @author your name (you@domain.com)</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 二叉堆，二叉堆一般使用使用数组实现，在逻辑结构上又具有二叉树的特征，</span></span><br><span class=\"line\"><span class=\"comment\"> * 数组下标一般从1开始，这样对于任意的下标为i的非叶子节点，它的左子节点下标是2i,右子节点是2i+1。</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果数组下标从0开始，这样对于任意的下标为i的非叶子节点，它的左子节点下标是2i+1,右子节点是2i+2。</span></span><br><span class=\"line\"><span class=\"comment\"> * @version 0.1</span></span><br><span class=\"line\"><span class=\"comment\"> * @date 2022-04-15</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @copyright Copyright (c) 2022</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\">    <span class=\"type\">int</span>* heap;</span><br><span class=\"line\">&#125; HeapStruct;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">HeapStruct* <span class=\"title function_\">initialize</span><span class=\"params\">(<span class=\"type\">int</span> maxSize)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HeapStruct* h = (HeapStruct*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(HeapStruct));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!h)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h-&gt;capacity = maxSize;</span><br><span class=\"line\">    h-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    h-&gt;heap = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>((maxSize + <span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>)); <span class=\"comment\">/**&lt; 加1是因为数组从下标1开始，空间要多一个 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!h-&gt;heap)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">deinitialize</span><span class=\"params\">(HeapStruct* h)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h-&gt;heap)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(h-&gt;heap);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 在堆中插入数据，使用上滤percolate up</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param h </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">(HeapStruct* h, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h-&gt;size == h-&gt;capacity)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = ++h-&gt;size;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; (i &gt;&gt; <span class=\"number\">1</span>) &gt;= <span class=\"number\">1</span> &amp;&amp; h-&gt;heap[i &gt;&gt; <span class=\"number\">1</span>] &gt; x; i &gt;&gt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        h-&gt;heap[i] = h-&gt;heap[i &gt;&gt; <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h-&gt;heap[i] = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 删除最小元素，下滤</span></span><br><span class=\"line\"><span class=\"comment\"> * 上滤或者下滤过程类似于插入排序</span></span><br><span class=\"line\"><span class=\"comment\"> * @param h </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">deleteMin</span><span class=\"params\">(HeapStruct* h)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h-&gt;size == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;no element\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">int</span> min = h-&gt;heap[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> child;</span><br><span class=\"line\">    <span class=\"type\">int</span> lastOne = h-&gt;heap[h-&gt;size];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i * <span class=\"number\">2</span> &lt;= h-&gt;size;i = child)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        child = i * <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">/* 找到左右child中的最小者 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child &lt; h-&gt;size &amp;&amp; h-&gt;heap[child + <span class=\"number\">1</span>] &lt; h-&gt;heap[child])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 删除的时候，一定会有一个位置空出来，</span></span><br><span class=\"line\"><span class=\"comment\">           使用左右子元素和最后一个元素三者间最小的元素去填充</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastOne &gt; h-&gt;heap[child])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            h-&gt;heap[i] = h-&gt;heap[child];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h-&gt;heap[i] = lastOne;</span><br><span class=\"line\">    --h-&gt;size;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">array</span>[] = &#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    HeapStruct* h = initialize(<span class=\"keyword\">sizeof</span>(<span class=\"built_in\">array</span>)/<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(<span class=\"built_in\">array</span>)/<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insert(h, <span class=\"built_in\">array</span>[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(<span class=\"built_in\">array</span>)/<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d,&quot;</span>, h-&gt;heap[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (h-&gt;size &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, deleteMin(h));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    deinitialize(h);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构与算法"]},{"title":"质数判断和筛质数","url":"/2022/04/29/prime-number/","content":"<p>给定一定范围的自然数，找出里面所有的质数主要有2种方式：</p>\n<ol>\n<li>遍历每一个数并判断是不是质数，如果是就存起来。</li>\n<li>借助一定的算法直接筛选。<span id=\"more\"></span></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdbool.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;math.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/******************判断质数**********************/</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 枚举法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 版本1：根据质数的定义，对于大于2的自然数n，从2开始到n-1看是否存在能整除n的数，</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果存在，则是合数，否则为质数</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 版本2：无需判断从2~n-1的所有数，只需要判断2~n的平方根的数是否能整除就行</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 版本3：对于所有大于3的质数具有6n+1(n &gt;= 1)或者6n-1的性质</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 结合2和3的代码示例，时间复杂度O(sqrt(n))</span></span><br><span class=\"line\"><span class=\"comment\">// leetcode中，计算从1到709486有几个质数，耗时28ms</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">isPrime3</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span> || n == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n % <span class=\"number\">6</span> != <span class=\"number\">1</span> &amp;&amp; n % <span class=\"number\">6</span> != <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">5</span>; i &lt;= j; i += <span class=\"number\">6</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 形如6k+1(k &gt;= 1)或者6k-1的合数，一定可以被6m+1或者6m-1的数所整除</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为合数肯定可以因式分解，而所有的质数都形如6m + 1 或者6m - 1(m &gt;=1)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n % i == <span class=\"number\">0</span> || n % (i + <span class=\"number\">2</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 分解质因数-短除法</span></span><br><span class=\"line\"><span class=\"comment\"> * 版本1：要从最小的质数除起（依次除于质数2 3 5....)一直到n，时间复杂度为O(n)</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 版本2：n中最多只含有一个大于sqrt(n)的质因子。</span></span><br><span class=\"line\"><span class=\"comment\"> *       证明：通过反证法：如果有两个大于sqrt(n)的因子，那么相乘会大于n，矛盾。证毕</span></span><br><span class=\"line\"><span class=\"comment\"> *       于是我们发现最多只有一个大于sqrt(n)的因子，对其进行优化。先考虑比sqrt(n)小的，代码和质数的判定类似</span></span><br><span class=\"line\"><span class=\"comment\"> *       最后如果n还是&gt;1，说明此时的n就是大于sqrt(n)的唯一质因子，输出即可，时间复杂度O(sqrt(n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 这种方法，运算次数太多，还不如枚举法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">divide1</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 证明一下循环里面的i一定是一个质数：假如 i 是一个合数，</span></span><br><span class=\"line\">        <span class=\"comment\">// 那么它一定可以分解成多个质因子相乘的形式，</span></span><br><span class=\"line\">        <span class=\"comment\">// 这多个质因子同时也是 n 的质因子且比i要小，</span></span><br><span class=\"line\">        <span class=\"comment\">// 而比i小的数在之前的循环过程中一定是被条件除完了的，所以i不可能是合数，只可能是质数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n % i == <span class=\"number\">0</span>)<span class=\"comment\">//i一定是质数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(n % i == <span class=\"number\">0</span>)<span class=\"comment\">//短除法分解质因数</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                n /= i;</span><br><span class=\"line\">                ++s;<span class=\"comment\">//统计质因数的个数</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s &gt; <span class=\"number\">1</span>? <span class=\"literal\">false</span>:<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用此方法，leetcode中，计算从1到709486有几个质数，耗时408ms</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">divide2</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n / i; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n % i == <span class=\"number\">0</span>)<span class=\"comment\">//i一定是质数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//s = 0;</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(n % i == <span class=\"number\">0</span>)<span class=\"comment\">//短除法分解质因数</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                n /= i;</span><br><span class=\"line\">                ++s;<span class=\"comment\">//统计质因数的个数</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//printf(&quot;%d %d\\n&quot;, i, s);</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//if(n &gt; 1) printf(&quot;%d %d\\n&quot;, n, 1);//当n没有变化的时候，输出本身和1</span></span><br><span class=\"line\">    n &gt; <span class=\"number\">1</span>? ++s:s; <span class=\"comment\">// n还是大于1的，说明此时的n就是一个质数，s需要加1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s &gt; <span class=\"number\">1</span>? <span class=\"literal\">false</span>:<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">countPrimes</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">        divide1(i)?++res:res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///////////////////////////筛质数///////////////////////////</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 朴素筛法</span></span><br><span class=\"line\"><span class=\"comment\"> * 枚举i：2~n，从前往后把每个数对应的倍数都删除掉，这样筛过之后，所有剩下的数都是质数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//朴素筛法-O(nlogn)</span></span><br><span class=\"line\"><span class=\"comment\">// leetcode n=709486时耗时28ms</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">countPrimes1</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储质数</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* primeNums = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(n * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 标记</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* flag = (<span class=\"type\">int</span>*)<span class=\"built_in\">calloc</span>(n + <span class=\"number\">1</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag[i])&#123;</span><br><span class=\"line\">            primeNums[count++] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将所有i的倍数都标记，这些标记的数肯定是合数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i + i; j &lt; n; j += i)&#123;</span><br><span class=\"line\">            flag[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(primeNums);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(flag);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">埃氏筛法是对朴素筛法的一种优化方式，我们并不需要把2~n的每一个数的倍数都删掉，可以只把所有质数的倍数删掉！</span></span><br><span class=\"line\"><span class=\"comment\">因为合数的倍数，肯定也是比这个合数小的质数的某个倍数</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度：O(n * loglogn)，近似O(n)</span></span><br><span class=\"line\"><span class=\"comment\"> * // leetcode n = n=709486时耗时8ms</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">countPrimes2</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储质数</span></span><br><span class=\"line\">    <span class=\"comment\">//int* primeNums = (int*)malloc(n * sizeof(int));</span></span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 标记</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* flag = (<span class=\"type\">int</span>*)<span class=\"built_in\">calloc</span>(n, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 进入这个if条件的都是质数，合数都在之前的循环中被标记为true了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag[i])&#123;</span><br><span class=\"line\">            <span class=\"comment\">// primeNums[count++] = i;</span></span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">            <span class=\"comment\">// 将所有i的倍数都标记，这些标记的数肯定是合数</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i + i; j &lt; n; j += i)&#123;</span><br><span class=\"line\">                flag[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//free(primeNums);</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(flag);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">线性（欧拉）筛法</span></span><br><span class=\"line\"><span class=\"comment\">埃氏筛法的缺陷 ：对于一个合数，有可能被筛多次。例如 30 = 2 * 15 = 3 * 10 = 5*6……</span></span><br><span class=\"line\"><span class=\"comment\">那么如何确保每个合数只被筛选一次呢？我们只要用它的最小质因子来筛选即可，这便是欧拉筛法。</span></span><br><span class=\"line\"><span class=\"comment\">欧拉筛法的基本思想 ：在埃氏筛法的基础上，让每个合数只被它的最小质因子筛选一次，以达到不重复的目的。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">countPrimes3</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储质数</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* primeNums = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(n * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 标记合数</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* flag = (<span class=\"type\">int</span>*)<span class=\"built_in\">calloc</span>(n, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将数从小到大遍历的过程中，没被标记的数一定是质数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag[i])&#123;</span><br><span class=\"line\">            primeNums[count++] = i;</span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 以下这组循环，意思是以一个固定的倍数i去乘以不同的质数，并加上0 == i % primeNums[j]判断来保证</span></span><br><span class=\"line\">        <span class=\"comment\">// 这些数是以primeNums[j]为最小质因数的合数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; i * primeNums[j] &lt; n; ++j)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// primeNums[]存放的是从小到大排列的质数，i在内循环中都是不变的，</span></span><br><span class=\"line\">            <span class=\"comment\">// i作为一个倍数去乘以质数来得到不同的合数。当j从0开始遍历的时候，</span></span><br><span class=\"line\">            <span class=\"comment\">// 一开始的一次或几次循环中，i * primeNums[j]得到的合数，肯定是以</span></span><br><span class=\"line\">            <span class=\"comment\">// primeNums[j]为最小质因数的。那么这些数都可以打上标记。i % primeNums[j] == 0</span></span><br><span class=\"line\">            <span class=\"comment\">// 是在判断primeNums[j]是不是i的最小质因数。当j继续增大，</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果出现某个i0可以被某个primeNums[j0]整除，说明此时i0可以分解成</span></span><br><span class=\"line\">            <span class=\"comment\">// primeNums[j0]和一个比primeNums[j0]大的质数的乘积，我们将这个比primeNums[j0]大</span></span><br><span class=\"line\">            <span class=\"comment\">// 的数称为primeNums[j1]。此时，</span></span><br><span class=\"line\">            <span class=\"comment\">// i0 * primeNums[j0] = primeNums[j0] * primeNums[j1] * primeNums[j0](其中j1 &gt; j0)。</span></span><br><span class=\"line\">            <span class=\"comment\">// primeNums[j0]的值还是i0 * primeNums[j0]这个合数的最小质因数，但是下一次循环，</span></span><br><span class=\"line\">            <span class=\"comment\">// 也就是i0 * primeNums[k0](其中k0 = j0 + 1)，却不是以primeNums[k0]为最小质因数的合数了，</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为i0 * primeNums[k0] = primeNums[j0] * primeNums[j1] * primeNums[k0],</span></span><br><span class=\"line\">            <span class=\"comment\">// 这里最小的质数是primeNums[j0],i0已经可以被上一次循环的primeNums[j0]因式分解。</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果仍然标记flag[i0 * primeNums[k0]] = 1,会造成重复标记。因为</span></span><br><span class=\"line\">            <span class=\"comment\">// 令i_ = primeNums[j1] * primeNums[k0] &gt; i0, i0 * primeNums[k0] = i_ * primeNums[j0],</span></span><br><span class=\"line\">            <span class=\"comment\">// 即当外层循环递增到i_时，又会标记一次i0 * primeNums[k0]这个合数。</span></span><br><span class=\"line\">            <span class=\"comment\">// 所以当i % primeNums[j] == 0时，应该推出循环了。</span></span><br><span class=\"line\">            flag[i * primeNums[j]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// j继续增大，会不会一直找不到primeNums[j]可以整除i,不可能，为什么？</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为小于等于i的质数都在primeNums中，</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果i是合数，合数一定可以因式分解，一定存在小于i的质数能整除i，</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果i是质数，那么i已经放在了primeNums中，正好是最后一个，</span></span><br><span class=\"line\">            <span class=\"comment\">// 质数当然可以被自己整除。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"number\">0</span> == i % primeNums[j]))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(primeNums);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(flag);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">709486</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        n = atoi(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;count:%d\\n&quot;</span>, countPrimes2(n));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构与算法"],"tags":["数学","质数"]},{"title":"一些经典排序算法的实现","url":"/2022/05/05/sort/","content":"<p>冒泡排序、选择排序、插入排序、堆排序、希尔排序、计数排序、归并排序、快速排序、桶排序、基数排序<br>各排序算法的时间复杂度：</p>\n<span id=\"more\"></span>\n<p><img src=\"https://gitlab.com/iEngne/images/-/raw/main/2022/5/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png\" alt=\"各排序算法的时间复杂度\" title=\"各排序算法的时间复杂度\"></p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序在1956年就已经被研究，不用多说了，经典中的经典了。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>* a, <span class=\"type\">int</span>* b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != b)&#123;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">        *b = *a ^ *b;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 外循环用于控制内循环的右边界 */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; size - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &lt; size - <span class=\"number\">1</span> - i; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[j] &gt; nums[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                swap(&amp;num[j], &amp;num[j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 从序列中选择一个最大(或者最小)的，放到对应位置,</span></span><br><span class=\"line\"><span class=\"comment\"> * 由于从一个序列中选择最大或者最小的方式有多种，</span></span><br><span class=\"line\"><span class=\"comment\"> * 所以有多种选择排序,堆排序也可以看作是选择排序</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>* a, <span class=\"type\">int</span>* b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != b)&#123;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">        *b = *a ^ *b;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 简单选择排序 */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">selectionSort</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; size - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> minIndex = i;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i + <span class=\"number\">1</span>; j &lt; size; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[j] &lt; nums[minIndex])&#123;</span><br><span class=\"line\">                minIndex = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(&amp;nums[minIndex], &amp;nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>* a, <span class=\"type\">int</span>* b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != b)&#123;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">        *b = *a ^ *b;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">insertionSort</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> key = nums[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; key &lt; nums[j]; --j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            nums[j + <span class=\"number\">1</span>] = nums[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nums[j + <span class=\"number\">1</span>] = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>堆排序使用了二叉堆的特性，在二叉堆中，父节点总是比<br>子节点大或者小</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>* a, <span class=\"type\">int</span>* b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != b)&#123;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">        *b = *a ^ *b;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief max堆，下滤</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param nums </span></span><br><span class=\"line\"><span class=\"comment\"> * @param start </span></span><br><span class=\"line\"><span class=\"comment\"> * @param end </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">maxPercDown</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> dad, <span class=\"type\">int</span> end)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> child = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> tmp = nums[dad];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;dad * <span class=\"number\">2</span> + <span class=\"number\">1</span> &lt;= end; dad = child)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        child = dad * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">/* 找到左右子元素中的最大值 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child != end &amp;&amp; nums[child + <span class=\"number\">1</span>] &gt; nums[child])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[child] &gt; tmp)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            nums[dad] = nums[child];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nums[dad] = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">heapSrot</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 从最后一个父元素开始 */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> dad = size/<span class=\"number\">2</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 第一步，将数组转换成max堆 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; dad &gt;= <span class=\"number\">0</span>; --dad)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        maxPercDown(nums, dad, size - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 第二步，排序元素 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; size &gt;= <span class=\"number\">1</span>; --size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        swap(&amp;nums[<span class=\"number\">0</span>], &amp;nums[size - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        maxPercDown(nums, <span class=\"number\">0</span>, size - <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><p>希尔排序，1959 Donard L.Shell提出,也称递减增量排序算法,是优化的插入排序,插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * Hibbard提出1，3，7，15...，这样的2^k - 1序列用于增量排序效果</span></span><br><span class=\"line\"><span class=\"comment\"> * 比N = N / 2的效果好</span></span><br><span class=\"line\"><span class=\"comment\"> * Sedgewick提出1，5，19，41，109...,这样的项或者是9*4^i - 9*2^i + 1</span></span><br><span class=\"line\"><span class=\"comment\"> * 或者是4^i - 3*2^i + 1,比上面的Hibbard提出的效果好</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">shellSort</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> increment = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (increment = size &gt;&gt; <span class=\"number\">1</span>; increment &gt; <span class=\"number\">0</span>; increment &gt;&gt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/** 希尔排序的内部就是简单插入排序 */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = increment; i &lt; size; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> key = nums[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> j;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i - increment; j &gt;= <span class=\"number\">0</span> &amp;&amp; nums[j] &gt; key; j -= increment)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                nums[j + increment] = nums[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nums[j + increment] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p>计数排序，是一种非比较排序，作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数，并且数据最好集中在一定的范围内，如果有个数特别大或者特别小，内存浪费会比较大。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">find_max_min</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> size, <span class=\"type\">int</span>* p_max, <span class=\"type\">int</span>* p_min)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *p_max = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    *p_min = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &gt; *p_max)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            *p_max = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; *p_min)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            *p_min = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">counting_sort</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> max, min;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = find_max_min(arr, size, &amp;max, &amp;min);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;find max or min error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span>* sorted_arr = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(size * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>)+<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sorted_arr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span>* count_arr = (<span class=\"type\">int</span>*)<span class=\"built_in\">calloc</span>(max - min + <span class=\"number\">1</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!count_arr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(sorted_arr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"comment\">/* 这一步类似于哈希,将数的有序性转化为数组下标的有序性 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ++count_arr[arr[i] - min];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/****************下面两个for循环是关键点*****************/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; max - min + <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        count_arr[i] += count_arr[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 计数排序，i从0开始还是size - 1开始无所谓，基数排序必须跟</span></span><br><span class=\"line\"><span class=\"comment\">    上一步中的个数累加顺序有关 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = size - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sorted_arr[--count_arr[arr[i] - min]] = arr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// for (i = 0; i &lt; size; ++i)</span></span><br><span class=\"line\">    <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     sorted_arr[--count_arr[arr[i] - min]] = arr[i];</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">/*******************************************************/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d, &quot;</span>, sorted_arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(arr, sorted_arr, size * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(count_arr);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(sorted_arr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>采用分治法（Divide and Conquer）的一个非常典型的应用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">merge</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span>* tmp_nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> star_r, <span class=\"type\">int</span> right)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, k;</span><br><span class=\"line\">    k = left;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = left, j = star_r; i &lt;= star_r - <span class=\"number\">1</span> &amp;&amp; j &lt;= right;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &lt;= nums[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tmp_nums[k] = nums[i];</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tmp_nums[k] = nums[j];</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            ++k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; j &lt;= right; ++j, ++k)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp_nums[k] = nums[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt;= star_r; ++i, ++k)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp_nums[k] = nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = right - left + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; ++i, ++left)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        nums[left] = tmp_nums[left];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">m_sort</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span>* tmp_nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        m_sort(nums, tmp_nums, left, center);</span><br><span class=\"line\">        m_sort(nums, tmp_nums, center + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        merge(nums, tmp_nums, left, center + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">merge_sort</span><span class=\"params\">(<span class=\"type\">int</span> *nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>* tmp_nums = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(size * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tmp_nums)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_sort(nums, tmp_nums, <span class=\"number\">0</span>, size - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(tmp_nums);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>* a, <span class=\"type\">int</span>* b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != b)&#123;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">        *b = *a ^ *b;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Range</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> start;</span><br><span class=\"line\">    <span class=\"type\">int</span> end;</span><br><span class=\"line\">&#125; Range;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 非递归的方式,在一次循环中，将可能的边界压栈 */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">quick_sort1</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Range range[size];</span><br><span class=\"line\">    <span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">    range[p].start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    range[p].end = size - <span class=\"number\">1</span>;</span><br><span class=\"line\">    ++p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; p;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Range r = range[--p];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.start &gt;= r.end)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 去中间位置的数为枢纽数 */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> pivot = nums[(r.start + r.end) / <span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> i = r.start;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = r.end;</span><br><span class=\"line\">        <span class=\"comment\">/* 注意这里是小于等于 */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; i &lt;= j;)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; nums[i] &lt; pivot;)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; nums[j] &gt; pivot;)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                --j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/* 注意这里是小于等于 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt;= j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                swap(&amp;nums[i], &amp;nums[j]);</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">                --j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.start &lt; j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            range[p].start = r.start;</span><br><span class=\"line\">            range[p].end = j;</span><br><span class=\"line\">            ++p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; r.end)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            range[p].start = i;</span><br><span class=\"line\">            range[p].end = r.end;</span><br><span class=\"line\">            ++p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">q_sort</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pivot = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = left;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = right;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;i &lt;= j;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;nums[i] &lt; nums[pivot];)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; nums[j] &gt; nums[pivot];)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            --j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            swap(&amp;nums[i], &amp;nums[j]);</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            --j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        q_sort(nums, left, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right &gt; i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        q_sort(nums, i, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 递归方式 */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">quick_sort</span><span class=\"params\">(<span class=\"type\">int</span> *nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    q_sort(nums, <span class=\"number\">0</span>, size - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h2><p>桶排序，是计数排序的升级版</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUCKET_SIZE (5) <span class=\"comment\">/**&lt; 假定均匀分布的情况下平均每个桶放几个元素*/</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> elem;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>* <span class=\"title\">list_next</span>;</span></span><br><span class=\"line\">&#125; Node;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BucketManager</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nums;</span><br><span class=\"line\">    Node** buckets;  </span><br><span class=\"line\">&#125; BucketManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BucketSpaceManager</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> index;</span><br><span class=\"line\">    Node* nodes_space;</span><br><span class=\"line\">&#125; BucketSpaceManager;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">BucketSpaceManager* <span class=\"title function_\">init_bucket_space</span><span class=\"params\">(<span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BucketSpaceManager* space_mgr = (BucketSpaceManager*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BucketSpaceManager));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!space_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> exit_1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    space_mgr-&gt;index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    space_mgr-&gt;nodes_space = (Node*)<span class=\"built_in\">malloc</span>(size * <span class=\"keyword\">sizeof</span>(Node));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!space_mgr-&gt;nodes_space)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> exit_2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> space_mgr;</span><br><span class=\"line\"></span><br><span class=\"line\">exit_2:</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(space_mgr);</span><br><span class=\"line\">exit_1:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">BucketManager* <span class=\"title function_\">init_buckets</span><span class=\"params\">(<span class=\"type\">int</span> bucket_nums)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BucketManager* bucket_mgr = (BucketManager*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BucketManager));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bucket_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> exit_1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bucket_mgr-&gt;nums = bucket_nums;</span><br><span class=\"line\">    bucket_mgr-&gt;buckets = (Node**)<span class=\"built_in\">calloc</span>(bucket_mgr-&gt;nums, <span class=\"keyword\">sizeof</span>(Node*));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bucket_mgr-&gt;buckets)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> exit_2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bucket_mgr;</span><br><span class=\"line\">exit_2:</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(bucket_mgr);</span><br><span class=\"line\">exit_1:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Node* <span class=\"title function_\">get_bucket_space</span><span class=\"params\">(BucketSpaceManager* space_mgr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (space_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;space_mgr-&gt;nodes_space[space_mgr-&gt;index++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">release_bucket_space</span><span class=\"params\">(BucketSpaceManager* space_mgr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (space_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (space_mgr-&gt;nodes_space)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(space_mgr-&gt;nodes_space);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(space_mgr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">release_buckets</span><span class=\"params\">(BucketManager* buckets_mgr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buckets_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buckets_mgr-&gt;buckets)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(buckets_mgr-&gt;buckets);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(buckets_mgr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">find_max_min</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> size, <span class=\"type\">int</span>* p_max, <span class=\"type\">int</span>* p_min)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *p_max = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    *p_min = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &gt; *p_max)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            *p_max = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; *p_min)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            *p_min = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">insert_bucket</span><span class=\"params\">(BucketManager* bucket_mgr, <span class=\"type\">int</span> index, Node* new_node)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node* cur, *pre;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bucket_mgr-&gt;buckets[index])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bucket_mgr-&gt;buckets[index] = new_node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/** 桶内使用插入排序 */</span></span><br><span class=\"line\">        cur = bucket_mgr-&gt;buckets[index];</span><br><span class=\"line\">        pre = cur;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur-&gt;list_next &amp;&amp; new_node-&gt;elem &gt; cur-&gt;elem)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = cur-&gt;list_next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (new_node-&gt;elem &lt;= cur-&gt;elem)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre == cur)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                new_node-&gt;list_next = cur;</span><br><span class=\"line\">                bucket_mgr-&gt;buckets[index] = new_node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                new_node-&gt;list_next = cur;</span><br><span class=\"line\">                pre-&gt;list_next = new_node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cur-&gt;list_next = new_node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">bucket_sort</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> max, min;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = find_max_min(arr, size, &amp;max, &amp;min);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    BucketSpaceManager* space_mgr = init_bucket_space(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!space_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> exit_1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> bucket_nums = (max - min) / BUCKET_SIZE + <span class=\"number\">1</span>;</span><br><span class=\"line\">    BucketManager* bucket_mgr = init_buckets(bucket_nums);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bucket_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> exit_2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> index = (arr[i] - min) / BUCKET_SIZE;</span><br><span class=\"line\">        Node* new_node = get_bucket_space(space_mgr);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!new_node)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> exit_3;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        new_node-&gt;elem = arr[i];</span><br><span class=\"line\">        new_node-&gt;list_next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        insert_bucket(bucket_mgr, index, new_node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; bucket_mgr-&gt;nums; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Node* node = bucket_mgr-&gt;buckets[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(node)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, node-&gt;elem);</span><br><span class=\"line\">            node = node-&gt;list_next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">exit_3:</span><br><span class=\"line\">    release_buckets(bucket_mgr);</span><br><span class=\"line\">exit_2:</span><br><span class=\"line\">    release_bucket_space(space_mgr);</span><br><span class=\"line\">exit_1:</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h2><p>基数排序是一种非比较型整数排序算法，<br>其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。<br>由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 待排序数的进制 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BASE (10)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">find_max</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> max = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (max &lt; arr[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            max = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">radix_sort</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>* backup = arr;</span><br><span class=\"line\">    <span class=\"type\">int</span>* snd_arr = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(size * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> bucket[BASE] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">int</span> max = find_max(arr, size);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">exp</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (max / <span class=\"built_in\">exp</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++bucket[(arr[i] / <span class=\"built_in\">exp</span>) % BASE];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; size; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            bucket[i] += bucket[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 计数排序，i从0开始还是size - 1开始无所谓，基数排序必须跟</span></span><br><span class=\"line\"><span class=\"comment\">        上一步中的个数累加顺序有关 */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = size - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            snd_arr[--bucket[(arr[i] / <span class=\"built_in\">exp</span>) % BASE]] = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 交换两个指针，这样就不用复制了，来回倒腾 */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> * tmp;</span><br><span class=\"line\">        tmp = arr;</span><br><span class=\"line\">        arr = snd_arr;</span><br><span class=\"line\">        snd_arr = tmp;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(bucket, <span class=\"number\">0</span> , BASE * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">        <span class=\"built_in\">exp</span> *= BASE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (backup != arr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(arr, snd_arr, size * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(snd_arr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构与算法"]},{"title":"实现伸展树","url":"/2022/04/29/splay-tree/","content":"<blockquote>\n<p>伸展树（英语：Splay Tree）是一种能够自我平衡的二叉查找树，它能在均摊O(log n)的时间内完成基于伸展（Splay）操作的插入、查找、修改和删除操作。它是由丹尼尔·斯立特（Daniel Sleator）和罗伯特·塔扬在1985年发明的。 </p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行调整，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。<br>它的优势在于不需要记录用于平衡树的冗余信息。<br>-—  Wikipedia</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @file splay_tree_traverse_BFS_DFS.c</span></span><br><span class=\"line\"><span class=\"comment\"> * @author your name (you@domain.com)</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 实现伸展树,实现队列和栈用于广度优先遍历和深度优先遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * @version 0.1</span></span><br><span class=\"line\"><span class=\"comment\"> * @date 2022-04-21</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @copyright Copyright (c) 2022</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">/**&lt; 相同元素计数 */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span>* <span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span>* <span class=\"title\">right</span>;</span></span><br><span class=\"line\">&#125; BinTreeNode;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*********************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用链表实现stack用于深度优先搜索</span></span><br><span class=\"line\"><span class=\"comment\"> ********************************************************/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    BinTreeNode* bin_tree_node;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; ListNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">Stack</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">is_empty</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">push_stack</span><span class=\"params\">(Stack* <span class=\"built_in\">stack</span>, BinTreeNode* tree_node)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode* node = (ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ListNode));</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;bin_tree_node = tree_node;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*<span class=\"built_in\">stack</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *<span class=\"built_in\">stack</span> = node;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    node-&gt;next = *<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    *<span class=\"built_in\">stack</span> = node;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BinTreeNode* <span class=\"title function_\">pop_stack</span><span class=\"params\">(Stack* <span class=\"built_in\">stack</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*<span class=\"built_in\">stack</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* backup = *<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">        BinTreeNode* ret = (*<span class=\"built_in\">stack</span>)-&gt;bin_tree_node;</span><br><span class=\"line\">        *<span class=\"built_in\">stack</span> = (*<span class=\"built_in\">stack</span>)-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(backup);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">make_stack_empty</span><span class=\"params\">(Stack* <span class=\"built_in\">stack</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">stack</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* backup;</span><br><span class=\"line\">        backup = *<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">        *<span class=\"built_in\">stack</span> = (*<span class=\"built_in\">stack</span>)-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(backup);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BinTreeNode* <span class=\"title function_\">get_top_elem</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>-&gt;bin_tree_node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/****************************</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现队列用于广度优先算法</span></span><br><span class=\"line\"><span class=\"comment\"> ***************************/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Queue</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    ListNode* front;</span><br><span class=\"line\">    ListNode* rear;</span><br><span class=\"line\">&#125; Queue;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">enqueue</span><span class=\"params\">(Queue* <span class=\"built_in\">queue</span>, BinTreeNode* tree_node)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error queue is NULL\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode* node = (ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ListNode));</span><br><span class=\"line\">    node-&gt;bin_tree_node = tree_node;</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>-&gt;rear)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;rear = node;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;front = <span class=\"built_in\">queue</span>-&gt;rear;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;rear-&gt;next = node;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;rear = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BinTreeNode* <span class=\"title function_\">dequeue</span><span class=\"params\">(Queue* <span class=\"built_in\">queue</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error: queue does not exist\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>-&gt;front)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error: queue is empty\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* list_node = <span class=\"built_in\">queue</span>-&gt;front;</span><br><span class=\"line\">        BinTreeNode* tree_node = list_node-&gt;bin_tree_node;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;front == <span class=\"built_in\">queue</span>-&gt;rear)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">queue</span>-&gt;front = <span class=\"built_in\">queue</span>-&gt;rear = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">queue</span>-&gt;front = <span class=\"built_in\">queue</span>-&gt;front-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(list_node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree_node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*******************************************</span></span><br><span class=\"line\"><span class=\"comment\"> *  实现伸展树 </span></span><br><span class=\"line\"><span class=\"comment\"> *******************************************/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span>* <span class=\"title\">SplayTree</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span>* <span class=\"title\">Position</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 插入操作就跟二叉搜索树插入一样，不做平衡操作</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param splay_tree </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return SplayTree </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">(SplayTree* root, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BinTreeNode* node = (BinTreeNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BinTreeNode));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    node-&gt;val = x;</span><br><span class=\"line\">    node-&gt;count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    node-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *root = node;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SplayTree pos = *root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; pos-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos = pos-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos-&gt;left = node;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; pos-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos = pos-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos-&gt;right = node;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos-&gt;val == x)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ++pos-&gt;count;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 二叉查找树的查找操作</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return Position </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Position <span class=\"title function_\">find_search_tree</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:not found\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; root-&gt;val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_search_tree(root-&gt;left, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; root-&gt;val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_search_tree(root-&gt;right, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">find_max</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_max(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">find_min</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_min(root-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 删除元素，删除操作跟二叉查找树的删除一致</span></span><br><span class=\"line\"><span class=\"comment\"> * 为了保持删除元素后的树依然是查找树，需要将删除节点的左子树的最大值</span></span><br><span class=\"line\"><span class=\"comment\"> * 或者右子树中的最小值移动到删除的地方，移动有两种方案：</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. 仅移动链表节点中的值</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. 移动链表的节点</span></span><br><span class=\"line\"><span class=\"comment\"> * 这里使用第1种方案, 第2种有点麻烦</span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return Position </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Position <span class=\"title function_\">delete</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:not found\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; root-&gt;val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = delete(root-&gt;left, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; root-&gt;val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = delete(root-&gt;right, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;count &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                --root-&gt;count;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Position tmp = find_min(root-&gt;right);</span><br><span class=\"line\">                root-&gt;val = tmp-&gt;val;</span><br><span class=\"line\">                root-&gt;count = tmp-&gt;count;</span><br><span class=\"line\">                root-&gt;right = delete(root-&gt;right, tmp-&gt;val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Position tmp = root;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!root-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 清空树，释放内存</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @return Position </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Position <span class=\"title function_\">delete_all</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            root-&gt;left = delete_all(root-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            root-&gt;right =  delete_all(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(root);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">splay_left_left</span><span class=\"params\">(Position g, Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    g-&gt;left = p-&gt;right;</span><br><span class=\"line\">    p-&gt;left = cur-&gt;right;</span><br><span class=\"line\">    p-&gt;right = g;</span><br><span class=\"line\">    cur-&gt;right = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">splay_left_right</span><span class=\"params\">(Position g, Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* cur跟p互换 */</span></span><br><span class=\"line\">    p-&gt;right = cur-&gt;left;</span><br><span class=\"line\">    cur-&gt;left = p;</span><br><span class=\"line\">    g-&gt;left = cur;</span><br><span class=\"line\">    <span class=\"comment\">/* cur跟g互换 */</span></span><br><span class=\"line\">    g-&gt;left = cur-&gt;right;</span><br><span class=\"line\">    cur-&gt;right = g;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">splay_right_left</span><span class=\"params\">(Position g, Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* cur跟p互换 */</span></span><br><span class=\"line\">    p-&gt;left = cur-&gt;right;</span><br><span class=\"line\">    cur-&gt;right = p;</span><br><span class=\"line\">    g-&gt;right = cur;</span><br><span class=\"line\">    <span class=\"comment\">/* cur跟g互换 */</span></span><br><span class=\"line\">    g-&gt;left = cur-&gt;left;</span><br><span class=\"line\">    cur-&gt;left = g;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">splay_right_right</span><span class=\"params\">(Position g, Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    g-&gt;right = p-&gt;left;</span><br><span class=\"line\">    p-&gt;right = cur-&gt;left;</span><br><span class=\"line\">    p-&gt;left = g;</span><br><span class=\"line\">    cur-&gt;left = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">rotate_left</span><span class=\"params\">(Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    p-&gt;left = cur-&gt;right;</span><br><span class=\"line\">    cur-&gt;right = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">rotate_right</span><span class=\"params\">(Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    p-&gt;right = cur-&gt;left;</span><br><span class=\"line\">    cur-&gt;left = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 伸展树的查找操作要求将找到的元素伸展到根节点</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param cur_pos </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return Position </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Position <span class=\"title function_\">find</span><span class=\"params\">(SplayTree cur_pos, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cur_pos)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack <span class=\"built_in\">stack</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; cur_pos-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur_pos-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                push_stack(&amp;<span class=\"built_in\">stack</span>, cur_pos);</span><br><span class=\"line\">                cur_pos = cur_pos-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:not found\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; cur_pos-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur_pos-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                push_stack(&amp;<span class=\"built_in\">stack</span>, cur_pos);</span><br><span class=\"line\">                cur_pos = cur_pos-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:not found\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;find it\\n&quot;</span>);</span><br><span class=\"line\">            Position p, q, r;</span><br><span class=\"line\">            p = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">            q = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">            r = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">            <span class=\"comment\">/* 找到元素后通过伸展将元素放到根节点*/</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* 栈里没有元素，那么cur_pos就是根节点 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!p &amp;&amp; !q &amp;&amp; !r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/* 说明当前cur_pos变量保存的节点的父节点是根节点,旋转一次就行 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p &amp;&amp; !q &amp;&amp; !r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (p-&gt;left == cur_pos)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        cur_pos = rotate_right(p, cur_pos);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        cur_pos = rotate_left(p, cur_pos);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/* zig-zig模式 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (q-&gt;left == p &amp;&amp; p-&gt;left == cur_pos)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cur_pos = splay_left_left(q, p ,cur_pos);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q-&gt;right == p &amp;&amp; p-&gt;right == cur_pos)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cur_pos = splay_right_right(q, p ,cur_pos);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/* zig-zag模式 */</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q-&gt;left == p &amp;&amp; p-&gt;right == cur_pos)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cur_pos = splay_left_right(q, p ,cur_pos);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q-&gt;right == p &amp;&amp; p-&gt;left == cur_pos)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cur_pos = splay_right_left(q, p, cur_pos);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r-&gt;left == q)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    r-&gt;left = cur_pos;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    r-&gt;right = cur_pos;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                p = r;</span><br><span class=\"line\">                q = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">                r = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cur_pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 随机生成一棵二叉查找树</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param size </span></span><br><span class=\"line\"><span class=\"comment\"> * @return SplayTree </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SplayTree <span class=\"title function_\">make_random_bin_tree</span><span class=\"params\">(<span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span></span><br><span class=\"line\">    gettimeofday(&amp;tv, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    srand((<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)(tv.tv_usec));</span><br><span class=\"line\">    SplayTree tree = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[random:]&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (size--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x = rand() % <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, x);</span><br><span class=\"line\">        insert(&amp;tree, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 深度优先遍历(后序遍历)</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">traverse_DFS</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Stack <span class=\"built_in\">stack</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = push_stack(&amp;<span class=\"built_in\">stack</span>, root);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;push_stack error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!is_empty(<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        BinTreeNode* ret = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:ret is NULL\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, ret-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            push_stack(&amp;<span class=\"built_in\">stack</span>, ret-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret-&gt;left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            push_stack(&amp;<span class=\"built_in\">stack</span>, ret-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">is_empty_queue</span><span class=\"params\">(Queue* <span class=\"built_in\">queue</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>-&gt;front == <span class=\"built_in\">queue</span>-&gt;rear &amp;&amp; <span class=\"built_in\">queue</span>-&gt;front == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 广度优先遍历(层序遍历)</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">traverse_BFS</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Queue <span class=\"built_in\">queue</span> = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    enqueue(&amp;<span class=\"built_in\">queue</span>, root);</span><br><span class=\"line\">    <span class=\"type\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!is_empty_queue(&amp;<span class=\"built_in\">queue</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        BinTreeNode* node = dequeue(&amp;<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            enqueue(&amp;<span class=\"built_in\">queue</span>, node-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            enqueue(&amp;<span class=\"built_in\">queue</span>, node-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 前序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param level </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">pre_order_traverse</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d &quot;</span>, level, root-&gt;val);</span><br><span class=\"line\">        pre_order_traverse(root-&gt;left, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        pre_order_traverse(root-&gt;right, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 中序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param level </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">in_order_traverse</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        in_order_traverse(root-&gt;left, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d &quot;</span>, level, root-&gt;val);</span><br><span class=\"line\">        in_order_traverse(root-&gt;right, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 后序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param level </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">post_order_traverse</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        post_order_traverse(root-&gt;left, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        post_order_traverse(root-&gt;right, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d-%p &quot;</span>, level, root-&gt;val, root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//SplayTree root = make_random_bin_tree(10);</span></span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">2</span>,<span class=\"number\">84</span>,<span class=\"number\">69</span>,<span class=\"number\">98</span>,<span class=\"number\">73</span>,<span class=\"number\">62</span>,<span class=\"number\">20</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    SplayTree root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insert(&amp;root, arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root = find(root, <span class=\"number\">73</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;--%p--\\n&quot;</span>, find_search_tree(root, <span class=\"number\">62</span>));</span><br><span class=\"line\">    delete(root, <span class=\"number\">50</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;---------------------\\n&quot;</span>);</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    in_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    post_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    traverse_DFS(root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    traverse_BFS(root);</span><br><span class=\"line\">    delete_all(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构与算法"],"tags":["伸展树","二叉查找树","栈","队列"]},{"title":"vscode ssh 远程登录天坑,使用密钥后仍需要输入密码","url":"/2022/01/12/vscode-ssh/","content":"<p><strong>问题</strong>：使用ssh-keygen生成了密钥对后，把公钥直接重命名成<code>authorized_keys</code>拷贝到服务器<code>~/.ssh</code>目录，发现vscode ssh登录还是提示需要输入密码，还以为密钥对搞错了，反复重试都一样，这就费解了。</p>\n<span id=\"more\"></span>\n<hr>\n<p><strong>解决</strong>  </p>\n<blockquote>\n<p>Make sure the permissions on the <code>~/.ssh</code> directory and its contents are proper. When I first set up my ssh key auth, I didn’t have the <code>~/.ssh</code> folder properly set up, and it yelled at me.</p>\n<ul>\n<li>Your home directory <code>~</code>, your <code>~/.ssh</code> directory and the <code>~/.ssh/authorized_keys</code> file on the remote machine must be writable only by you: <code>rwx------</code> and <code>rwxr-xr-x</code> are fine, but <code>rwxrwx---</code> is no good¹, even if you are the only user in your group (if you prefer numeric modes: <code>700</code> or <code>755</code>, not <code>775</code>).<br>If <code>~/.ssh</code> or <code>authorized_keys</code> is a symbolic link, <a href=\"https://unix.stackexchange.com/questions/152417/why-cant-i-use-public-private-key-authentication-with-ssh-on-arch-linux\">the canonical path (with symbolic links expanded) is checked.</a></li>\n<li>Your <code>~/.ssh/authorized_keys</code> file (on the remote machine) must be readable (at least <code>400</code>), but you’ll need it to be also writable (<code>600</code>) if you will add any more keys to it.</li>\n<li>Your private key file (on the local machine) must be readable and writable only by you: <code>rw-------</code>, i.e. <code>600</code>.  </li>\n<li>Also, if SELinux is set to enforcing, you may need to run <code>restorecon -R -v ~/.ssh</code> (see e.g. <a href=\"https://bugs.launchpad.net/ubuntu/+source/openssh/+bug/965663\">Ubuntu bug 965663</a> and <a href=\"https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=658675\">Debian bug report #658675</a>; this is <a href=\"https://wiki.centos.org/Manuals/ReleaseNotes/CentOS6.2#head-652041430eedc0752937ec8252c52132e574fd2a\">patched in CentOS 6).</a></li>\n</ul>\n<p>¹ Except on some distributions (Debian and derivatives) which have patched the code to allow group writability if you are the only user in your group.  </p>\n</blockquote>\n<p><strong>原文链接</strong>:<a href=\"https://unix.stackexchange.com/questions/36540/why-am-i-still-getting-a-password-prompt-with-ssh-with-public-key-authentication\">https://unix.stackexchange.com/questions/36540/why-am-i-still-getting-a-password-prompt-with-ssh-with-public-key-authentication</a>  </p>\n<p><strong>意思就是</strong>，一般情况下要求 <code>authorized_keys</code> 文件最好设置为只有所有者有读权限或者读写权限(400或者600)，其他情况可能导致不能访问。某些打了补丁的系统也允许当属组成员只有你一个时，<code>authorized_keys</code>设置属组写权限，也允许ssh登录。  </p>\n<p>果然我服务器<code>authorized_keys</code>权限是<code>-rwxr--r--</code>(<code>744</code>).我是通过samba把服务器目录共享到Windows的，拷贝过去默认变成了<code>-rwxr--r--</code>  </p>\n<p>所以一句  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 600 authorized_keys</span><br></pre></td></tr></table></figure>\n<p>解决</p>\n","categories":["开发日常"],"tags":["linux","vscode"]}]