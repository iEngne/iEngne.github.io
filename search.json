[{"title":"github fork 项目同步上游","url":"/2022/01/13/fork-merge/","content":"<p>虽然github已经在网页上增加了<strong>fetch upstream</strong>功能，但如果有冲突，只能手动merge.<br>以下记录一次手动合并的过程：</p>\n<span id=\"more\"></span>\n<hr>\n<ul>\n<li>clone 自己fork的仓库<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-16:47:17-&gt;&gt;~/workspace<span class=\"comment\"># git clone git@github.com:iEngne/now-subconverter.git</span></span><br><span class=\"line\">Cloning into <span class=\"string\">&#x27;now-subconverter&#x27;</span>...</span><br><span class=\"line\">remote: Enumerating objects: 1514, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Counting objects: 100% (121/121), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Compressing objects: 100% (110/110), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Total 1514 (delta 24), reused 57 (delta 5), pack-reused 1393</span><br><span class=\"line\">Receiving objects: 100% (1514/1514), 46.51 MiB | 991.00 KiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Resolving deltas: 100% (636/636), <span class=\"keyword\">done</span>.</span><br></pre></td></tr></table></figure></li>\n<li>确认当前分支是否是要合并的分支，<code>git brakch -a</code>，如果不是切换到相应的分支。<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:11:23-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git branch  -a</span></span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/HEAD -&gt; origin/master</span><br></pre></td></tr></table></figure></li>\n<li>设置<strong>upstream</strong>.<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-16:48:43-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git remote add upstream https://github.com/zhongfly/now-subconverter.git</span></span><br><span class=\"line\">♥root-16:51:15-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git remote -v</span></span><br><span class=\"line\">origin  git@github.com:iEngne/now-subconverter.git (fetch)</span><br><span class=\"line\">origin  git@github.com:iEngne/now-subconverter.git (push)</span><br><span class=\"line\">upstream        https://github.com/zhongfly/now-subconverter.git (fetch)</span><br><span class=\"line\">upstream        https://github.com/zhongfly/now-subconverter.git (push)</span><br></pre></td></tr></table></figure></li>\n<li>从远程取出<strong>upstream</strong><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-16:51:20-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git fetch upstream</span></span><br><span class=\"line\">remote: Enumerating objects: 32, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Counting objects: 100% (32/32), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Compressing objects: 100% (20/20), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Total 26 (delta 15), reused 17 (delta 6), pack-reused 0</span><br><span class=\"line\">Unpacking objects: 100% (26/26), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">From https://github.com/zhongfly/now-subconverter</span><br><span class=\"line\"> * [new branch]      master     -&gt; upstream/master</span><br></pre></td></tr></table></figure></li>\n<li>查看下分支情况，<code>git branch -a</code><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:29:13-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git branch  -a</span></span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/HEAD -&gt; origin/master</span><br><span class=\"line\">  remotes/origin/master</span><br><span class=\"line\">  remotes/upstream/master</span><br></pre></td></tr></table></figure></li>\n<li>执行合并<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:31:27-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git merge upstream/master</span></span><br><span class=\"line\">warning: Cannot merge binary files: subconverter/subconverter.exe (HEAD vs. upstream/master)</span><br><span class=\"line\">Auto-merging subconverter/subconverter.exe</span><br><span class=\"line\">CONFLICT (content): Merge conflict <span class=\"keyword\">in</span> subconverter/subconverter.exe</span><br><span class=\"line\">Auto-merging subconverter/snippets/emoji.toml</span><br><span class=\"line\">CONFLICT (add/add): Merge conflict <span class=\"keyword\">in</span> subconverter/snippets/emoji.toml</span><br><span class=\"line\">Auto-merging subconverter/pref.example.toml</span><br><span class=\"line\">CONFLICT (add/add): Merge conflict <span class=\"keyword\">in</span> subconverter/pref.example.toml</span><br><span class=\"line\">Automatic merge failed; fix conflicts and <span class=\"keyword\">then</span> commit the result.</span><br></pre></td></tr></table></figure></li>\n<li>查看冲突<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:31:44-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git status</span></span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># You have unmerged paths.</span></span><br><span class=\"line\"><span class=\"comment\">#   (fix conflicts and run &quot;git commit&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Unmerged paths:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#       both added:         subconverter/pref.example.toml</span></span><br><span class=\"line\"><span class=\"comment\">#       both added:         subconverter/snippets/emoji.toml</span></span><br><span class=\"line\"><span class=\"comment\">#       both modified:      subconverter/subconverter.exe</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">no changes added to commit (use <span class=\"string\">&quot;git add&quot;</span> and/or <span class=\"string\">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n<li>直接从GUI界面打开文件修改冲突，或者使用<code>git mergetool</code>命令从命令行打开merge工具，如果有装VIM默认调用vimdiff.  </li>\n<li>修改后<strong>commit</strong>和<strong>push</strong>就OK.</li>\n</ul>\n","categories":["开发日常"],"tags":["github"]},{"title":"vscode ssh 远程登录天坑,使用密钥后仍需要输入密码","url":"/2022/01/12/vscode-ssh/","content":"<p><strong>问题</strong>：使用ssh-keygen生成了密钥对后，把公钥直接重命名成<code>authorized_keys</code>拷贝到服务器<code>~/.ssh</code>目录，发现vscode ssh登录还是提示需要输入密码，还以为密钥对搞错了，反复重试都一样，这就费解了。</p>\n<span id=\"more\"></span>\n<hr>\n<p><strong>解决</strong>  </p>\n<blockquote>\n<p>Make sure the permissions on the <code>~/.ssh</code> directory and its contents are proper. When I first set up my ssh key auth, I didn’t have the <code>~/.ssh</code> folder properly set up, and it yelled at me.</p>\n<ul>\n<li>Your home directory <code>~</code>, your <code>~/.ssh</code> directory and the <code>~/.ssh/authorized_keys</code> file on the remote machine must be writable only by you: <code>rwx------</code> and <code>rwxr-xr-x</code> are fine, but <code>rwxrwx---</code> is no good¹, even if you are the only user in your group (if you prefer numeric modes: <code>700</code> or <code>755</code>, not <code>775</code>).<br>If <code>~/.ssh</code> or <code>authorized_keys</code> is a symbolic link, <a href=\"https://unix.stackexchange.com/questions/152417/why-cant-i-use-public-private-key-authentication-with-ssh-on-arch-linux\">the canonical path (with symbolic links expanded) is checked.</a></li>\n<li>Your <code>~/.ssh/authorized_keys</code> file (on the remote machine) must be readable (at least <code>400</code>), but you’ll need it to be also writable (<code>600</code>) if you will add any more keys to it.</li>\n<li>Your private key file (on the local machine) must be readable and writable only by you: <code>rw-------</code>, i.e. <code>600</code>.  </li>\n<li>Also, if SELinux is set to enforcing, you may need to run <code>restorecon -R -v ~/.ssh</code> (see e.g. <a href=\"https://bugs.launchpad.net/ubuntu/+source/openssh/+bug/965663\">Ubuntu bug 965663</a> and <a href=\"https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=658675\">Debian bug report #658675</a>; this is <a href=\"https://wiki.centos.org/Manuals/ReleaseNotes/CentOS6.2#head-652041430eedc0752937ec8252c52132e574fd2a\">patched in CentOS 6).</a></li>\n</ul>\n<p>¹ Except on some distributions (Debian and derivatives) which have patched the code to allow group writability if you are the only user in your group.  </p>\n</blockquote>\n<p><strong>原文链接</strong>:<a href=\"https://unix.stackexchange.com/questions/36540/why-am-i-still-getting-a-password-prompt-with-ssh-with-public-key-authentication\">https://unix.stackexchange.com/questions/36540/why-am-i-still-getting-a-password-prompt-with-ssh-with-public-key-authentication</a>  </p>\n<p><strong>意思就是</strong>，一般情况下要求 <code>authorized_keys</code> 文件最好设置为只有所有者有读权限或者读写权限(400或者600)，其他情况可能导致不能访问。某些打了补丁的系统也允许当属组成员只有你一个时，<code>authorized_keys</code>设置属组写权限，也允许ssh登录。  </p>\n<p>果然我服务器<code>authorized_keys</code>权限是<code>-rwxr--r--</code>(<code>744</code>).我是通过samba把服务器目录共享到Windows的，拷贝过去默认变成了<code>-rwxr--r--</code>  </p>\n<p>所以一句  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 600 authorized_keys</span><br></pre></td></tr></table></figure>\n<p>解决</p>\n","categories":["开发日常"],"tags":["linux","vscode"]},{"title":"C语言中复杂类型的声明","url":"/2022/04/28/c-complex-declaration/","content":"<p>犹记得当第一次看见c的signal函数的原型的时候，懵逼了，这是个啥啊</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"title function_\">void</span> <span class=\"params\">(*<span class=\"type\">sighandler_t</span>)</span><span class=\"params\">(<span class=\"type\">int</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">sighandler_t</span> <span class=\"title function_\">signal</span><span class=\"params\">(<span class=\"type\">int</span> signum, <span class=\"type\">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>现在知道了，借助typedef声明了一个函数指针类型取名叫sighandler_t，这个函数指针<br>返回值是void，入参是int。然后声明了signal函数，signal函数的返回值是sighandler_t<br>这个类型的函数指针。<br>typedef可以帮我们简化复杂类型的声明，在不借助typedef的情况下，c语言应该怎么声明复杂的类型呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 复习关于C语言复杂类型的声明定义</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * c语言语法中，[]、()的优先级最高，[]、()写在标识符的右侧，*号和基本类型，如int,char,struct等</span></span><br><span class=\"line\"><span class=\"comment\">     * 写在标识符左侧,对声明定义的解析是右左原则。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指针p指向一个有20个char类型元素的数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">char</span> (*p)[<span class=\"number\">20</span>];</span><br><span class=\"line\">    p=(<span class=\"type\">char</span>(*)[<span class=\"number\">20</span>])<span class=\"built_in\">malloc</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> (*p_a)[<span class=\"number\">20</span>] = &amp;a;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 二级指针就多加个*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (**pp_a)[<span class=\"number\">20</span>] = &amp;p_a;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"title function_\">int</span><span class=\"params\">(*p_array)</span>[];</span><br><span class=\"line\">    p_array * p_c = &amp;p_a;<span class=\"comment\">// 跟int (**pp_a)[20] = &amp;p_a;等效</span></span><br><span class=\"line\">    p_array** p_d = &amp;p_c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> *b[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> *(*p_b)[<span class=\"number\">20</span>] = &amp;b;</span><br><span class=\"line\">    <span class=\"type\">int</span> *(**p_e)[<span class=\"number\">20</span>] = &amp;p_b;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*************************************/</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个数组，数组有20个元素，每个元素是指向int类型的二级指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>** f[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个指针，该指针指向一个数组，该数组有20个元素，每个元素是指向int类型的二级指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>** (*p_f)[<span class=\"number\">20</span>] = &amp;f;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个20个元素的数组g，该数组的每个元素是一个指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该指针指向一个有10个元素的数组,该数组的元素是指向char*</span></span><br><span class=\"line\"><span class=\"comment\">     * 类型的指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">char</span> *(*g[<span class=\"number\">20</span>])[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个20个元素的数组，数组的每一个元素是一个指针，该指针是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该函数指针指向的函数，入参为int,返回值是int</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*h[<span class=\"number\">20</span>])(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个函数指针func，指向的函数没有入参，返回值是一个指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该指针指向一个二维数组，该二维数组的每一元素是一个int* 指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *(*(*func)(<span class=\"type\">void</span>))[][<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个函数指针func_a，指向的函数入参是int,返回值是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该函数指针指向的函数入参是int,返回值是int*</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.首先是个指针,所以在左侧加*号，得到*func_a</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.变成函数指针，入参是int，得到(*func_a)(int)</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.返回值是函数指针，那么把2的结果作为一个整体看待，看作是标识符,</span></span><br><span class=\"line\"><span class=\"comment\">     *   再在左侧加*号，后边加(int),得到(*(*func_)(int))(int)</span></span><br><span class=\"line\"><span class=\"comment\">     * 4.返回值的函数指针指向的函数返回值是int*，所以再在左边加上int*，</span></span><br><span class=\"line\"><span class=\"comment\">     * 最后得到 int *(*(*func_a)(int))(int)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *(*(*func_a)(<span class=\"type\">int</span>))(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个数组指针pg，该指针指向一个20个元素的数组，该数组的元素是</span></span><br><span class=\"line\"><span class=\"comment\">     * 函数指针，该函数指针指向的函数，入参是int,返回值是int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">     <span class=\"type\">int</span> (*(*pg)[<span class=\"number\">20</span>])(<span class=\"type\">int</span>);</span><br><span class=\"line\">     pg = &amp;h;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个函数指针func_b，指向的函数入参是int，返回值是一个指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该指针指向一个20个元素的数组，该数组的元素是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该函数指针指向的函数，入参是int,返回值是int.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">     <span class=\"type\">int</span> (*(*(*func_b)(<span class=\"type\">int</span> b))[<span class=\"number\">20</span>])(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 定义一个数组指针ph,指向一个有20个元素的数组，该数组的元素是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">      * 该指针指向一个函数，该函数的入参是int,返回值是指针，该指针指向一个10</span></span><br><span class=\"line\"><span class=\"comment\">      * 个元素的数组，该元素char *</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"type\">char</span>* (*(*(*ph)[<span class=\"number\">20</span>])(<span class=\"type\">int</span>))[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 定义一个函数指针func_d，入参是int,返回值是函数指针，该函数指针指向的函数</span></span><br><span class=\"line\"><span class=\"comment\">      * 入参是short, 返回值是一个指向包含15个char*类型的数组的指针</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">      <span class=\"type\">char</span> *(*(*(*func_d)(<span class=\"type\">int</span>))(<span class=\"type\">short</span>))[<span class=\"number\">15</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["开发日常"],"tags":["C语言"]},{"title":"实现伸展树","url":"/2022/04/29/splay-tree/","content":"<blockquote>\n<p>伸展树（英语：Splay Tree）是一种能够自我平衡的二叉查找树，它能在均摊O(log n)的时间内完成基于伸展（Splay）操作的插入、查找、修改和删除操作。它是由丹尼尔·斯立特（Daniel Sleator）和罗伯特·塔扬在1985年发明的。 </p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行调整，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。<br>它的优势在于不需要记录用于平衡树的冗余信息。<br>-—  Wikipedia</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @file splay_tree_traverse_BFS_DFS.c</span></span><br><span class=\"line\"><span class=\"comment\"> * @author your name (you@domain.com)</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 实现伸展树,实现队列和栈用于广度优先遍历和深度优先遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * @version 0.1</span></span><br><span class=\"line\"><span class=\"comment\"> * @date 2022-04-21</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @copyright Copyright (c) 2022</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">/**&lt; 相同元素计数 */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span>* <span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span>* <span class=\"title\">right</span>;</span></span><br><span class=\"line\">&#125; BinTreeNode;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*********************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用链表实现stack用于深度优先搜索</span></span><br><span class=\"line\"><span class=\"comment\"> ********************************************************/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    BinTreeNode* bin_tree_node;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; ListNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">Stack</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">is_empty</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">push_stack</span><span class=\"params\">(Stack* <span class=\"built_in\">stack</span>, BinTreeNode* tree_node)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ListNode* node = (ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ListNode));</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;bin_tree_node = tree_node;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*<span class=\"built_in\">stack</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *<span class=\"built_in\">stack</span> = node;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    node-&gt;next = *<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    *<span class=\"built_in\">stack</span> = node;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BinTreeNode* <span class=\"title function_\">pop_stack</span><span class=\"params\">(Stack* <span class=\"built_in\">stack</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*<span class=\"built_in\">stack</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* backup = *<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">        BinTreeNode* ret = (*<span class=\"built_in\">stack</span>)-&gt;bin_tree_node;</span><br><span class=\"line\">        *<span class=\"built_in\">stack</span> = (*<span class=\"built_in\">stack</span>)-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(backup);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">make_stack_empty</span><span class=\"params\">(Stack* <span class=\"built_in\">stack</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">stack</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* backup;</span><br><span class=\"line\">        backup = *<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">        *<span class=\"built_in\">stack</span> = (*<span class=\"built_in\">stack</span>)-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(backup);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BinTreeNode* <span class=\"title function_\">get_top_elem</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>-&gt;bin_tree_node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/****************************</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现队列用于广度优先算法</span></span><br><span class=\"line\"><span class=\"comment\"> ***************************/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Queue</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    ListNode* front;</span><br><span class=\"line\">    ListNode* rear;</span><br><span class=\"line\">&#125; Queue;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">enqueue</span><span class=\"params\">(Queue* <span class=\"built_in\">queue</span>, BinTreeNode* tree_node)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error queue is NULL\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode* node = (ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ListNode));</span><br><span class=\"line\">    node-&gt;bin_tree_node = tree_node;</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>-&gt;rear)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;rear = node;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;front = <span class=\"built_in\">queue</span>-&gt;rear;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;rear-&gt;next = node;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;rear = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BinTreeNode* <span class=\"title function_\">dequeue</span><span class=\"params\">(Queue* <span class=\"built_in\">queue</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error: queue does not exist\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>-&gt;front)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error: queue is empty\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ListNode* list_node = <span class=\"built_in\">queue</span>-&gt;front;</span><br><span class=\"line\">        BinTreeNode* tree_node = list_node-&gt;bin_tree_node;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;front == <span class=\"built_in\">queue</span>-&gt;rear)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">queue</span>-&gt;front = <span class=\"built_in\">queue</span>-&gt;rear = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">queue</span>-&gt;front = <span class=\"built_in\">queue</span>-&gt;front-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(list_node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree_node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*******************************************</span></span><br><span class=\"line\"><span class=\"comment\"> *  实现伸展树 </span></span><br><span class=\"line\"><span class=\"comment\"> *******************************************/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span>* <span class=\"title\">SplayTree</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinTreeNode</span>* <span class=\"title\">Position</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 插入操作就跟二叉搜索树插入一样，不做平衡操作</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param splay_tree </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return SplayTree </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">(SplayTree* root, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BinTreeNode* node = (BinTreeNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BinTreeNode));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    node-&gt;val = x;</span><br><span class=\"line\">    node-&gt;count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    node-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *root = node;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SplayTree pos = *root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; pos-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos = pos-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos-&gt;left = node;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; pos-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos = pos-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos-&gt;right = node;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos-&gt;val == x)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ++pos-&gt;count;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 二叉查找树的查找操作</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return Position </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Position <span class=\"title function_\">find_search_tree</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:not found\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; root-&gt;val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_search_tree(root-&gt;left, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; root-&gt;val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_search_tree(root-&gt;right, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">find_max</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_max(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">find_min</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;left)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_min(root-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 删除元素，删除操作跟二叉查找树的删除一致</span></span><br><span class=\"line\"><span class=\"comment\"> * 为了保持删除元素后的树依然是查找树，需要将删除节点的左子树的最大值</span></span><br><span class=\"line\"><span class=\"comment\"> * 或者右子树中的最小值移动到删除的地方，移动有两种方案：</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. 仅移动链表节点中的值</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. 移动链表的节点</span></span><br><span class=\"line\"><span class=\"comment\"> * 这里使用第1种方案, 第2种有点麻烦</span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return Position </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Position <span class=\"title function_\">delete</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:not found\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; root-&gt;val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = delete(root-&gt;left, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; root-&gt;val)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = delete(root-&gt;right, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;count &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                --root-&gt;count;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Position tmp = find_min(root-&gt;right);</span><br><span class=\"line\">                root-&gt;val = tmp-&gt;val;</span><br><span class=\"line\">                root-&gt;count = tmp-&gt;count;</span><br><span class=\"line\">                root-&gt;right = delete(root-&gt;right, tmp-&gt;val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Position tmp = root;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!root-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 清空树，释放内存</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @return Position </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Position <span class=\"title function_\">delete_all</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            root-&gt;left = delete_all(root-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            root-&gt;right =  delete_all(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(root);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">splay_left_left</span><span class=\"params\">(Position g, Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    g-&gt;left = p-&gt;right;</span><br><span class=\"line\">    p-&gt;left = cur-&gt;right;</span><br><span class=\"line\">    p-&gt;right = g;</span><br><span class=\"line\">    cur-&gt;right = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">splay_left_right</span><span class=\"params\">(Position g, Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* cur跟p互换 */</span></span><br><span class=\"line\">    p-&gt;right = cur-&gt;left;</span><br><span class=\"line\">    cur-&gt;left = p;</span><br><span class=\"line\">    g-&gt;left = cur;</span><br><span class=\"line\">    <span class=\"comment\">/* cur跟g互换 */</span></span><br><span class=\"line\">    g-&gt;left = cur-&gt;right;</span><br><span class=\"line\">    cur-&gt;right = g;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">splay_right_left</span><span class=\"params\">(Position g, Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* cur跟p互换 */</span></span><br><span class=\"line\">    p-&gt;left = cur-&gt;right;</span><br><span class=\"line\">    cur-&gt;right = p;</span><br><span class=\"line\">    g-&gt;right = cur;</span><br><span class=\"line\">    <span class=\"comment\">/* cur跟g互换 */</span></span><br><span class=\"line\">    g-&gt;left = cur-&gt;left;</span><br><span class=\"line\">    cur-&gt;left = g;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">splay_right_right</span><span class=\"params\">(Position g, Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    g-&gt;right = p-&gt;left;</span><br><span class=\"line\">    p-&gt;right = cur-&gt;left;</span><br><span class=\"line\">    p-&gt;left = g;</span><br><span class=\"line\">    cur-&gt;left = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">rotate_left</span><span class=\"params\">(Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    p-&gt;left = cur-&gt;right;</span><br><span class=\"line\">    cur-&gt;right = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Position <span class=\"title function_\">rotate_right</span><span class=\"params\">(Position p, Position cur)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    p-&gt;right = cur-&gt;left;</span><br><span class=\"line\">    cur-&gt;left = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 伸展树的查找操作要求将找到的元素伸展到根节点</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param cur_pos </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return Position </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Position <span class=\"title function_\">find</span><span class=\"params\">(SplayTree cur_pos, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cur_pos)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack <span class=\"built_in\">stack</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; cur_pos-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur_pos-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                push_stack(&amp;<span class=\"built_in\">stack</span>, cur_pos);</span><br><span class=\"line\">                cur_pos = cur_pos-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:not found\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; cur_pos-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur_pos-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                push_stack(&amp;<span class=\"built_in\">stack</span>, cur_pos);</span><br><span class=\"line\">                cur_pos = cur_pos-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:not found\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;find it\\n&quot;</span>);</span><br><span class=\"line\">            Position p, q, r;</span><br><span class=\"line\">            p = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">            q = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">            r = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">            <span class=\"comment\">/* 找到元素后通过伸展将元素放到根节点*/</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* 栈里没有元素，那么cur_pos就是根节点 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!p &amp;&amp; !q &amp;&amp; !r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/* 说明当前cur_pos变量保存的节点的父节点是根节点,旋转一次就行 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p &amp;&amp; !q &amp;&amp; !r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (p-&gt;left == cur_pos)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        cur_pos = rotate_right(p, cur_pos);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        cur_pos = rotate_left(p, cur_pos);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/* zig-zig模式 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (q-&gt;left == p &amp;&amp; p-&gt;left == cur_pos)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cur_pos = splay_left_left(q, p ,cur_pos);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q-&gt;right == p &amp;&amp; p-&gt;right == cur_pos)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cur_pos = splay_right_right(q, p ,cur_pos);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/* zig-zag模式 */</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q-&gt;left == p &amp;&amp; p-&gt;right == cur_pos)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cur_pos = splay_left_right(q, p ,cur_pos);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q-&gt;right == p &amp;&amp; p-&gt;left == cur_pos)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cur_pos = splay_right_left(q, p, cur_pos);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r-&gt;left == q)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    r-&gt;left = cur_pos;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    r-&gt;right = cur_pos;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                p = r;</span><br><span class=\"line\">                q = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">                r = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cur_pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 随机生成一棵二叉查找树</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param size </span></span><br><span class=\"line\"><span class=\"comment\"> * @return SplayTree </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SplayTree <span class=\"title function_\">make_random_bin_tree</span><span class=\"params\">(<span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span></span><br><span class=\"line\">    gettimeofday(&amp;tv, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    srand((<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)(tv.tv_usec));</span><br><span class=\"line\">    SplayTree tree = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[random:]&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (size--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x = rand() % <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, x);</span><br><span class=\"line\">        insert(&amp;tree, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 深度优先遍历(后序遍历)</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">traverse_DFS</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Stack <span class=\"built_in\">stack</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = push_stack(&amp;<span class=\"built_in\">stack</span>, root);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;push_stack error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!is_empty(<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        BinTreeNode* ret = pop_stack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:ret is NULL\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, ret-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            push_stack(&amp;<span class=\"built_in\">stack</span>, ret-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret-&gt;left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            push_stack(&amp;<span class=\"built_in\">stack</span>, ret-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">is_empty_queue</span><span class=\"params\">(Queue* <span class=\"built_in\">queue</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>-&gt;front == <span class=\"built_in\">queue</span>-&gt;rear &amp;&amp; <span class=\"built_in\">queue</span>-&gt;front == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 广度优先遍历(层序遍历)</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">traverse_BFS</span><span class=\"params\">(SplayTree root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Queue <span class=\"built_in\">queue</span> = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    enqueue(&amp;<span class=\"built_in\">queue</span>, root);</span><br><span class=\"line\">    <span class=\"type\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!is_empty_queue(&amp;<span class=\"built_in\">queue</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        BinTreeNode* node = dequeue(&amp;<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            enqueue(&amp;<span class=\"built_in\">queue</span>, node-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            enqueue(&amp;<span class=\"built_in\">queue</span>, node-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 前序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param level </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">pre_order_traverse</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d &quot;</span>, level, root-&gt;val);</span><br><span class=\"line\">        pre_order_traverse(root-&gt;left, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        pre_order_traverse(root-&gt;right, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 中序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param level </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">in_order_traverse</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        in_order_traverse(root-&gt;left, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d &quot;</span>, level, root-&gt;val);</span><br><span class=\"line\">        in_order_traverse(root-&gt;right, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 后序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param level </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">post_order_traverse</span><span class=\"params\">(SplayTree root, <span class=\"type\">int</span> level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        post_order_traverse(root-&gt;left, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        post_order_traverse(root-&gt;right, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d-%p &quot;</span>, level, root-&gt;val, root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//SplayTree root = make_random_bin_tree(10);</span></span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">2</span>,<span class=\"number\">84</span>,<span class=\"number\">69</span>,<span class=\"number\">98</span>,<span class=\"number\">73</span>,<span class=\"number\">62</span>,<span class=\"number\">20</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    SplayTree root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insert(&amp;root, arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root = find(root, <span class=\"number\">73</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;--%p--\\n&quot;</span>, find_search_tree(root, <span class=\"number\">62</span>));</span><br><span class=\"line\">    delete(root, <span class=\"number\">50</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;---------------------\\n&quot;</span>);</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    in_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    post_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    traverse_DFS(root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    traverse_BFS(root);</span><br><span class=\"line\">    delete_all(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构与算法"],"tags":["二叉查找树","栈","队列","伸展树"]},{"title":"AVL-tree","url":"/2022/04/29/AVL-tree/","content":"<blockquote>\n<p>AVL树（Adelson-Velsky and Landis Tree）是计算机科学中最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @file AVLTree.c</span></span><br><span class=\"line\"><span class=\"comment\"> * @author your name (you@domain.com)</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 实现AVL树</span></span><br><span class=\"line\"><span class=\"comment\"> * @version 0.1</span></span><br><span class=\"line\"><span class=\"comment\"> * @date 2022-04-11</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @copyright Copyright (c) 2022</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;errno.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;string.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;math.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _Search_Tree_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _Search_Tree_H</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> <span class=\"title\">TreeNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">SearchTRee</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">Position</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ERorateDir</span>&#123;</span></span><br><span class=\"line\">    ROTATE_L = <span class=\"number\">1</span>,</span><br><span class=\"line\">    ROTATE_R,</span><br><span class=\"line\">&#125;ERorateDir;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> elem;</span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">/**&lt; 一个节点相同元素计数 */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> height; <span class=\"comment\">///&lt; 树的高度</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">right</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">releaseSTree</span><span class=\"params\">(TreeNode* t)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!t)&#123;</span><br><span class=\"line\">        TreeNode* left = (t)-&gt;left;</span><br><span class=\"line\">        TreeNode* right = (t)-&gt;right;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(t);</span><br><span class=\"line\">        releaseSTree(left);</span><br><span class=\"line\">        releaseSTree(right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 计算树的高度 */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">height</span><span class=\"params\">(Position root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Line:%d, error:node does not exist\\n&quot;</span>, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmax(root-&gt;left-&gt;height, root-&gt;right-&gt;height) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;left-&gt;height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;right-&gt;height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 计算左右子树的高度差 */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">height_lr_diff</span><span class=\"params\">(Position root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right &amp;&amp; root-&gt;left)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;left-&gt;height &gt; root-&gt;left-&gt;height? \\</span><br><span class=\"line\">               root-&gt;left-&gt;height - root-&gt;right-&gt;height: \\</span><br><span class=\"line\">               root-&gt;right-&gt;height - root-&gt;left-&gt;height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;left-&gt;height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;right-&gt;height + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 单旋转 */</span></span><br><span class=\"line\">Position <span class=\"title function_\">singleRotate</span><span class=\"params\">(Position k, ERorateDir dir)</span>&#123;</span><br><span class=\"line\">    Position k1;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dir == ROTATE_L)&#123;</span><br><span class=\"line\">        k1 = k-&gt;left;</span><br><span class=\"line\">        k-&gt;left = k1-&gt;right;</span><br><span class=\"line\">        k1-&gt;right = k;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dir == ROTATE_R)&#123;</span><br><span class=\"line\">        k1 = k-&gt;right;</span><br><span class=\"line\">        k-&gt;right = k1-&gt;left;</span><br><span class=\"line\">        k1-&gt;left = k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    k-&gt;height = height(k);</span><br><span class=\"line\">    k1-&gt;height = height(k1);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> k1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* L_R型双旋转 */</span></span><br><span class=\"line\">Position <span class=\"title function_\">doubleRotateWithLeft</span><span class=\"params\">(Position k)</span>&#123;</span><br><span class=\"line\">    k-&gt;left = singleRotate(k-&gt;left, ROTATE_R);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleRotate(k, ROTATE_L);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* R-L型双旋转 */</span></span><br><span class=\"line\">Position <span class=\"title function_\">doubleRotateWithRight</span><span class=\"params\">(Position k)</span>&#123;</span><br><span class=\"line\">    k-&gt;right = singleRotate(k-&gt;right, ROTATE_L);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleRotate(k, ROTATE_R);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 插入操作，插入后做平衡调整</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param tree </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return TreeNode*，新树的root节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">TreeNode* <span class=\"title function_\">insert</span><span class=\"params\">(TreeNode* tree, <span class=\"type\">int</span> x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">        tree = (TreeNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(TreeNode));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error:out of memory\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tree-&gt;elem = x;</span><br><span class=\"line\">        tree-&gt;count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        tree-&gt;height = <span class=\"number\">0</span>;</span><br><span class=\"line\">        tree-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        tree-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> diff_height;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; tree-&gt;elem)&#123;</span><br><span class=\"line\">            tree-&gt;left = insert(tree-&gt;left, x);</span><br><span class=\"line\">            diff_height = height_lr_diff(tree);</span><br><span class=\"line\">            <span class=\"comment\">/* 插入之后判断是否需要调整平衡 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff_height == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">/* L-L型 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x &lt; tree-&gt;left-&gt;elem)&#123;</span><br><span class=\"line\">                    tree = singleRotate(tree, ROTATE_L);</span><br><span class=\"line\">                <span class=\"comment\">/* L-R型 */</span></span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; tree-&gt;left-&gt;elem)&#123;</span><br><span class=\"line\">                    tree = doubleRotateWithLeft(tree);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; tree-&gt;elem)&#123;</span><br><span class=\"line\">            tree-&gt;right = insert(tree-&gt;right, x);</span><br><span class=\"line\">            diff_height = height_lr_diff(tree);</span><br><span class=\"line\">            <span class=\"comment\">/* 插入之后判断是否需要调整平衡 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff_height == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">/* R-R型 */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x &gt; tree-&gt;right-&gt;elem)&#123;</span><br><span class=\"line\">                    tree = singleRotate(tree, ROTATE_R);</span><br><span class=\"line\">                <span class=\"comment\">/* R-L型 */</span></span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &lt; tree-&gt;right-&gt;elem)&#123;</span><br><span class=\"line\">                    tree = doubleRotateWithRight(tree);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ++ tree-&gt;count;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree-&gt;height = height(tree);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TreeNode* <span class=\"title function_\">find</span><span class=\"params\">(TreeNode* tree, <span class=\"type\">int</span> x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == tree-&gt;elem)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &lt; tree-&gt;elem)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(tree-&gt;left, x);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(tree-&gt;right, x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TreeNode* <span class=\"title function_\">findMin</span><span class=\"params\">(TreeNode* tree)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree-&gt;left)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findMin(tree-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TreeNode* <span class=\"title function_\">findMax</span><span class=\"params\">(TreeNode* tree)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree-&gt;right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findMax(tree-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief AVL树的删除，删除后需要做调整平衡</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param tree </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> * @return TreeNode* ,新树的root节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">TreeNode* </span><br><span class=\"line\"><span class=\"title function_\">delete</span><span class=\"params\">(root, x)</span></span><br><span class=\"line\">TreeNode* root;<span class=\"type\">int</span> x;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Line:%d, error: node does not exist\\n&quot;</span>, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> height_diff;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; root-&gt;elem)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = delete(root-&gt;left, x);</span><br><span class=\"line\">        height_diff = height_lr_diff(root);</span><br><span class=\"line\">        <span class=\"comment\">/* 1.如果被删除的元素不是叶子节点，需要去高的子树中去找替代的叶子节点，</span></span><br><span class=\"line\"><span class=\"comment\">        然后删除叶子节点。</span></span><br><span class=\"line\"><span class=\"comment\">        2.如果本来要删除的就是叶子节点，那跟上面的后半部分动作一致。</span></span><br><span class=\"line\"><span class=\"comment\">        所以只有叶子节点被删除之后才会需要调整 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (height_diff == <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* x是删除的元素,删除后O是最小不平衡子树的root</span></span><br><span class=\"line\"><span class=\"comment\">                O</span></span><br><span class=\"line\"><span class=\"comment\">              /   \\</span></span><br><span class=\"line\"><span class=\"comment\">             x     o</span></span><br><span class=\"line\"><span class=\"comment\">                  /</span></span><br><span class=\"line\"><span class=\"comment\">                 o</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            <span class=\"comment\">/* 这种情况必须用双旋转，单旋转不能改变深度 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!root-&gt;right-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = doubleRotateWithRight(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">                O                       O   </span></span><br><span class=\"line\"><span class=\"comment\">              /   \\                   /   \\</span></span><br><span class=\"line\"><span class=\"comment\">             x     o         或者    x     o</span></span><br><span class=\"line\"><span class=\"comment\">                    \\                    /  \\</span></span><br><span class=\"line\"><span class=\"comment\">                     o                  o    o</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            <span class=\"comment\">/* 单旋转 */</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = singleRotate(root, ROTATE_R);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &gt; root-&gt;elem)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = delete(root-&gt;right, x);</span><br><span class=\"line\">        height_diff = height_lr_diff(root);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (height_diff == <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* x是删除的元素,删除后O是最小不平衡子树的root</span></span><br><span class=\"line\"><span class=\"comment\">                   O</span></span><br><span class=\"line\"><span class=\"comment\">                 /   \\</span></span><br><span class=\"line\"><span class=\"comment\">                o     x</span></span><br><span class=\"line\"><span class=\"comment\">                 \\</span></span><br><span class=\"line\"><span class=\"comment\">                  o</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            <span class=\"comment\">/* 这种情况必须用双旋转，单旋转不能改变深度 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!root-&gt;left-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = doubleRotateWithLeft(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/*       O                  O</span></span><br><span class=\"line\"><span class=\"comment\">                   /   \\              /   \\</span></span><br><span class=\"line\"><span class=\"comment\">                  o     x   或者     o     x</span></span><br><span class=\"line\"><span class=\"comment\">                /   \\               /</span></span><br><span class=\"line\"><span class=\"comment\">               o     o             o</span></span><br><span class=\"line\"><span class=\"comment\">           */</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = singleRotate(root, ROTATE_L);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 左右子树都存在 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;count &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                --root-&gt;count;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 从高的子树中找到元素替换将要删除的节点位置，保证左右子树是平衡的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;left-&gt;height &gt; root-&gt;right-&gt;height)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">/* 在左子树中找到最大的值，也就是右子树是空的节点，将它移到将要删除的节点位置 */</span></span><br><span class=\"line\">                    TreeNode* tmp = findMax(root-&gt;left);</span><br><span class=\"line\">                    root-&gt;elem = tmp-&gt;elem;</span><br><span class=\"line\">                    root-&gt;count -= tmp-&gt;count;</span><br><span class=\"line\">                    <span class=\"comment\">/* 删除移动了元素的节点 */</span></span><br><span class=\"line\">                    root-&gt;left = delete(root-&gt;left, tmp-&gt;elem);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">/* 在右子树中找到最小的值，也就是左子树是空的节点，将它移到将要删除的节点位置 */</span></span><br><span class=\"line\">                    TreeNode* tmp = findMin(root-&gt;right);</span><br><span class=\"line\">                    root-&gt;elem = tmp-&gt;elem;</span><br><span class=\"line\">                    root-&gt;count -= tmp-&gt;count;</span><br><span class=\"line\">                    <span class=\"comment\">/* 删除移动了元素的节点 */</span></span><br><span class=\"line\">                    root-&gt;right = delete(root-&gt;right, tmp-&gt;elem);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 只存在一个子树,或者不存在子树 */</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TreeNode* tmpNode = root;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!root-&gt;left)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* 如果两个子树都是空，将right给root也没问题，因为right就是NULL */</span></span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(tmpNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;height = height(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 前序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param root </span></span><br><span class=\"line\"><span class=\"comment\"> * @param level </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">pre_order_traverse</span><span class=\"params\">(SearchTRee root, <span class=\"type\">int</span> level)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d &quot;</span>, level, root-&gt;elem);</span><br><span class=\"line\">        pre_order_traverse(root-&gt;left, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        pre_order_traverse(root-&gt;right, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">2</span>,<span class=\"number\">84</span>,<span class=\"number\">69</span>,<span class=\"number\">98</span>,<span class=\"number\">73</span>,<span class=\"number\">62</span>,<span class=\"number\">20</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">    SearchTRee root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root = insert(root, arr[i]);</span><br><span class=\"line\">        pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    root = delete(root, <span class=\"number\">50</span>);</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    root = delete(root, <span class=\"number\">32</span>);</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    root = delete(root, <span class=\"number\">62</span>);</span><br><span class=\"line\">    pre_order_traverse(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    releaseSTree(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构与算法"],"tags":["查找二叉树","平衡查找二叉树"]},{"title":"质数判断和筛质数","url":"/2022/04/29/prime-number/","content":"<p>给定一定范围的自然数，找出里面所有的质数主要有2种方式：</p>\n<ol>\n<li>遍历每一个数并判断是不是质数，如果是就存起来。</li>\n<li>借助一定的算法直接筛选。<span id=\"more\"></span></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdbool.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;math.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/******************判断质数**********************/</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 枚举法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 版本1：根据质数的定义，对于大于2的自然数n，从2开始到n-1看是否存在能整除n的数，</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果存在，则是合数，否则为质数</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 版本2：无需判断从2~n-1的所有数，只需要判断2~n的平方根的数是否能整除就行</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 版本3：对于所有大于3的质数具有6n+1(n &gt;= 1)或者6n-1的性质</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 结合2和3的代码示例，时间复杂度O(sqrt(n))</span></span><br><span class=\"line\"><span class=\"comment\">// leetcode中，计算从1到709486有几个质数，耗时28ms</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">isPrime3</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span> || n == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n % <span class=\"number\">6</span> != <span class=\"number\">1</span> &amp;&amp; n % <span class=\"number\">6</span> != <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">5</span>; i &lt;= j; i += <span class=\"number\">6</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 形如6k+1(k &gt;= 1)或者6k-1的合数，一定可以被6m+1或者6m-1的数所整除</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为合数肯定可以因式分解，而所有的质数都形如6m + 1 或者6m - 1(m &gt;=1)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n % i == <span class=\"number\">0</span> || n % (i + <span class=\"number\">2</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 分解质因数-短除法</span></span><br><span class=\"line\"><span class=\"comment\"> * 版本1：要从最小的质数除起（依次除于质数2 3 5....)一直到n，时间复杂度为O(n)</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 版本2：n中最多只含有一个大于sqrt(n)的质因子。</span></span><br><span class=\"line\"><span class=\"comment\"> *       证明：通过反证法：如果有两个大于sqrt(n)的因子，那么相乘会大于n，矛盾。证毕</span></span><br><span class=\"line\"><span class=\"comment\"> *       于是我们发现最多只有一个大于sqrt(n)的因子，对其进行优化。先考虑比sqrt(n)小的，代码和质数的判定类似</span></span><br><span class=\"line\"><span class=\"comment\"> *       最后如果n还是&gt;1，说明此时的n就是大于sqrt(n)的唯一质因子，输出即可，时间复杂度O(sqrt(n))</span></span><br><span class=\"line\"><span class=\"comment\"> * 这种方法，运算次数太多，还不如枚举法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">divide1</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 证明一下循环里面的i一定是一个质数：假如 i 是一个合数，</span></span><br><span class=\"line\">        <span class=\"comment\">// 那么它一定可以分解成多个质因子相乘的形式，</span></span><br><span class=\"line\">        <span class=\"comment\">// 这多个质因子同时也是 n 的质因子且比i要小，</span></span><br><span class=\"line\">        <span class=\"comment\">// 而比i小的数在之前的循环过程中一定是被条件除完了的，所以i不可能是合数，只可能是质数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n % i == <span class=\"number\">0</span>)<span class=\"comment\">//i一定是质数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(n % i == <span class=\"number\">0</span>)<span class=\"comment\">//短除法分解质因数</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                n /= i;</span><br><span class=\"line\">                ++s;<span class=\"comment\">//统计质因数的个数</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s &gt; <span class=\"number\">1</span>? <span class=\"literal\">false</span>:<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用此方法，leetcode中，计算从1到709486有几个质数，耗时408ms</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">divide2</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n / i; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n % i == <span class=\"number\">0</span>)<span class=\"comment\">//i一定是质数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//s = 0;</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(n % i == <span class=\"number\">0</span>)<span class=\"comment\">//短除法分解质因数</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                n /= i;</span><br><span class=\"line\">                ++s;<span class=\"comment\">//统计质因数的个数</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//printf(&quot;%d %d\\n&quot;, i, s);</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//if(n &gt; 1) printf(&quot;%d %d\\n&quot;, n, 1);//当n没有变化的时候，输出本身和1</span></span><br><span class=\"line\">    n &gt; <span class=\"number\">1</span>? ++s:s; <span class=\"comment\">// n还是大于1的，说明此时的n就是一个质数，s需要加1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s &gt; <span class=\"number\">1</span>? <span class=\"literal\">false</span>:<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">countPrimes</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">        divide1(i)?++res:res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///////////////////////////筛质数///////////////////////////</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 朴素筛法</span></span><br><span class=\"line\"><span class=\"comment\"> * 枚举i：2~n，从前往后把每个数对应的倍数都删除掉，这样筛过之后，所有剩下的数都是质数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//朴素筛法-O(nlogn)</span></span><br><span class=\"line\"><span class=\"comment\">// leetcode n=709486时耗时28ms</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">countPrimes1</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储质数</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* primeNums = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(n * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 标记</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* flag = (<span class=\"type\">int</span>*)<span class=\"built_in\">calloc</span>(n + <span class=\"number\">1</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag[i])&#123;</span><br><span class=\"line\">            primeNums[count++] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将所有i的倍数都标记，这些标记的数肯定是合数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i + i; j &lt; n; j += i)&#123;</span><br><span class=\"line\">            flag[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(primeNums);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(flag);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">埃氏筛法是对朴素筛法的一种优化方式，我们并不需要把2~n的每一个数的倍数都删掉，可以只把所有质数的倍数删掉！</span></span><br><span class=\"line\"><span class=\"comment\">因为合数的倍数，肯定也是比这个合数小的质数的某个倍数</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度：O(n * loglogn)，近似O(n)</span></span><br><span class=\"line\"><span class=\"comment\"> * // leetcode n = n=709486时耗时8ms</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">countPrimes2</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储质数</span></span><br><span class=\"line\">    <span class=\"comment\">//int* primeNums = (int*)malloc(n * sizeof(int));</span></span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 标记</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* flag = (<span class=\"type\">int</span>*)<span class=\"built_in\">calloc</span>(n, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 进入这个if条件的都是质数，合数都在之前的循环中被标记为true了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag[i])&#123;</span><br><span class=\"line\">            <span class=\"comment\">// primeNums[count++] = i;</span></span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">            <span class=\"comment\">// 将所有i的倍数都标记，这些标记的数肯定是合数</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i + i; j &lt; n; j += i)&#123;</span><br><span class=\"line\">                flag[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//free(primeNums);</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(flag);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">线性（欧拉）筛法</span></span><br><span class=\"line\"><span class=\"comment\">埃氏筛法的缺陷 ：对于一个合数，有可能被筛多次。例如 30 = 2 * 15 = 3 * 10 = 5*6……</span></span><br><span class=\"line\"><span class=\"comment\">那么如何确保每个合数只被筛选一次呢？我们只要用它的最小质因子来筛选即可，这便是欧拉筛法。</span></span><br><span class=\"line\"><span class=\"comment\">欧拉筛法的基本思想 ：在埃氏筛法的基础上，让每个合数只被它的最小质因子筛选一次，以达到不重复的目的。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">countPrimes3</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储质数</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* primeNums = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(n * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 标记合数</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* flag = (<span class=\"type\">int</span>*)<span class=\"built_in\">calloc</span>(n, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将数从小到大遍历的过程中，没被标记的数一定是质数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag[i])&#123;</span><br><span class=\"line\">            primeNums[count++] = i;</span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 以下这组循环，意思是以一个固定的倍数i去乘以不同的质数，并加上0 == i % primeNums[j]判断来保证</span></span><br><span class=\"line\">        <span class=\"comment\">// 这些数是以primeNums[j]为最小质因数的合数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; i * primeNums[j] &lt; n; ++j)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// primeNums[]存放的是从小到大排列的质数，i在内循环中都是不变的，</span></span><br><span class=\"line\">            <span class=\"comment\">// i作为一个倍数去乘以质数来得到不同的合数。当j从0开始遍历的时候，</span></span><br><span class=\"line\">            <span class=\"comment\">// 一开始的一次或几次循环中，i * primeNums[j]得到的合数，肯定是以</span></span><br><span class=\"line\">            <span class=\"comment\">// primeNums[j]为最小质因数的。那么这些数都可以打上标记。i % primeNums[j] == 0</span></span><br><span class=\"line\">            <span class=\"comment\">// 是在判断primeNums[j]是不是i的最小质因数。当j继续增大，</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果出现某个i0可以被某个primeNums[j0]整除，说明此时i0可以分解成</span></span><br><span class=\"line\">            <span class=\"comment\">// primeNums[j0]和一个比primeNums[j0]大的质数的乘积，我们将这个比primeNums[j0]大</span></span><br><span class=\"line\">            <span class=\"comment\">// 的数称为primeNums[j1]。此时，</span></span><br><span class=\"line\">            <span class=\"comment\">// i0 * primeNums[j0] = primeNums[j0] * primeNums[j1] * primeNums[j0](其中j1 &gt; j0)。</span></span><br><span class=\"line\">            <span class=\"comment\">// primeNums[j0]的值还是i0 * primeNums[j0]这个合数的最小质因数，但是下一次循环，</span></span><br><span class=\"line\">            <span class=\"comment\">// 也就是i0 * primeNums[k0](其中k0 = j0 + 1)，却不是以primeNums[k0]为最小质因数的合数了，</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为i0 * primeNums[k0] = primeNums[j0] * primeNums[j1] * primeNums[k0],</span></span><br><span class=\"line\">            <span class=\"comment\">// 这里最小的质数是primeNums[j0],i0已经可以被上一次循环的primeNums[j0]因式分解。</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果仍然标记flag[i0 * primeNums[k0]] = 1,会造成重复标记。因为</span></span><br><span class=\"line\">            <span class=\"comment\">// 令i_ = primeNums[j1] * primeNums[k0] &gt; i0, i0 * primeNums[k0] = i_ * primeNums[j0],</span></span><br><span class=\"line\">            <span class=\"comment\">// 即当外层循环递增到i_时，又会标记一次i0 * primeNums[k0]这个合数。</span></span><br><span class=\"line\">            <span class=\"comment\">// 所以当i % primeNums[j] == 0时，应该推出循环了。</span></span><br><span class=\"line\">            flag[i * primeNums[j]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// j继续增大，会不会一直找不到primeNums[j]可以整除i,不可能，为什么？</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为小于等于i的质数都在primeNums中，</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果i是合数，合数一定可以因式分解，一定存在小于i的质数能整除i，</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果i是质数，那么i已经放在了primeNums中，正好是最后一个，</span></span><br><span class=\"line\">            <span class=\"comment\">// 质数当然可以被自己整除。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"number\">0</span> == i % primeNums[j]))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(primeNums);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(flag);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">709486</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        n = atoi(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;count:%d\\n&quot;</span>, countPrimes2(n));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构与算法"],"tags":["数学","质数"]},{"title":"二叉堆","url":"/2022/05/05/heap/","content":"<blockquote>\n<p>二叉堆（英语：binary heap）是一种特殊的堆，二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足堆特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。<br>当父节点的键值总是大于或等于任何一个子节点的键值时为“最大堆”。当父节点的键值总是小于或等于任何一个子节点的键值时为“最小堆”。—-Wikipedia</p>\n</blockquote>\n<span id=\"more\"></span>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @file heap.c</span></span><br><span class=\"line\"><span class=\"comment\"> * @author your name (you@domain.com)</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 二叉堆，二叉堆一般使用使用数组实现，在逻辑结构上又具有二叉树的特征，</span></span><br><span class=\"line\"><span class=\"comment\"> * 数组下标一般从1开始，这样对于任意的下标为i的非叶子节点，它的左子节点下标是2i,右子节点是2i+1。</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果数组下标从0开始，这样对于任意的下标为i的非叶子节点，它的左子节点下标是2i+1,右子节点是2i+2。</span></span><br><span class=\"line\"><span class=\"comment\"> * @version 0.1</span></span><br><span class=\"line\"><span class=\"comment\"> * @date 2022-04-15</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @copyright Copyright (c) 2022</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\">    <span class=\"type\">int</span>* heap;</span><br><span class=\"line\">&#125; HeapStruct;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">HeapStruct* <span class=\"title function_\">initialize</span><span class=\"params\">(<span class=\"type\">int</span> maxSize)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HeapStruct* h = (HeapStruct*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(HeapStruct));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!h)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h-&gt;capacity = maxSize;</span><br><span class=\"line\">    h-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    h-&gt;heap = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>((maxSize + <span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>)); <span class=\"comment\">/**&lt; 加1是因为数组从下标1开始，空间要多一个 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!h-&gt;heap)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">deinitialize</span><span class=\"params\">(HeapStruct* h)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h-&gt;heap)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(h-&gt;heap);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 在堆中插入数据，使用上滤percolate up</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param h </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">(HeapStruct* h, <span class=\"type\">int</span> x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h-&gt;size == h-&gt;capacity)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = ++h-&gt;size;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; (i &gt;&gt; <span class=\"number\">1</span>) &gt;= <span class=\"number\">1</span> &amp;&amp; h-&gt;heap[i &gt;&gt; <span class=\"number\">1</span>] &gt; x; i &gt;&gt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        h-&gt;heap[i] = h-&gt;heap[i &gt;&gt; <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h-&gt;heap[i] = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 删除最小元素，下滤</span></span><br><span class=\"line\"><span class=\"comment\"> * 上滤或者下滤过程类似于插入排序</span></span><br><span class=\"line\"><span class=\"comment\"> * @param h </span></span><br><span class=\"line\"><span class=\"comment\"> * @param x </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">deleteMin</span><span class=\"params\">(HeapStruct* h)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h-&gt;size == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;no element\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">int</span> min = h-&gt;heap[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> child;</span><br><span class=\"line\">    <span class=\"type\">int</span> lastOne = h-&gt;heap[h-&gt;size];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i * <span class=\"number\">2</span> &lt;= h-&gt;size;i = child)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        child = i * <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">/* 找到左右child中的最小者 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child &lt; h-&gt;size &amp;&amp; h-&gt;heap[child + <span class=\"number\">1</span>] &lt; h-&gt;heap[child])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 删除的时候，一定会有一个位置空出来，</span></span><br><span class=\"line\"><span class=\"comment\">           使用左右子元素和最后一个元素三者间最小的元素去填充</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastOne &gt; h-&gt;heap[child])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            h-&gt;heap[i] = h-&gt;heap[child];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h-&gt;heap[i] = lastOne;</span><br><span class=\"line\">    --h-&gt;size;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">array</span>[] = &#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    HeapStruct* h = initialize(<span class=\"keyword\">sizeof</span>(<span class=\"built_in\">array</span>)/<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(<span class=\"built_in\">array</span>)/<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        insert(h, <span class=\"built_in\">array</span>[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(<span class=\"built_in\">array</span>)/<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d,&quot;</span>, h-&gt;heap[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (h-&gt;size &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, deleteMin(h));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    deinitialize(h);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构与算法"]},{"title":"一些经典排序算法的实现","url":"/2022/05/05/sort/","content":"<p>冒泡排序、选择排序、插入排序、堆排序、希尔排序、计数排序、归并排序、快速排序、桶排序、基数排序<br>各排序算法的时间复杂度：</p>\n<span id=\"more\"></span>\n<p><img src=\"https://gitlab.com/iEngne/images/-/raw/main/2022/5/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png\" alt=\"各排序算法的时间复杂度\" title=\"各排序算法的时间复杂度\"></p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序在1956年就已经被研究，不用多说了，经典中的经典了。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>* a, <span class=\"type\">int</span>* b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != b)&#123;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">        *b = *a ^ *b;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 外循环用于控制内循环的右边界 */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; size - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &lt; size - <span class=\"number\">1</span> - i; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[j] &gt; nums[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                swap(&amp;num[j], &amp;num[j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 从序列中选择一个最大(或者最小)的，放到对应位置,</span></span><br><span class=\"line\"><span class=\"comment\"> * 由于从一个序列中选择最大或者最小的方式有多种，</span></span><br><span class=\"line\"><span class=\"comment\"> * 所以有多种选择排序,堆排序也可以看作是选择排序</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>* a, <span class=\"type\">int</span>* b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != b)&#123;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">        *b = *a ^ *b;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 简单选择排序 */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">selectionSort</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; size - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> minIndex = i;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i + <span class=\"number\">1</span>; j &lt; size; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[j] &lt; nums[minIndex])&#123;</span><br><span class=\"line\">                minIndex = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(&amp;nums[minIndex], &amp;nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>* a, <span class=\"type\">int</span>* b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != b)&#123;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">        *b = *a ^ *b;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">insertionSort</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> key = nums[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; key &lt; nums[j]; --j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            nums[j + <span class=\"number\">1</span>] = nums[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nums[j + <span class=\"number\">1</span>] = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>堆排序使用了二叉堆的特性，在二叉堆中，父节点总是比<br>子节点大或者小</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>* a, <span class=\"type\">int</span>* b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != b)&#123;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">        *b = *a ^ *b;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief max堆，下滤</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param nums </span></span><br><span class=\"line\"><span class=\"comment\"> * @param start </span></span><br><span class=\"line\"><span class=\"comment\"> * @param end </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">maxPercDown</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> dad, <span class=\"type\">int</span> end)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> child = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> tmp = nums[dad];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;dad * <span class=\"number\">2</span> + <span class=\"number\">1</span> &lt;= end; dad = child)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        child = dad * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">/* 找到左右子元素中的最大值 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child != end &amp;&amp; nums[child + <span class=\"number\">1</span>] &gt; nums[child])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[child] &gt; tmp)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            nums[dad] = nums[child];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nums[dad] = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">heapSrot</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 从最后一个父元素开始 */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> dad = size/<span class=\"number\">2</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 第一步，将数组转换成max堆 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; dad &gt;= <span class=\"number\">0</span>; --dad)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        maxPercDown(nums, dad, size - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 第二步，排序元素 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; size &gt;= <span class=\"number\">1</span>; --size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        swap(&amp;nums[<span class=\"number\">0</span>], &amp;nums[size - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        maxPercDown(nums, <span class=\"number\">0</span>, size - <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><p>希尔排序，1959 Donard L.Shell提出,也称递减增量排序算法,是优化的插入排序,插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * Hibbard提出1，3，7，15...，这样的2^k - 1序列用于增量排序效果</span></span><br><span class=\"line\"><span class=\"comment\"> * 比N = N / 2的效果好</span></span><br><span class=\"line\"><span class=\"comment\"> * Sedgewick提出1，5，19，41，109...,这样的项或者是9*4^i - 9*2^i + 1</span></span><br><span class=\"line\"><span class=\"comment\"> * 或者是4^i - 3*2^i + 1,比上面的Hibbard提出的效果好</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">shellSort</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> increment = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (increment = size &gt;&gt; <span class=\"number\">1</span>; increment &gt; <span class=\"number\">0</span>; increment &gt;&gt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/** 希尔排序的内部就是简单插入排序 */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = increment; i &lt; size; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> key = nums[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> j;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i - increment; j &gt;= <span class=\"number\">0</span> &amp;&amp; nums[j] &gt; key; j -= increment)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                nums[j + increment] = nums[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nums[j + increment] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p>计数排序，是一种非比较排序，作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数，并且数据最好集中在一定的范围内，如果有个数特别大或者特别小，内存浪费会比较大。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">find_max_min</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> size, <span class=\"type\">int</span>* p_max, <span class=\"type\">int</span>* p_min)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *p_max = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    *p_min = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &gt; *p_max)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            *p_max = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; *p_min)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            *p_min = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">counting_sort</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> max, min;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = find_max_min(arr, size, &amp;max, &amp;min);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;find max or min error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span>* sorted_arr = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(size * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>)+<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sorted_arr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span>* count_arr = (<span class=\"type\">int</span>*)<span class=\"built_in\">calloc</span>(max - min + <span class=\"number\">1</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!count_arr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(sorted_arr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"comment\">/* 这一步类似于哈希,将数的有序性转化为数组下标的有序性 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ++count_arr[arr[i] - min];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/****************下面两个for循环是关键点*****************/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; max - min + <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        count_arr[i] += count_arr[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 计数排序，i从0开始还是size - 1开始无所谓，基数排序必须跟</span></span><br><span class=\"line\"><span class=\"comment\">    上一步中的个数累加顺序有关 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = size - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sorted_arr[--count_arr[arr[i] - min]] = arr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// for (i = 0; i &lt; size; ++i)</span></span><br><span class=\"line\">    <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     sorted_arr[--count_arr[arr[i] - min]] = arr[i];</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">/*******************************************************/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d, &quot;</span>, sorted_arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(arr, sorted_arr, size * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(count_arr);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(sorted_arr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>采用分治法（Divide and Conquer）的一个非常典型的应用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">merge</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span>* tmp_nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> star_r, <span class=\"type\">int</span> right)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, k;</span><br><span class=\"line\">    k = left;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = left, j = star_r; i &lt;= star_r - <span class=\"number\">1</span> &amp;&amp; j &lt;= right;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &lt;= nums[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tmp_nums[k] = nums[i];</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tmp_nums[k] = nums[j];</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            ++k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; j &lt;= right; ++j, ++k)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp_nums[k] = nums[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt;= star_r; ++i, ++k)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp_nums[k] = nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = right - left + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; ++i, ++left)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        nums[left] = tmp_nums[left];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">m_sort</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span>* tmp_nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        m_sort(nums, tmp_nums, left, center);</span><br><span class=\"line\">        m_sort(nums, tmp_nums, center + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        merge(nums, tmp_nums, left, center + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">merge_sort</span><span class=\"params\">(<span class=\"type\">int</span> *nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>* tmp_nums = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(size * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tmp_nums)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_sort(nums, tmp_nums, <span class=\"number\">0</span>, size - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(tmp_nums);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>* a, <span class=\"type\">int</span>* b)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != b)&#123;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">        *b = *a ^ *b;</span><br><span class=\"line\">        *a = *a ^ *b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Range</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> start;</span><br><span class=\"line\">    <span class=\"type\">int</span> end;</span><br><span class=\"line\">&#125; Range;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 非递归的方式,在一次循环中，将可能的边界压栈 */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">quick_sort1</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Range range[size];</span><br><span class=\"line\">    <span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">    range[p].start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    range[p].end = size - <span class=\"number\">1</span>;</span><br><span class=\"line\">    ++p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; p;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Range r = range[--p];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.start &gt;= r.end)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 去中间位置的数为枢纽数 */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> pivot = nums[(r.start + r.end) / <span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> i = r.start;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = r.end;</span><br><span class=\"line\">        <span class=\"comment\">/* 注意这里是小于等于 */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; i &lt;= j;)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; nums[i] &lt; pivot;)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; nums[j] &gt; pivot;)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                --j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/* 注意这里是小于等于 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt;= j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                swap(&amp;nums[i], &amp;nums[j]);</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">                --j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.start &lt; j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            range[p].start = r.start;</span><br><span class=\"line\">            range[p].end = j;</span><br><span class=\"line\">            ++p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; r.end)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            range[p].start = i;</span><br><span class=\"line\">            range[p].end = r.end;</span><br><span class=\"line\">            ++p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">q_sort</span><span class=\"params\">(<span class=\"type\">int</span>* nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pivot = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = left;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = right;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;i &lt;= j;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;nums[i] &lt; nums[pivot];)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; nums[j] &gt; nums[pivot];)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            --j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            swap(&amp;nums[i], &amp;nums[j]);</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            --j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        q_sort(nums, left, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right &gt; i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        q_sort(nums, i, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 递归方式 */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">quick_sort</span><span class=\"params\">(<span class=\"type\">int</span> *nums, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    q_sort(nums, <span class=\"number\">0</span>, size - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h2><p>桶排序，是计数排序的升级版</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUCKET_SIZE (5) <span class=\"comment\">/**&lt; 假定均匀分布的情况下平均每个桶放几个元素*/</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> elem;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>* <span class=\"title\">list_next</span>;</span></span><br><span class=\"line\">&#125; Node;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BucketManager</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nums;</span><br><span class=\"line\">    Node** buckets;  </span><br><span class=\"line\">&#125; BucketManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BucketSpaceManager</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> index;</span><br><span class=\"line\">    Node* nodes_space;</span><br><span class=\"line\">&#125; BucketSpaceManager;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">BucketSpaceManager* <span class=\"title function_\">init_bucket_space</span><span class=\"params\">(<span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BucketSpaceManager* space_mgr = (BucketSpaceManager*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BucketSpaceManager));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!space_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> exit_1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    space_mgr-&gt;index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    space_mgr-&gt;nodes_space = (Node*)<span class=\"built_in\">malloc</span>(size * <span class=\"keyword\">sizeof</span>(Node));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!space_mgr-&gt;nodes_space)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> exit_2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> space_mgr;</span><br><span class=\"line\"></span><br><span class=\"line\">exit_2:</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(space_mgr);</span><br><span class=\"line\">exit_1:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">BucketManager* <span class=\"title function_\">init_buckets</span><span class=\"params\">(<span class=\"type\">int</span> bucket_nums)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BucketManager* bucket_mgr = (BucketManager*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BucketManager));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bucket_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> exit_1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bucket_mgr-&gt;nums = bucket_nums;</span><br><span class=\"line\">    bucket_mgr-&gt;buckets = (Node**)<span class=\"built_in\">calloc</span>(bucket_mgr-&gt;nums, <span class=\"keyword\">sizeof</span>(Node*));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bucket_mgr-&gt;buckets)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> exit_2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bucket_mgr;</span><br><span class=\"line\">exit_2:</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(bucket_mgr);</span><br><span class=\"line\">exit_1:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Node* <span class=\"title function_\">get_bucket_space</span><span class=\"params\">(BucketSpaceManager* space_mgr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (space_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &amp;space_mgr-&gt;nodes_space[space_mgr-&gt;index++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">release_bucket_space</span><span class=\"params\">(BucketSpaceManager* space_mgr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (space_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (space_mgr-&gt;nodes_space)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(space_mgr-&gt;nodes_space);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(space_mgr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">release_buckets</span><span class=\"params\">(BucketManager* buckets_mgr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buckets_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buckets_mgr-&gt;buckets)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(buckets_mgr-&gt;buckets);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(buckets_mgr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">find_max_min</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> size, <span class=\"type\">int</span>* p_max, <span class=\"type\">int</span>* p_min)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *p_max = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    *p_min = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &gt; *p_max)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            *p_max = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; *p_min)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            *p_min = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">insert_bucket</span><span class=\"params\">(BucketManager* bucket_mgr, <span class=\"type\">int</span> index, Node* new_node)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Node* cur, *pre;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bucket_mgr-&gt;buckets[index])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bucket_mgr-&gt;buckets[index] = new_node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/** 桶内使用插入排序 */</span></span><br><span class=\"line\">        cur = bucket_mgr-&gt;buckets[index];</span><br><span class=\"line\">        pre = cur;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur-&gt;list_next &amp;&amp; new_node-&gt;elem &gt; cur-&gt;elem)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = cur-&gt;list_next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (new_node-&gt;elem &lt;= cur-&gt;elem)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre == cur)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                new_node-&gt;list_next = cur;</span><br><span class=\"line\">                bucket_mgr-&gt;buckets[index] = new_node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                new_node-&gt;list_next = cur;</span><br><span class=\"line\">                pre-&gt;list_next = new_node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cur-&gt;list_next = new_node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">bucket_sort</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> max, min;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = find_max_min(arr, size, &amp;max, &amp;min);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    BucketSpaceManager* space_mgr = init_bucket_space(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!space_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> exit_1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> bucket_nums = (max - min) / BUCKET_SIZE + <span class=\"number\">1</span>;</span><br><span class=\"line\">    BucketManager* bucket_mgr = init_buckets(bucket_nums);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bucket_mgr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> exit_2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> index = (arr[i] - min) / BUCKET_SIZE;</span><br><span class=\"line\">        Node* new_node = get_bucket_space(space_mgr);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!new_node)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> exit_3;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        new_node-&gt;elem = arr[i];</span><br><span class=\"line\">        new_node-&gt;list_next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        insert_bucket(bucket_mgr, index, new_node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; bucket_mgr-&gt;nums; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Node* node = bucket_mgr-&gt;buckets[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(node)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, node-&gt;elem);</span><br><span class=\"line\">            node = node-&gt;list_next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">exit_3:</span><br><span class=\"line\">    release_buckets(bucket_mgr);</span><br><span class=\"line\">exit_2:</span><br><span class=\"line\">    release_bucket_space(space_mgr);</span><br><span class=\"line\">exit_1:</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h2><p>基数排序是一种非比较型整数排序算法，<br>其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。<br>由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 待排序数的进制 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BASE (10)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">find_max</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> max = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (max &lt; arr[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            max = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">radix_sort</span><span class=\"params\">(<span class=\"type\">int</span>* arr, <span class=\"type\">int</span> size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>* backup = arr;</span><br><span class=\"line\">    <span class=\"type\">int</span>* snd_arr = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(size * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> bucket[BASE] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">int</span> max = find_max(arr, size);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">exp</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (max / <span class=\"built_in\">exp</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++bucket[(arr[i] / <span class=\"built_in\">exp</span>) % BASE];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; size; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            bucket[i] += bucket[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 计数排序，i从0开始还是size - 1开始无所谓，基数排序必须跟</span></span><br><span class=\"line\"><span class=\"comment\">        上一步中的个数累加顺序有关 */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = size - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            snd_arr[--bucket[(arr[i] / <span class=\"built_in\">exp</span>) % BASE]] = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 交换两个指针，这样就不用复制了，来回倒腾 */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> * tmp;</span><br><span class=\"line\">        tmp = arr;</span><br><span class=\"line\">        arr = snd_arr;</span><br><span class=\"line\">        snd_arr = tmp;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(bucket, <span class=\"number\">0</span> , BASE * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">        <span class=\"built_in\">exp</span> *= BASE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (backup != arr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(arr, snd_arr, size * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(snd_arr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["数据结构与算法"]}]