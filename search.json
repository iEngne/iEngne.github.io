[{"title":"github fork 项目同步上游","url":"/2022/01/13/fork-merge/","content":"<p>虽然github已经在网页上增加了<strong>fetch upstream</strong>功能，但如果有冲突，只能手动merge.<br>以下记录一次手动合并的过程：</p>\n<span id=\"more\"></span>\n<hr>\n<ul>\n<li>clone 自己fork的仓库<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-16:47:17-&gt;&gt;~/workspace<span class=\"comment\"># git clone git@github.com:iEngne/now-subconverter.git</span></span><br><span class=\"line\">Cloning into <span class=\"string\">&#x27;now-subconverter&#x27;</span>...</span><br><span class=\"line\">remote: Enumerating objects: 1514, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Counting objects: 100% (121/121), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Compressing objects: 100% (110/110), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Total 1514 (delta 24), reused 57 (delta 5), pack-reused 1393</span><br><span class=\"line\">Receiving objects: 100% (1514/1514), 46.51 MiB | 991.00 KiB/s, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Resolving deltas: 100% (636/636), <span class=\"keyword\">done</span>.</span><br></pre></td></tr></table></figure></li>\n<li>确认当前分支是否是要合并的分支，<code>git brakch -a</code>，如果不是切换到相应的分支。<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:11:23-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git branch  -a</span></span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/HEAD -&gt; origin/master</span><br></pre></td></tr></table></figure></li>\n<li>设置<strong>upstream</strong>.<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-16:48:43-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git remote add upstream https://github.com/zhongfly/now-subconverter.git</span></span><br><span class=\"line\">♥root-16:51:15-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git remote -v</span></span><br><span class=\"line\">origin  git@github.com:iEngne/now-subconverter.git (fetch)</span><br><span class=\"line\">origin  git@github.com:iEngne/now-subconverter.git (push)</span><br><span class=\"line\">upstream        https://github.com/zhongfly/now-subconverter.git (fetch)</span><br><span class=\"line\">upstream        https://github.com/zhongfly/now-subconverter.git (push)</span><br></pre></td></tr></table></figure></li>\n<li>从远程取出<strong>upstream</strong><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-16:51:20-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git fetch upstream</span></span><br><span class=\"line\">remote: Enumerating objects: 32, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Counting objects: 100% (32/32), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Compressing objects: 100% (20/20), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">remote: Total 26 (delta 15), reused 17 (delta 6), pack-reused 0</span><br><span class=\"line\">Unpacking objects: 100% (26/26), <span class=\"keyword\">done</span>.</span><br><span class=\"line\">From https://github.com/zhongfly/now-subconverter</span><br><span class=\"line\"> * [new branch]      master     -&gt; upstream/master</span><br></pre></td></tr></table></figure></li>\n<li>查看下分支情况，<code>git branch -a</code><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:29:13-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git branch  -a</span></span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/HEAD -&gt; origin/master</span><br><span class=\"line\">  remotes/origin/master</span><br><span class=\"line\">  remotes/upstream/master</span><br></pre></td></tr></table></figure></li>\n<li>执行合并<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:31:27-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git merge upstream/master</span></span><br><span class=\"line\">warning: Cannot merge binary files: subconverter/subconverter.exe (HEAD vs. upstream/master)</span><br><span class=\"line\">Auto-merging subconverter/subconverter.exe</span><br><span class=\"line\">CONFLICT (content): Merge conflict <span class=\"keyword\">in</span> subconverter/subconverter.exe</span><br><span class=\"line\">Auto-merging subconverter/snippets/emoji.toml</span><br><span class=\"line\">CONFLICT (add/add): Merge conflict <span class=\"keyword\">in</span> subconverter/snippets/emoji.toml</span><br><span class=\"line\">Auto-merging subconverter/pref.example.toml</span><br><span class=\"line\">CONFLICT (add/add): Merge conflict <span class=\"keyword\">in</span> subconverter/pref.example.toml</span><br><span class=\"line\">Automatic merge failed; fix conflicts and <span class=\"keyword\">then</span> commit the result.</span><br></pre></td></tr></table></figure></li>\n<li>查看冲突<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">♥root-17:31:44-&gt;&gt;~/workspace/now-subconverter<span class=\"comment\"># git status</span></span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># You have unmerged paths.</span></span><br><span class=\"line\"><span class=\"comment\">#   (fix conflicts and run &quot;git commit&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Unmerged paths:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#       both added:         subconverter/pref.example.toml</span></span><br><span class=\"line\"><span class=\"comment\">#       both added:         subconverter/snippets/emoji.toml</span></span><br><span class=\"line\"><span class=\"comment\">#       both modified:      subconverter/subconverter.exe</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">no changes added to commit (use <span class=\"string\">&quot;git add&quot;</span> and/or <span class=\"string\">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n<li>直接从GUI界面打开文件修改冲突，或者使用<code>git mergetool</code>命令从命令行打开merge工具，如果有装VIM默认调用vimdiff.  </li>\n<li>修改后<strong>commit</strong>和<strong>push</strong>就OK.</li>\n</ul>\n","categories":["开发日常"],"tags":["github"]},{"title":"vscode ssh 远程登录天坑,使用密钥后仍需要输入密码","url":"/2022/01/12/vscode-ssh/","content":"<p><strong>问题</strong>：使用ssh-keygen生成了密钥对后，把公钥直接重命名成<code>authorized_keys</code>拷贝到服务器<code>~/.ssh</code>目录，发现vscode ssh登录还是提示需要输入密码，还以为密钥对搞错了，反复重试都一样，这就费解了。</p>\n<span id=\"more\"></span>\n<hr>\n<p><strong>解决</strong>  </p>\n<blockquote>\n<p>Make sure the permissions on the <code>~/.ssh</code> directory and its contents are proper. When I first set up my ssh key auth, I didn’t have the <code>~/.ssh</code> folder properly set up, and it yelled at me.</p>\n<ul>\n<li>Your home directory <code>~</code>, your <code>~/.ssh</code> directory and the <code>~/.ssh/authorized_keys</code> file on the remote machine must be writable only by you: <code>rwx------</code> and <code>rwxr-xr-x</code> are fine, but <code>rwxrwx---</code> is no good¹, even if you are the only user in your group (if you prefer numeric modes: <code>700</code> or <code>755</code>, not <code>775</code>).<br>If <code>~/.ssh</code> or <code>authorized_keys</code> is a symbolic link, <a href=\"https://unix.stackexchange.com/questions/152417/why-cant-i-use-public-private-key-authentication-with-ssh-on-arch-linux\">the canonical path (with symbolic links expanded) is checked.</a></li>\n<li>Your <code>~/.ssh/authorized_keys</code> file (on the remote machine) must be readable (at least <code>400</code>), but you’ll need it to be also writable (<code>600</code>) if you will add any more keys to it.</li>\n<li>Your private key file (on the local machine) must be readable and writable only by you: <code>rw-------</code>, i.e. <code>600</code>.  </li>\n<li>Also, if SELinux is set to enforcing, you may need to run <code>restorecon -R -v ~/.ssh</code> (see e.g. <a href=\"https://bugs.launchpad.net/ubuntu/+source/openssh/+bug/965663\">Ubuntu bug 965663</a> and <a href=\"https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=658675\">Debian bug report #658675</a>; this is <a href=\"https://wiki.centos.org/Manuals/ReleaseNotes/CentOS6.2#head-652041430eedc0752937ec8252c52132e574fd2a\">patched in CentOS 6).</a></li>\n</ul>\n<p>¹ Except on some distributions (Debian and derivatives) which have patched the code to allow group writability if you are the only user in your group.  </p>\n</blockquote>\n<p><strong>原文链接</strong>:<a href=\"https://unix.stackexchange.com/questions/36540/why-am-i-still-getting-a-password-prompt-with-ssh-with-public-key-authentication\">https://unix.stackexchange.com/questions/36540/why-am-i-still-getting-a-password-prompt-with-ssh-with-public-key-authentication</a>  </p>\n<p><strong>意思就是</strong>，一般情况下要求 <code>authorized_keys</code> 文件最好设置为只有所有者有读权限或者读写权限(400或者600)，其他情况可能导致不能访问。某些打了补丁的系统也允许当属组成员只有你一个时，<code>authorized_keys</code>设置属组写权限，也允许ssh登录。  </p>\n<p>果然我服务器<code>authorized_keys</code>权限是<code>-rwxr--r--</code>(<code>744</code>).我是通过samba把服务器目录共享到Windows的，拷贝过去默认变成了<code>-rwxr--r--</code>  </p>\n<p>所以一句  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 600 authorized_keys</span><br></pre></td></tr></table></figure>\n<p>解决</p>\n","categories":["开发日常"],"tags":["linux","vscode"]},{"title":"c-complex-declaration","url":"/2022/04/28/c-complex-declaration/","content":"<h1 id=\"C语言中复杂类型的声明\"><a href=\"#C语言中复杂类型的声明\" class=\"headerlink\" title=\"C语言中复杂类型的声明\"></a>C语言中复杂类型的声明</h1><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 复习关于C语言复杂类型的声明定义</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * c语言语法中，[]、()的优先级最高，[]、()写在标识符的右侧，*号和基本类型，如int,char,struct等</span></span><br><span class=\"line\"><span class=\"comment\">     * 写在标识符左侧,对声明定义的解析是右左原则。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指针p指向一个有20个char类型元素的数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">char</span> (*p)[<span class=\"number\">20</span>];</span><br><span class=\"line\">    p=(<span class=\"type\">char</span>(*)[<span class=\"number\">20</span>])<span class=\"built_in\">malloc</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> (*p_a)[<span class=\"number\">20</span>] = &amp;a;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 二级指针就多加个*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (**pp_a)[<span class=\"number\">20</span>] = &amp;p_a;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"title function_\">int</span><span class=\"params\">(*p_array)</span>[];</span><br><span class=\"line\">    p_array * p_c = &amp;p_a;<span class=\"comment\">// 跟int (**pp_a)[20] = &amp;p_a;等效</span></span><br><span class=\"line\">    p_array** p_d = &amp;p_c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> *b[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> *(*p_b)[<span class=\"number\">20</span>] = &amp;b;</span><br><span class=\"line\">    <span class=\"type\">int</span> *(**p_e)[<span class=\"number\">20</span>] = &amp;p_b;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*************************************/</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个数组，数组有20个元素，每个元素是指向int类型的二级指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>** f[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个指针，该指针指向一个数组，该数组有20个元素，每个元素是指向int类型的二级指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span>** (*p_f)[<span class=\"number\">20</span>] = &amp;f;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个20个元素的数组g，该数组的每个元素是一个指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该指针指向一个有10个元素的数组,该数组的元素是指向char*</span></span><br><span class=\"line\"><span class=\"comment\">     * 类型的指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">char</span> *(*g[<span class=\"number\">20</span>])[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个20个元素的数组，数组的每一个元素是一个指针，该指针是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该函数指针指向的函数，入参为int,返回值是int</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*h[<span class=\"number\">20</span>])(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个函数指针func，指向的函数没有入参，返回值是一个指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该指针指向一个二维数组，该二维数组的每一元素是一个int* 指针</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *(*(*func)(<span class=\"type\">void</span>))[][<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个函数指针func_a，指向的函数入参是int,返回值是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该函数指针指向的函数入参是int,返回值是int*</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.首先是个指针,所以在左侧加*号，得到*func_a</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.变成函数指针，入参是int，得到(*func_a)(int)</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.返回值是函数指针，那么把2的结果作为一个整体看待，看作是标识符,</span></span><br><span class=\"line\"><span class=\"comment\">     *   再在左侧加*号，后边加(int),得到(*(*func_)(int))(int)</span></span><br><span class=\"line\"><span class=\"comment\">     * 4.返回值的函数指针指向的函数返回值是int*，所以再在左边加上int*，</span></span><br><span class=\"line\"><span class=\"comment\">     * 最后得到 int *(*(*func_a)(int))(int)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *(*(*func_a)(<span class=\"type\">int</span>))(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个数组指针pg，该指针指向一个20个元素的数组，该数组的元素是</span></span><br><span class=\"line\"><span class=\"comment\">     * 函数指针，该函数指针指向的函数，入参是int,返回值是int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">     <span class=\"type\">int</span> (*(*pg)[<span class=\"number\">20</span>])(<span class=\"type\">int</span>);</span><br><span class=\"line\">     pg = &amp;h;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个函数指针func_b，指向的函数入参是int，返回值是一个指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该指针指向一个20个元素的数组，该数组的元素是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">     * 该函数指针指向的函数，入参是int,返回值是int.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">     <span class=\"type\">int</span> (*(*(*func_b)(<span class=\"type\">int</span> b))[<span class=\"number\">20</span>])(<span class=\"type\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 定义一个数组指针ph,指向一个有20个元素的数组，该数组的元素是函数指针，</span></span><br><span class=\"line\"><span class=\"comment\">      * 该指针指向一个函数，该函数的入参是int,返回值是指针，该指针指向一个10</span></span><br><span class=\"line\"><span class=\"comment\">      * 个元素的数组，该元素char *</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"type\">char</span>* (*(*(*ph)[<span class=\"number\">20</span>])(<span class=\"type\">int</span>))[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 定义一个函数指针func_d，入参是int,返回值是函数指针，该函数指针指向的函数</span></span><br><span class=\"line\"><span class=\"comment\">      * 入参是short, 返回值是一个指向包含15个char*类型的数组的指针</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">      <span class=\"type\">char</span> *(*(*(*func_d)(<span class=\"type\">int</span>))(<span class=\"type\">short</span>))[<span class=\"number\">15</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["开发日常"],"tags":["C语言"]}]