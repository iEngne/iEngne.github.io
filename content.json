{"meta":{"title":"孑影","subtitle":"","description":"记录那些瞎折腾","author":"iEngne","url":"https://iengne.vercel.app","root":"/"},"pages":[{"title":"about","date":"2022-01-12T08:26:57.000Z","updated":"2022-06-10T04:03:01.528Z","comments":true,"path":"about/index.html","permalink":"https://iengne.vercel.app/about/index.html","excerpt":"","text":"一个总是在瞎折腾家伙github: https://github.com/iEngne"},{"title":"archives","date":"2022-01-12T08:26:42.000Z","updated":"2022-03-24T07:14:02.336Z","comments":true,"path":"archives/index.html","permalink":"https://iengne.vercel.app/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-01-12T07:38:01.000Z","updated":"2022-06-09T02:43:14.196Z","comments":true,"path":"categories/index.html","permalink":"https://iengne.vercel.app/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-12T07:38:14.000Z","updated":"2022-06-09T02:43:33.136Z","comments":true,"path":"tags/index.html","permalink":"https://iengne.vercel.app/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"字节序中的位序","slug":"bit_order","date":"2022-06-09T07:06:35.000Z","updated":"2022-06-10T04:01:10.948Z","comments":true,"path":"2022/06/09/bit_order/","link":"","permalink":"https://iengne.vercel.app/2022/06/09/bit_order/","excerpt":"开篇关于字节序很多书都有讲到，去网上搜字节序或者大端序、小端序，有很多介绍的文章，但是这些文章基本只讲到大端序或者小端序中字节层面数据是如何存储的，没有讲到位序是如何的。之前也没想过位序的问题，直到前段时间看到linux kernel中linux&#x2F;tcp.h的定义：","text":"开篇关于字节序很多书都有讲到，去网上搜字节序或者大端序、小端序，有很多介绍的文章，但是这些文章基本只讲到大端序或者小端序中字节层面数据是如何存储的，没有讲到位序是如何的。之前也没想过位序的问题，直到前段时间看到linux kernel中linux&#x2F;tcp.h的定义： 1234567891011121314151617181920212223242526272829303132333435struct tcphdr &#123; __u16 source; __u16 dest; __u32 seq; __u32 ack_seq;#if defined(__LITTLE_ENDIAN_BITFIELD) __u16 res1:4, doff:4, fin:1, syn:1, rst:1, psh:1, ack:1, urg:1, ece:1, cwr:1;#elif defined(__BIG_ENDIAN_BITFIELD) __u16 doff:4, res1:4, cwr:1, ece:1, urg:1, ack:1, psh:1, rst:1, syn:1, fin:1;#else#error &quot;Adjust your &lt;asm/byteorder.h&gt; defines&quot;#endif __u16 window; __u16 check; __u16 urg_ptr;&#125;; 可以看到头文件使用两个宏(__LITTLE_ENDIAN_BITFIELD和__BIG_ENDIAN_BITFIELD)。我们知道tcp头的结构如下：中文版：对比图片和上面定义的头文件可以看出，针对大端和小端系统，进行了不同的定义，说明在不同字节序中位序也是不同的。具体可以看这两篇参考： https://www.fileformat.info/mirror/egff/ch06_04.htmhttps://www.linuxjournal.com/article/6788https://en.wikipedia.org/wiki/Endianness 结论大端系统中的位序也是&quot;大端&quot;，小端系统中的位序也是&quot;小端&quot;。即对于0x0a0b0c0d这个四字节的整数，在内存中是如下存储的：大端： 123456789+-------------------------------------------------------+ | 低地址 ----&gt; 高地址 | |-------------------------------------------------------|| 0 | 1 | 2 | 3 | |-------------------------------------------------------||bit0 --&gt; bit7|bit0 --&gt; bit7|bit0 --&gt; bit7|bit0 --&gt; bit7| |-------------------------------------------------------|| 00001010 | 00001011 | 00001100 | 00001101 | +-------------------------------------------------------+ 小端： 123456789+-------------------------------------------------------+ | 低地址 ----&gt; 高地址 | |-------------------------------------------------------|| 0 | 1 | 2 | 3 | |-------------------------------------------------------||bit0 --&gt; bit7|bit0 --&gt; bit7|bit0 --&gt; bit7|bit0 --&gt; bit7| |-------------------------------------------------------|| 10110000 | 00110000 | 11010000 | 01010000 | +-------------------------------------------------------+ 验证大端系统中的位序我们现在接触到的大部分系统是小端系统，小端系统很好验证，大端系统就比较麻烦，为了验证大端系统，得通过qemu装大端的虚拟机来验证。参考： https://stackoverflow.com/questions/2839087/how-to-test-your-code-on-a-machine-with-big-endian-architecturehttps://stackoverflow.com/questions/3337896/imitate-emulate-a-big-endian-behavior-in-c 0x00. 安装qemu去https://www.qemu.org/download/#windows 这个页面下载windows下的qemu,并安装，安装完后记得添加环境变量 0x01. 下载模拟mips的debian镜像mips芯片是大端的，所以我们模拟这个芯片去验证。去https://people.debian.org/~aurel32/qemu/mips/下载vmlinux-3.2.0-4-5kc-malta和debian_wheezy_mips_standard.qcow2根据页面的说明，打开cmd输入 1qemu-system-mips64 -M malta -kernel vmlinux-3.2.0-4-5kc-malta -hda debian_wheezy_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -m 256 来启动虚拟机，这里怕内存不够，加了-m 256的启动参数，测试发现即使使用|-m 512实际使用的内存也只有256M。 0x02. 启动后发现没法联网启动后想安装gcc，发现没法联网，这是第一次使用qemu，联网搞了半天。找到以下解决方法， 在 Windows 上使用 qemu 虚拟机，通过此配置，可以使 qemu 中的虚拟机能连接互联网，并且也可以和 Windows 主机通信。此方式类似于 Vmware 和 VitrualBox 中的桥接网卡。配置方法如下： 在 Windows 主机上安装 TAP 网卡驱动: 可下载 openvpn 客户端软件，只安装其中的 TAP 驱动；在网络连接中，会看到一个新的网卡，属性类似于 TAP-Win32 Adapter…，将其名称修改为 tap0。 将 tap0 虚拟网卡和 Windows 上连接互联网的真实网卡桥接: 选中这两块网卡，右键，桥接。此时，Windows 主机将不能连接互联网，需要在网桥上配置 IP 地址和域名等信息，才能使 Windows 主机连接互联网。 qemu 配置: 在虚拟机启动命令行添加以下参数：–net nic -net tap,ifname&#x3D;tap0；启动虚拟机，并配置虚拟机中的网卡，则虚拟机也可以和 Windows 主机一样，连接互联网和 Windows 主机。 参考：https://my.oschina.net/Czl6BQ6SEmYt/blog/164308我把TAP网卡重命名为my-tap，所以我的启动参数改为： 1qemu-system-mips64 -M malta -kernel vmlinux-3.2.0-4-5kc-malta -hda debian_wheezy_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -m 256 -net nic -net tap,ifname=my-tap 注意，tap和ifname之间只有一个逗号，不要加空格，否则报错 0x03. 换软件源终于能联网了，发现官方源失效了于是找到阿里云的镜像站中wheezy(Debian7.x)的源替换。备份官方源 1root@debian-mips:~# cp /etc/apt/sources.list /etc/apt/sources.list.backup 创建新文件 1root@debian-mips:~# vi /etc/apt/sources.list 写入 12345# deb http://ftp.debian.org/debian wheezy maindeb http://mirrors.aliyun.com/debian-archive/debian/ wheezy main non-free contribdeb http://mirrors.aliyun.com/debian-archive/debian/ wheezy-proposed-updates main non-free contribdeb-src http://mirrors.aliyun.com/debian-archive/debian/ wheezy main non-free contribdeb-src http://mirrors.aliyun.com/debian-archive/debian/ wheezy-proposed-updates main non-free contrib 更新apt缓存，安装gcc 12root@debian-mips:~# apt-get updateroot@debian-mips:~# apt-get install gcc 0x04. 开始验证测试代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct A &#123; unsigned int a:3; unsigned int b:1; unsigned int c:4; unsigned int d:5;&#125;;struct B &#123; unsigned int a:3; unsigned int b:2; unsigned int c:5; unsigned int d:6;&#125;;struct C &#123; int a; int b; int c;&#125;;void foo(int *p)&#123; int a1 = 1; int a2 = 2; printf(&quot;&amp;a1:%p, &amp;a2:%p\\n&quot;, &amp;a1, &amp;a2); return;&#125;int main(void)&#123; int x[]=&#123;0b10101010110010101000101110110011, 0xbbbbbbbb&#125;; int h, i, j; printf(&quot;&amp;h:%p, &amp;i:%p, &amp;j:%p\\n&quot;, &amp;h, &amp;i ,&amp;j); char y[] = &#123;0b11010, 0b11011, 0b11100, 0b11101&#125;; int* p = (int*)y; printf(&quot;*p = %#x\\n&quot;, *p); struct A* m = (struct A*)&amp;x; struct B* n = (struct B*)&amp;x; printf(&quot;m:%p\\n&quot;, m); printf(&quot;n:%p\\n&quot;, n); printf(&quot;m:%#x, %#x,%#x, %#x,%#x\\n&quot;, m-&gt;a,m-&gt;b, m-&gt;c, m-&gt;d); printf(&quot;n:%#x, %#x,%#x, %#x,%#x\\n&quot;, n-&gt;a,n-&gt;b, n-&gt;c, n-&gt;d); struct C c; printf(&quot;&amp;c.a:%p, &amp;c.b:%p, &amp;c.c:%p\\n&quot;, &amp;c.a, &amp;c.b, &amp;c.c); foo(p); int * po1 = (int*)malloc(16); int * po2 = (int*)malloc(16); printf(&quot;po1:%p, po2%p\\n&quot;, po1, po2); free(po1); free(po2); return 0;&#125; 运行结果 12345678910root@debian-mips:~# ./a.out&amp;h:0x7fba3df4, &amp;i:0x7fba3df8, &amp;j:0x7fba3dfc*p = 0x1a1b1c1dm:0x7fba3decn:0x7fba3decm:0x5, 0, 0xa, 0x19,0x77667000n:0x5, 0x1, 0xb, 0xa,0x77667000&amp;c.a:0x7fba3e04, &amp;c.b:0x7fba3e08, &amp;c.c:0x7fba3e0c&amp;a1:0x7fba3da8, &amp;a2:0x7fba3dacpo1:0x81f008, po20x81f020 因为使用位序的结构体成员不能通过&amp;符号取到地址，所以只能再使用一个struct C来验证结构体内的成员地址是怎么分配的，从c.a,c.b,c.c的地址是递增的，说明在大端系统中，结构体内的成员的地址按照书写顺序递增的。m-&gt;a占3bit，数值是0x5 —–&gt; 10101010110010101000101110110011m-&gt;b占1bit，数值是0x0 —–&gt; 10101010110010101000101110110011m-&gt;c占4bit，数值是0xa —–&gt; 10101010110010101000101110110011m-&gt;d占5bit，数值是0x19 —-&gt; 10101010110010101000101110110011从以上可以看出，m中a,b,c,d四个成员变量的地址应该是递增，它们对应的数值在二进制也是依次从高位往低位排。这说明，在内存中，二进制数10101010110010101000101110110011的高位数值在低地址的低bit位。即 在小端系统中的结果： 1234567891011●●●E:\\workspace\\code\\alg_practice\\test*master&gt;$ .\\a.exe&amp;h:000000a1089ffb48, &amp;i:000000a1089ffb44, &amp;j:000000a1089ffb40sizeof(struct A):4m:000000a1089ffb50n:000000a1089ffb50m:0x3, 0, 0xb, 0xbn:0x3, 0x2, 0x1d, 0x22*p:0x1d1c1b1a000000a1089ffb4c, 000000a1089ffb4d, 000000a1089ffb4e, 000000a1089ffb4f&amp;c.a:000000a1089ffb34, &amp;c.b:000000a1089ffb38, &amp;c.c:000000a1089ffb3c&amp;a1:000000a1089ffaec, &amp;a2:000000a1089ffae8po1:000002858a656cd0, po2000002858a656cf0 m-&gt;a占3bit，数值是0x3 —–&gt; 10101010110010101000101110110011m-&gt;b占1bit，数值是0x0 —–&gt; 10101010110010101000101110110011m-&gt;c占4bit，数值是0xb —–&gt; 10101010110010101000101110110011m-&gt;d占5bit，数值是0xb —–&gt; 10101010110010101000101110110011说明小端字节序的位序也是小端的。","categories":[{"name":"开发日常","slug":"开发日常","permalink":"https://iengne.vercel.app/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://iengne.vercel.app/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"win10下挂载阿里云网盘用于同步文件","slug":"aliyun-driver-webdav","date":"2022-05-10T08:24:51.000Z","updated":"2022-05-13T07:22:39.825Z","comments":true,"path":"2022/05/10/aliyun-driver-webdav/","link":"","permalink":"https://iengne.vercel.app/2022/05/10/aliyun-driver-webdav/","excerpt":"收集了一些电子书，大部分是PDF文件，看的时候会直接在PDF文件上划一些重点和标注，这就需要一种能同步修改的方法。显然普通的存储网盘达不到要求，普通网盘要同步只能有点修改就上传，太麻烦。","text":"收集了一些电子书，大部分是PDF文件，看的时候会直接在PDF文件上划一些重点和标注，这就需要一种能同步修改的方法。显然普通的存储网盘达不到要求，普通网盘要同步只能有点修改就上传，太麻烦。 尝试一 git仓库首先想到的是github或者gitlab存储，修改后通过git push保存修改内容。但是书有2个G多，github单个仓库限额1G,gitlab虽然页面写着git push and GitLab project imports are limited to 5 GB per request through Cloudflare.但是实际测试了下，发现还是失败了。况且实际使用时还挺麻烦，还得自己commit，push，最终放弃了。 尝试二 百度网盘、坚果云、和彩云等的同步功能。百度网盘自带有同步盘功能—同步空间。试了下还不错，还有同步记录，但是有流量限制，每个月1G，我这2G的电子书，完成同步需要2个月，太费劲了。包括坚果云也一样，有流量限制，放弃了。和彩云没有流量限制，但是网盘空间只给20G，太少了，万一以后东西多了之后，存不下。 尝试三 阿里云盘本地挂载想起之前给路由器刷OpenWrt的时候，有可以将阿里云盘挂载到路由器的插件，搜了搜，发现有win10下挂载阿里云盘的方法，挂载后在windows资源管理器中有盘符，跟访问本地磁盘一样，类似挂载samba的效果，可以说非常棒了。 一.需要的软件 https://github.com/messense/aliyundrive-webdav https://www.raidrive.com 基本的原理是，aliyundrive-webdav实现了阿里云盘的webdav,然后使用raildirve挂载webdav。 二.获取refresh-token参考：https://github.com/messense/aliyundrive-webdav#%E8%8E%B7%E5%8F%96-refresh_token具体方法： 登录阿里云盘网页版，建议使用chromium内核的浏览器，chrome或者edge。 按F12进调试模式，在控制台中输入JSON.parse(localStorage.token).refresh_token,即可看到refresh-token。 三.下载aliyundrive-webdav.exe前往https://github.com/messense/aliyundrive-webdav/releases下载windows下的可执行文件压缩包，我的是64位win10，所以下载aliyundrive-webdav-v1.3.2.x86_64-pc-windows-msvc.zip，下载后解压得到aliyundrive-webdav.exe。 四.开机启动aliyundrive-webdav.exe 使用bat脚本运行aliyundrive-webdav.exe。新建txt文件，并写入：1234567891011::隐藏cmd窗口,但仍然会闪一下@echo off if &quot;%1&quot; == &quot;h&quot; goto begin mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;%~nx0 h&quot;,0)(window.close)&amp;&amp;exit :begin ::下面是要执行的命令C:\\Users\\Frank\\Downloads\\aliyundrive-webdav-v1.3.2.x86_64-pc-windows-msvc\\aliyundrive-webdav.exe ^--refresh-token xxxxxxxxxxxxxxx ^--port 8080 ^--auth-user admin ^--auth-password admin123 ^ 说明： aliyundrive-webdav.exe的路径根据自己的实际情况修改。 refresh-token就是第一步中获取的值 port端口号不要跟其他服务冲突 auth-user，auth-password的内容可以自定，这两项会在后面的RaiDrive软件中用到。 将txt文件命名为run_aliyun_dirver_webdav.bat，并保存到合适的位置，右键单击创建一个快捷方式。 按住Ctrl + r启动”运行”, 输入shell:startup并回车，会打开windows的开机启动文件夹，将快捷方式放入其中。 双击快捷方式启动aliyundrive-webdav.exe 安装配置RaiDrive 安装不用多说了，去上面的官网下载安装就行。 配置 storage选NAS-&gt;WebDAV 不要勾选&#39;Address&#39;，否则变成https连接了。 地址填”127.0.0.1”本地地址，端口号就是bat脚本中的端口号。 Account就是bat脚本中的auth-user和auth-password。 点击connect 资源管理器出现以下磁盘就表示成功了： 后续 直接从挂载盘打开PDF文件会有点慢，保存文件也会比较慢，复制大文件到挂载的盘速度挺快的，但是小文件速度很慢。 修改文件后保存，会在文件相同目录生成一个隐藏文件夹，应该是同步文件的时候用的，但是没有删除，文件夹名应该是哈希值， 2022.05.12，发现重大bug，保存后部分文件内容被删了，PDF后面的页面都变成空白的了,不知道是aliyundrive-webdav的问题还是raidrive的问题，都不知道该往哪家提issue，算了，这个同步盘的方式放弃了。 PS:不过，WebDAV挂载阿里云盘拿来只读问题还是不错的，比如拿来看阿里云盘里的影视剧。最终还是选择使用百度网盘的同步空间功能，使用这种成品稳定点，虽然只有1G的同步流量，这么多电子我也不会短时间内全部看完，先看到哪本同步哪本吧。","categories":[{"name":"瞎折腾","slug":"瞎折腾","permalink":"https://iengne.vercel.app/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"阿里云盘","slug":"阿里云盘","permalink":"https://iengne.vercel.app/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/"},{"name":"WebDAV","slug":"WebDAV","permalink":"https://iengne.vercel.app/tags/WebDAV/"}]},{"title":"实现一些经典经典排序算法","slug":"sort","date":"2022-05-05T02:25:13.000Z","updated":"2022-06-12T11:08:01.632Z","comments":true,"path":"2022/05/05/sort/","link":"","permalink":"https://iengne.vercel.app/2022/05/05/sort/","excerpt":"冒泡排序、选择排序、插入排序、堆排序、希尔排序、计数排序、归并排序、快速排序、桶排序、基数排序各排序算法的时间复杂度：","text":"冒泡排序、选择排序、插入排序、堆排序、希尔排序、计数排序、归并排序、快速排序、桶排序、基数排序各排序算法的时间复杂度： 图片来源：https://en.wikipedia.org/wiki/Sorting_algorithm 冒泡排序冒泡排序在1956年就已经被研究，不用多说了，经典中的经典了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @file bubble.c * @author your name (you@domain.com) * @brief 冒泡排序 * @version 0.1 * @date 2022-04-15 * * @copyright Copyright (c) 2022 * */#include &quot;stdio.h&quot;void swap(int* x, int* y)&#123; if (x != y) &#123; *x = *x ^ *y; *y = *x ^ *y; *x = *x ^ *y; &#125;&#125;void bubble_sort(int* nums, int size)&#123; int i,j; /* 外层循环控制有边界 */ for (i = size - 1; i &gt;=1; --i) &#123; for (j = 0; j &lt; i; ++j) &#123; if (nums[j] &gt; nums[j + 1]) &#123; swap(&amp;nums[j], &amp;nums[j+1]); &#125; &#125; &#125;&#125;int main(void)&#123; int array[] = &#123;3,4,1,2,5,7,8,6,5,9,10,5&#125;; bubbleSort(array, sizeof(array)/sizeof(int)); int i = 0; for (; i &lt; sizeof(array)/sizeof(int); ++i) &#123; printf(&quot;%d &quot;, array[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 选择排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @file selection.c * @author your name (you@domain.com) * @brief 选择排序 * @version 0.1 * @date 2022-04-15 * * @copyright Copyright (c) 2022 * */#include &quot;stdio.h&quot;/** * 从序列中选择一个最大(或者最小)的，放到对应位置, * 由于从一个序列中选择最大或者最小的方式有多种， * 所以有多种选择排序,堆排序也可以看作时选择排序 */void swap(int* a, int* b)&#123; if (a != b)&#123; *a = *a ^ *b; *b = *a ^ *b; *a = *a ^ *b; &#125;&#125;/** 简单选择排序 */void selectionSort(int* nums, int size)&#123; int i = 0; /* 外层循环控制待排序元素的位置 */ for (; i &lt; size - 1; ++i) &#123; int minIndex = i; int j = 0; for (j = i + 1; j &lt; size; ++j) &#123; if (nums[j] &lt; nums[minIndex])&#123; minIndex = j; &#125; &#125; swap(&amp;nums[minIndex], &amp;nums[i]); &#125;&#125;int main(void)&#123; int array[] = &#123;3,4,1,2,5,7,8,6,5,9,10,5&#125;; selectionSort(array, sizeof(array)/sizeof(int)); int i = 0; for (; i &lt; sizeof(array)/sizeof(int); ++i) &#123; printf(&quot;%d &quot;, array[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 插入排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @file insertionSort.c * @author your name (you@domain.com) * @brief 插入排序 * @version 0.1 * @date 2022-04-15 * * @copyright Copyright (c) 2022 * */#include &quot;stdio.h&quot;void swap(int* a, int* b)&#123; if (a != b)&#123; *a = *a ^ *b; *b = *a ^ *b; *a = *a ^ *b; &#125;&#125;void insertionSort(int* nums, int size)&#123; int i = 1; for (; i &lt; size; ++i) &#123; int key = nums[i]; int j = i - 1; for (; j &gt;= 0 &amp;&amp; key &lt; nums[j]; --j) &#123; nums[j + 1] = nums[j]; &#125; nums[j + 1] = key; &#125;&#125;int main(void)&#123; int array[] = &#123;3,4,1,2,5,7,8,6,5,9,10,5&#125;; insertionSort(array, sizeof(array)/sizeof(int)); int i = 0; for (; i &lt; sizeof(array)/sizeof(int); ++i) &#123; printf(&quot;%d &quot;, array[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 堆排序堆排序使用了二叉堆的特性，在二叉堆中，父节点总是比子节点大或者小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * @file heapSort.c * @author your name (you@domain.com) * @brief 堆排序，也是一种选择排序 * @version 0.1 * @date 2022-04-15 * * @copyright Copyright (c) 2022 * */#include &quot;stdio.h.&quot;void swap(int* a, int* b)&#123; if (a != b)&#123; *a = *a ^ *b; *b = *a ^ *b; *a = *a ^ *b; &#125;&#125;/** * @brief max堆，下滤 * * @param nums * @param start * @param end */void maxPercDown(int* nums, int dad, int end)&#123; int child = 0; int tmp = nums[dad]; for (;dad * 2 + 1 &lt;= end; dad = child) &#123; child = dad * 2 + 1; /* 找到左右子元素中的最大值 */ if (child != end &amp;&amp; nums[child + 1] &gt; nums[child]) &#123; ++child; &#125; if (nums[child] &gt; tmp) &#123; nums[dad] = nums[child]; &#125; else &#123; break; &#125; &#125; nums[dad] = tmp;&#125;void heapSrot(int* nums, int size)&#123; /* 从最后一个父元素开始 */ int dad = size/2 - 1; /* 第一步，将数组转换成max堆 */ for (; dad &gt;= 0; --dad) &#123; maxPercDown(nums, dad, size - 1); &#125; /* 第二步，排序元素 */ for (; size &gt;= 1; --size) &#123; swap(&amp;nums[0], &amp;nums[size - 1]); maxPercDown(nums, 0, size - 2); &#125;&#125;int main(void)&#123; int array[] = &#123;9,10,8,7,1,3,5,4,6,2&#125;; heapSrot(array, sizeof(array)/sizeof(int)); int i = 0; for (; i &lt; sizeof(array)/sizeof(int); ++i) &#123; printf(&quot;%d &quot;, array[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 希尔排序希尔排序，1959 Donard L.Shell提出,也称递减增量排序算法,是优化的插入排序,插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @file shellSort.c * @author your name (you@domain.com) * @brief 希尔排序，也称递减增量排序算法,是优化的插入排序 * 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； * 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； * 1959 Donard L.Shell提出 * @version 0.1 * @date 2022-04-15 * * @copyright Copyright (c) 2022 * */#include &quot;stdio.h&quot;#include &quot;math.h&quot;/** Hibbard提出1，3，7，15...，这样的2^k - 1序列用于增量排序效果 * 比N = N / 2的效果好 * Sedgewick提出1，5，19，41，109...,这样的项或者是9*4^i - 9*2^i + 1 * 或者是4^i - 3*2^i + 1,比上面的Hibbard提出的效果好 */void shellSort(int* nums, int size)&#123; int increment = 0; for (increment = size &gt;&gt; 1; increment &gt; 0; increment &gt;&gt;= 1) &#123; /** 希尔排序的内部就是简单插入排序 */ int i; for (i = increment; i &lt; size; ++i) &#123; int key = nums[i]; int j; for (j = i - increment; j &gt;= 0 &amp;&amp; nums[j] &gt; key; j -= increment) &#123; nums[j + increment] = nums[j]; &#125; nums[j + increment] = key; &#125; &#125;&#125;int main(void)&#123; int array[] = &#123;3,4,1,2,5,7,8,6,5,9,10,5&#125;; shellSort(array, sizeof(array)/sizeof(int)); int i = 0; for (; i &lt; sizeof(array)/sizeof(int); ++i) &#123; printf(&quot;%d &quot;, array[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 计数排序计数排序，是一种非比较排序，作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数，并且数据最好集中在一定的范围内，如果有个数特别大或者特别小，内存浪费会比较大。计数排序的基本思想是，如果我知道比我小的数有几个，那么我也就知道我排第几了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * @file counting_sort.c * @author your name (you@domain.com) * @brief 计数排序，非比较排序，作为一种线性时间复杂度的排序， * 计数排序要求输入的数据必须是有确定范围的整数，并且数据最好集中在一定的范围内， * 如果有个数特别大或者特别小，内存浪费会比较大。 * @version 0.1 * @date 2022-04-19 * * @copyright Copyright (c) 2022 * */#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;int find_max_min(int* arr, int size, int* p_max, int* p_min)&#123; if (size &lt;= 0) &#123; return -1; &#125; *p_max = arr[0]; *p_min = arr[0]; int i; for (i = 1; i &lt; size; ++i) &#123; if (arr[i] &gt; *p_max) &#123; *p_max = arr[i]; &#125; if (arr[i] &lt; *p_min) &#123; *p_min = arr[i]; &#125; &#125; return 0;&#125;void counting_sort(int* arr, int size)&#123; int max, min; int ret = find_max_min(arr, size, &amp;max, &amp;min); if (ret &lt; 0) &#123; printf(&quot;find max or min error\\n&quot;); return; &#125; int* sorted_arr = (int*)malloc(size * sizeof(int)+20); if (!sorted_arr) &#123; printf(&quot;out of memory\\n&quot;); return; &#125; int* count_arr = (int*)calloc(max - min + 1, sizeof(int)); if (!count_arr) &#123; printf(&quot;out of memory\\n&quot;); free(sorted_arr); return; &#125; int i; /* 这一步类似于哈希,将数的有序性转化为数组下标的有序性 */ for (i = 0; i &lt; size; ++i) &#123; ++count_arr[arr[i] - min]; &#125; /****************下面两个for循环是关键点*****************/ for (i = 1; i &lt; max - min + 1; ++i) &#123; count_arr[i] += count_arr[i - 1]; &#125; /* 计数排序，i从0开始还是size - 1开始无所谓，基数排序必须跟 上一步中的个数累加顺序有关 */ for (i = size - 1; i &gt;= 0; --i) &#123; sorted_arr[--count_arr[arr[i] - min]] = arr[i]; &#125; // for (i = 0; i &lt; size; ++i) // &#123; // sorted_arr[--count_arr[arr[i] - min]] = arr[i]; // &#125; /*******************************************************/ for (i = 0; i &lt; size; ++i) &#123; printf(&quot;%d, &quot;, sorted_arr[i]); &#125; memcpy(arr, sorted_arr, size * sizeof(int)); printf(&quot;\\n&quot;); free(count_arr); free(sorted_arr); return;&#125;int main(void)&#123; int array[] = &#123;3,4,1,2,5,7,8,6,5,9,10,5&#125;; counting_sort(array, sizeof(array)/sizeof(int)); int i; for (i = 0; i &lt; sizeof(array)/sizeof(int); ++i) &#123; printf(&quot;%d &quot;, array[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * @file merge_sort.c * @author your name (you@domain.com) * @brief 归并排序 * 采用分治法（Divide and Conquer）的一个非常典型的应用。 * @version 0.1 * @date 2022-04-18 * * @copyright Copyright (c) 2022 * */#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &lt;math.h&gt;/** * 归并排序分为迭代法和递归法 * 迭代法的基本思想是，一开始假设一个元素一组，然后相邻的两组进行比大小合并 * 这样两个短的就变成了一个比原来长的有序分组了，然后再相邻的两两合并 * 示意图如下，假设要求递增排序 * 10 9 8 7 6 5 4 3 2 1 * \\ / \\ / \\ / \\ / \\ / * [9,10] [7,8] [5,6] [3,4] [1,2] * \\ / \\ / * [7,8,9,10] [3,4,5,6] [1,2] * \\ / * [3,4,5,6,7,8,9,10] [1,2] * \\ / * [1,2,3,4,5,6,7,8,9,10] * * 递归法的基本思想是，通过递归调用，不断对数进行二分法分组，直到每个分组都 * 只有一个元素，然后再合并，合并过程类似上述类似。 */void merge(int* nums, int* tmp_nums, int left, int star_r, int right)&#123; int i, j, k; k = left; for (i = left, j = star_r; i &lt;= star_r - 1 &amp;&amp; j &lt;= right;) &#123; if (nums[i] &lt;= nums[j]) &#123; tmp_nums[k] = nums[i]; ++i; ++k; &#125; else &#123; tmp_nums[k] = nums[j]; ++j; ++k; &#125; &#125; for (; j &lt;= right; ++j, ++k) &#123; tmp_nums[k] = nums[j]; &#125; for (; i &lt;= star_r; ++i, ++k) &#123; tmp_nums[k] = nums[i]; &#125; int size = right - left + 1; for (i = 0; i &lt; size; ++i, ++left) &#123; nums[left] = tmp_nums[left]; &#125;&#125;/************************ 迭代法 *****************************/void merge_sort_iter(int* nums, int size)&#123; int* tmp_nums = (int*)malloc(size * sizeof(int)); // step 标识分组的长度，以1，2，4，8...方式增长 int step = 1; int index = 0; // 第一层用于控制步长 for (step = 1; step &lt; size; step &lt;&lt;= 1) &#123; // 第二层用于分组划分,span是合并后的分组大小 int span = step + step; for (index = 0; index &lt; size; index += span) &#123; merge(nums, tmp_nums, index, fmin(index + step, size - 1), fmin(index + span - 1, size - 1)); &#125; &#125; free(tmp_nums); return;&#125;/************************ 递归法 *****************************/void m_sort(int* nums, int* tmp_nums, int left, int right)&#123; if (left &lt; right) &#123; int center = (left + right) / 2; m_sort(nums, tmp_nums, left, center); m_sort(nums, tmp_nums, center + 1, right); merge(nums, tmp_nums, left, center + 1, right); &#125;&#125;void merge_sort(int *nums, int size)&#123; int* tmp_nums = (int*)malloc(size * sizeof(int)); if (!tmp_nums) &#123; printf(&quot;out of memory\\n&quot;); return; &#125; m_sort(nums, tmp_nums, 0, size - 1); free(tmp_nums); return;&#125;int main(void)&#123; int array[] = &#123;3,4,1,2,5,7,8,6,5,9,10,5&#125;; //merge_sort(array, sizeof(array)/sizeof(int)); merge_sort_iter(array, sizeof(array)/sizeof(int)); int i = 0; for (; i &lt; sizeof(array)/sizeof(int); ++i) &#123; printf(&quot;%d &quot;, array[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/** * @file quick_sort.c * @author your name (you@domain.com) * @brief 快速排序 * @version 0.1 * @date 2022-04-18 * * @copyright Copyright (c) 2022 * */#include &quot;stdio.h&quot;void swap(int* a, int* b)&#123; if (a != b)&#123; *a = *a ^ *b; *b = *a ^ *b; *a = *a ^ *b; &#125;&#125;typedef struct Range&#123; int start; int end;&#125; Range;int median3(int* nums, int left, int right)&#123;&#125;/* 非递归的方式,在一次循环中，将可能的边界压栈 */void quick_sort1(int* nums, int size)&#123; if (size &lt;= 1) &#123; return; &#125; Range range[size]; int p = 0; range[p].start = 0; range[p].end = size - 1; ++p; for (; p;) &#123; Range r = range[--p]; if (r.start &gt;= r.end) &#123; continue; &#125; /* 去中间位置的数为枢纽数 */ int pivot = nums[(r.start + r.end) / 2]; int i = r.start; int j = r.end; /* 注意这里是小于等于 */ for (; i &lt;= j;) &#123; for (; nums[i] &lt; pivot;) &#123; ++i; &#125; for (; nums[j] &gt; pivot;) &#123; --j; &#125; /* 注意这里是小于等于 */ if (i &lt;= j) &#123; swap(&amp;nums[i], &amp;nums[j]); ++i; --j; &#125; &#125; if (r.start &lt; j) &#123; range[p].start = r.start; range[p].end = j; ++p; &#125; if (i &lt; r.end) &#123; range[p].start = i; range[p].end = r.end; ++p; &#125; &#125;&#125;void q_sort(int* nums, int left, int right)&#123; int pivot = (left + right) / 2; int i = left; int j = right; for (;i &lt;= j;) &#123; for (;nums[i] &lt; nums[pivot];) &#123; ++i; &#125; for (; nums[j] &gt; nums[pivot];) &#123; --j; &#125; if (i &lt;= j) &#123; swap(&amp;nums[i], &amp;nums[j]); ++i; --j; &#125; &#125; if (left &lt; j) &#123; q_sort(nums, left, j); &#125; if (right &gt; i) &#123; q_sort(nums, i, right); &#125;&#125;/* 递归方式 */void quick_sort(int *nums, int size)&#123; q_sort(nums, 0, size - 1); return;&#125;int main(void)&#123; int array[] = &#123;3,4,1,2,5,7,8,6,5,9,10,5&#125;; quick_sort(array, sizeof(array)/sizeof(int)); int i = 0; for (; i &lt; sizeof(array)/sizeof(int); ++i) &#123; printf(&quot;%d &quot;, array[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 桶排序桶排序，是计数排序的升级版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253/** * @file bucket_sort.c * @author your name (you@domain.com) * @brief 桶排序，是计数排序的升级版， * @version 0.1 * @date 2022-04-19 * * @copyright Copyright (c) 2022 * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define BUCKET_SIZE (5) /**&lt; 假定均匀分布的情况下平均每个桶放几个元素*/typedef struct Node&#123; int elem; struct Node* list_next;&#125; Node;typedef struct BucketManager&#123; int nums; Node** buckets; &#125; BucketManager;typedef struct BucketSpaceManager&#123; int index; Node* nodes_space;&#125; BucketSpaceManager;BucketSpaceManager* init_bucket_space(int size)&#123; BucketSpaceManager* space_mgr = (BucketSpaceManager*)malloc(sizeof(BucketSpaceManager)); if (!space_mgr) &#123; printf(&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;, __FILE__, __func__, __LINE__); goto exit_1; &#125; space_mgr-&gt;index = 0; space_mgr-&gt;nodes_space = (Node*)malloc(size * sizeof(Node)); if (!space_mgr-&gt;nodes_space) &#123; printf(&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;, __FILE__, __func__, __LINE__); goto exit_2; &#125; return space_mgr;exit_2: free(space_mgr);exit_1: return NULL;&#125;BucketManager* init_buckets(int bucket_nums)&#123; BucketManager* bucket_mgr = (BucketManager*)malloc(sizeof(BucketManager)); if (!bucket_mgr) &#123; printf(&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;, __FILE__, __func__, __LINE__); goto exit_1; &#125; bucket_mgr-&gt;nums = bucket_nums; bucket_mgr-&gt;buckets = (Node**)calloc(bucket_mgr-&gt;nums, sizeof(Node*)); if (!bucket_mgr-&gt;buckets) &#123; printf(&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;, __FILE__, __func__, __LINE__); goto exit_2; &#125; return bucket_mgr;exit_2: free(bucket_mgr);exit_1: return NULL;&#125;Node* get_bucket_space(BucketSpaceManager* space_mgr)&#123; if (space_mgr) &#123; return &amp;space_mgr-&gt;nodes_space[space_mgr-&gt;index++]; &#125; else &#123; return NULL; &#125;&#125;void release_bucket_space(BucketSpaceManager* space_mgr)&#123; if (space_mgr) &#123; if (space_mgr-&gt;nodes_space) &#123; free(space_mgr-&gt;nodes_space); &#125; free(space_mgr); &#125;&#125;void release_buckets(BucketManager* buckets_mgr)&#123; if (buckets_mgr) &#123; if (buckets_mgr-&gt;buckets) &#123; free(buckets_mgr-&gt;buckets); &#125; free(buckets_mgr); &#125;&#125;int find_max_min(int* arr, int size, int* p_max, int* p_min)&#123; if (size &lt;= 0) &#123; return -1; &#125; *p_max = arr[0]; *p_min = arr[0]; int i; for (i = 1; i &lt; size; ++i) &#123; if (arr[i] &gt; *p_max) &#123; *p_max = arr[i]; &#125; if (arr[i] &lt; *p_min) &#123; *p_min = arr[i]; &#125; &#125; return 0;&#125;int insert_bucket(BucketManager* bucket_mgr, int index, Node* new_node)&#123; Node* cur, *pre; if (!bucket_mgr-&gt;buckets[index]) &#123; bucket_mgr-&gt;buckets[index] = new_node; &#125; else &#123; /** 桶内使用插入排序 */ cur = bucket_mgr-&gt;buckets[index]; pre = cur; while (cur-&gt;list_next &amp;&amp; new_node-&gt;elem &gt; cur-&gt;elem) &#123; pre = cur; cur = cur-&gt;list_next; &#125; if (new_node-&gt;elem &lt;= cur-&gt;elem) &#123; if (pre == cur) &#123; new_node-&gt;list_next = cur; bucket_mgr-&gt;buckets[index] = new_node; &#125; else &#123; new_node-&gt;list_next = cur; pre-&gt;list_next = new_node; &#125; &#125; else &#123; cur-&gt;list_next = new_node; &#125; &#125; return 0;&#125;void bucket_sort(int* arr, int size)&#123; int max, min; int ret = find_max_min(arr, size, &amp;max, &amp;min); if (ret &lt; 0) &#123; return; &#125; BucketSpaceManager* space_mgr = init_bucket_space(size); if (!space_mgr) &#123; printf(&quot;out of memory,File:%s, Func:%s, Line:%d\\n&quot;, __FILE__, __func__, __LINE__); goto exit_1; &#125; int bucket_nums = (max - min) / BUCKET_SIZE + 1; BucketManager* bucket_mgr = init_buckets(bucket_nums); if (!bucket_mgr) &#123; goto exit_2; &#125; int i; for (i = 0; i &lt; size; ++i) &#123; int index = (arr[i] - min) / BUCKET_SIZE; Node* new_node = get_bucket_space(space_mgr); if (!new_node) &#123; goto exit_3; &#125; new_node-&gt;elem = arr[i]; new_node-&gt;list_next = NULL; insert_bucket(bucket_mgr, index, new_node); &#125; for (i = 0; i &lt; bucket_mgr-&gt;nums; ++i) &#123; Node* node = bucket_mgr-&gt;buckets[i]; while(node) &#123; printf(&quot;%d &quot;, node-&gt;elem); node = node-&gt;list_next; &#125; &#125; printf(&quot;\\n&quot;);exit_3: release_buckets(bucket_mgr);exit_2: release_bucket_space(space_mgr);exit_1: return;&#125;int main(void)&#123; int test_nums[] = &#123;237384,348185,338816,825359,461215,315112,170091,173609,724297,828355,395935,687922,127118,795454,166794,888047,274616,667202,772520,845914,142832,575527,980196,584061,784366,68694,80105,618370,915739,787506,379362,601205,44762,969018,625507,738640,900407,43638,477963,233716,613792,751212,231136,467042,514654,521610,369778,843173,257148,760274,234955,265546,891429,750091,942435,882691,485058,792360,435287,372065,396852,330275,801939,200914,455728,109280,527003,303337,793015,667734,279361,37810,783709,960454,33515,263864,624043,788379,449351,538850,706217,238925,353546,816968,654562,564565,948428,739868,861656,857587,418080,653483,909732,952407,927615,35267,732179,232870,933798,61900,147786,777833,294447,441553,819649,999015,523917,507135,9098,588245,831300,993003,945127,295861,806452,771032,921668,596114,58389,569490,199237,885193,713430,997040,349454,18832,365963,558789,793979,254667,902665,558387,193214,22187,589600,12593,959246,288997,790510,739049,415542,64949,504677,744804,344632,973744,984968,641758,44835,276866,533525,98170,362427,158920,761852,350430,378032,170007,937691,243911,35862,531400,478419,649378,146626,88512,280222,670261,941343,38126,514239,239530,502593,525678,583466,591214,539578,787397,941549,774755,828458,408562,867366,117131,114317,466268,629942,971386,113065,796098,875547,527563,539137,993188,177348,731079,452588,788027,482866,183936,891182,14590,796156,74952,512718,988078,316782,432209,405396,909257,659880,642669,784593,862734,581531,297746,379112,965834,757501,134934,262876,151414,341459,68737,335705,108420,175807,49204,418698,817329,683802,860609,970110,562200,491152,474457,82314,164791,579463,324083,114843,523863,305404,361637,631095,644669,990028,661638,98042,785313,92497,393902,493634,54193,786608,157915,907705,900047,733377,104396,800956,611681,900941,905797,918430,595666,611837,661676,485663,356116,62184,22936,101311,174347,176398,692221,924783,332203,23632,778317,433707,631680,847304,963864,713851,549636,191334,907916,47933,193726,839680,126830,969619,628862,971186,734295,940422,873838,710272,209108,23584,415483,344786,442615,533638,869735,327330,64692,223777,613179,926166,278178,42026,695892,190137,520649,212425,591392,953797,870512,920351,832099,272207,808275,724503,127489,522614,56839,59895,102922,200728,277140,756415,619144,202689,448065,169987,854403,718299,290852,184409,866904,468376,434288,683022,468668,521252,630787,910353,142102,776763,402397,997568,460132,591549,560002,140986,393106,315836,299789,11157,948822,736508,906511,359633,102634,758603,805615,991907,260305,566652,360444,640556,683744,490938,70267,974394,483178,140278,963198,607682,209876,545401,940834,353171,46725,959406,354607,105717,363535,16577,802543,148157,857807,853261,1498,894257,545218,888366,440977,760701,96299,194450,556914,761520,613246,137907,808247,716421,37096,466670,750120,55193,913440,8276,447656,578312,259763,531876,512665,141442,939404,522308,727677,66404,306827,611378,640320,463646,23442,814541,819520,700355,999156,299221,300487,694583,925423,942388,200218,951988,223828,625765,806161,775098,668188,354891,941824,874533,790457,17266,587582,782052,543260,761066,33671,282287,36517,641769,385319,788130,444800,151440,760399,156927,810160,399433,20665,789379,245026,869278,79201,525654,154337,153772,520742,409817,351982,632677,27469,461968,67163,598474,413742,162730,398958,301268,188138,454016,685406,65119,424960,818292,500147,531479,320450,31786,847222,17718,573327,675570,627627,134531,278662,882290,91973,715585,416932,141758,330628,608707,961155,644588,685130,558779,690500,576750,57187,662322,665426,878670,398251,851778,73445,291259,667672,879137,421584,252470,981007,959007,53698,133588,258920,681480,73704,369061,257507,783989,955086,78221,878089,393338,909013,941463,497392,775208,464141,885513,194241,576540,994311,430940,463882,476639,97844,412750,31014,834638,766103,636265,574729,830894,789695,824714,226564,302451,431214,698974,268952,909138,568967,526732,990610,420963,887778,652540,435751,931021,543446,232181,236984,751446,608881,804842,538843,329712,355717,782681,473005,767954,470918,742657,728655,365915,904237,846747,6298,705289,457213,288518,679537,486580,99128,173621,770845,958054,602720,628137,857349,902228,143259,788408,349345,704796,603484,480846,169475,888264,7467,101509,944655,550048,233987,97958,211933,262737,696890,306842,268402,823675,462983,500079,337185,779420,235971,618001,852936,348159,585270,253322,133651,275390,815377,859521,719221,37242,211276,151229,636060,782778,520680,520329,485325,259013,617869,511118,52820,606179,457781,861353,410867,169794,503806,854135,485535,34892,964607,585208,638485,609536,731747,715170,318192,802739,356387,170816,357610,891098,977234,976964,264819,525494,418773,26864,134949,843984,324369,726637,41795,512710,401258,835971,73776,630372,381524,305245,549503,725983,342165,317492,850053,764863,120577,43205,843143,996410,732112,282227,857503,197508,483094,483191,404547,689744,533489,54389,816657,900804,547343,766481,89532,836491,571400,361547,453296,487986,777471,581869,517966,657816,205850,484738,437893,369736,329489,129082,995024,910156,562018,690831,772881,471961,68259,868647,162362,698669,706968,803864,200166,791470,779783,656081,432804,101615,903098,603139,243133,63039,723923,706235,176627,421722,156099,251079,570462,387579,135309,254221,900525,401696,545242,649953,265465,478224,210210,870963,11204,906806,593938,308828,839903,344986,552973,868191,423898,841030,31248,201878,908361,938518,702414,927371,187915,582150,250622,853272,378462,750728,841296,646057,86613,903991,884906,370017,62265,971984,411031,64080,252978,73118,398306,312366,58337,774908,11239,137947,738056,492168,116364,24769,96167,192952,142183,517522,978015,944570,354291,42020,729306,258838,402630,687489,965651,456761,261371,7505,994268,758338,292010,750701,193464,514023,303629,973093,998924,693448,114160,989360,30856,262046,625396,142208,76524,64194,932588,28579,606417,300349,605278,223074,298180,775329,468490,652937,990775,698051,584527,259521,53062,300194,522713,38368,473798,940083,295847,514003,243339,886679,558418,48354,266870,101180,725339,414568,438067,74220,606737,674479,136313,758031,941488,506637,146915,500431,56167,876539,911115,819750,526974,136156,809654,819404,994640,114101,610563,365490,210767,558064,868269,621800,943069,84813,577138,794535,644600,760143,357944,229363,240759,31577,178432,281788,921022,888824,619432,71886,313585,988663,434824,385765,135830,842738,370217,578942,354150,32117,347770,436059,109040,955493,608239,501982,465481,519878,96756,397057,209517,402619,619978,231284,399712,160156,531674,41788,899754,535660,334515,908049,679252,825448,396682,349157,921979,17598,811584,849117,415521,968473,119924,241966,956841,819813,256247,926526,8530,456200,933361,282325,705205,553214,906451,944192,889932,164576,516882,859439,52687,111709,778327,369781,474722,264710,537749,420656,227498,913284,444034,86666,71542&#125;; int array[] = &#123;9,1,10,8,7,10,3,5,4,6,10,10,2,10,11,9,4,7,20,22,54&#125;; bucket_sort(array, sizeof(array)/sizeof(int)); // bucket_sort(test_nums, sizeof(test_nums)/sizeof(int)); return 0;&#125; 基数排序基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * @file radix_sort.c * @author your name (you@domain.com) * @brief 基数排序是一种非比较型整数排序算法， * 其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 * 由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 * @version 0.1 * @date 2022-04-20 * * @copyright Copyright (c) 2022 * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/* 待排序数的进制 */#define BASE (10)int find_max(int* arr, int size)&#123; int max = arr[0]; int i; for (i = 1; i &lt; size; ++i) &#123; if (max &lt; arr[i]) &#123; max = arr[i]; &#125; &#125; return max;&#125;void radix_sort(int* arr, int size)&#123; int* backup = arr; int* snd_arr = (int*)malloc(size * sizeof(int)); int bucket[BASE] = &#123;0&#125;; int i; int max = find_max(arr, size); int exp = 1; while (max / exp &gt; 0) &#123; for (i = 0; i &lt; size; ++i) &#123; ++bucket[(arr[i] / exp) % BASE]; &#125; for (i = 1; i &lt; size; ++i) &#123; bucket[i] += bucket[i - 1]; &#125; /* 计数排序，i从0开始还是size - 1开始无所谓，基数排序必须跟 上一步中的个数累加顺序有关 */ for (i = size - 1; i &gt;= 0; --i) &#123; snd_arr[--bucket[(arr[i] / exp) % BASE]] = arr[i]; &#125; /* 交换两个指针，这样就不用复制了，来回倒腾 */ int * tmp; tmp = arr; arr = snd_arr; snd_arr = tmp; memset(bucket, 0 , BASE * sizeof(int)); exp *= BASE; &#125; if (backup != arr) &#123; memcpy(arr, snd_arr, size * sizeof(int)); &#125; free(snd_arr);&#125;int main(void)&#123; int array[] = &#123;3,4,1,2,5,7,8,6,5,9,10,5&#125;; radix_sort(array, sizeof(array)/sizeof(int)); int i = 0; for (; i &lt; sizeof(array)/sizeof(int); ++i) &#123; printf(&quot;%d &quot;, array[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://iengne.vercel.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"二叉堆","slug":"heap","date":"2022-05-05T01:49:14.000Z","updated":"2022-05-05T01:54:14.383Z","comments":true,"path":"2022/05/05/heap/","link":"","permalink":"https://iengne.vercel.app/2022/05/05/heap/","excerpt":"二叉堆（英语：binary heap）是一种特殊的堆，二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足堆特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。当父节点的键值总是大于或等于任何一个子节点的键值时为“最大堆”。当父节点的键值总是小于或等于任何一个子节点的键值时为“最小堆”。—-Wikipedia","text":"二叉堆（英语：binary heap）是一种特殊的堆，二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足堆特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。当父节点的键值总是大于或等于任何一个子节点的键值时为“最大堆”。当父节点的键值总是小于或等于任何一个子节点的键值时为“最小堆”。—-Wikipedia 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/** * @file heap.c * @author your name (you@domain.com) * @brief 二叉堆，二叉堆一般使用使用数组实现，在逻辑结构上又具有二叉树的特征， * 数组下标一般从1开始，这样对于任意的下标为i的非叶子节点，它的左子节点下标是2i,右子节点是2i+1。 * 如果数组下标从0开始，这样对于任意的下标为i的非叶子节点，它的左子节点下标是2i+1,右子节点是2i+2。 * @version 0.1 * @date 2022-04-15 * * @copyright Copyright (c) 2022 * */#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;typedef struct HeapStruct&#123; int capacity; int size; int* heap;&#125; HeapStruct;HeapStruct* initialize(int maxSize)&#123; HeapStruct* h = (HeapStruct*)malloc(sizeof(HeapStruct)); if (!h) &#123; printf(&quot;out of memory\\n&quot;); return NULL; &#125; h-&gt;capacity = maxSize; h-&gt;size = 0; h-&gt;heap = (int*)malloc((maxSize + 1) * sizeof(int)); /**&lt; 加1是因为数组从下标1开始，空间要多一个 */ if (!h-&gt;heap) &#123; printf(&quot;out of memory\\n&quot;); free(h); return NULL; &#125; return h;&#125;void deinitialize(HeapStruct* h)&#123; if (h) &#123; if (h-&gt;heap) &#123; free(h-&gt;heap); &#125; free(h); &#125;&#125;/** * @brief 在堆中插入数据，使用上滤percolate up * * @param h * @param x */void insert(HeapStruct* h, int x)&#123; if (h-&gt;size == h-&gt;capacity) &#123; return; &#125; int i = ++h-&gt;size; for (; (i &gt;&gt; 1) &gt;= 1 &amp;&amp; h-&gt;heap[i &gt;&gt; 1] &gt; x; i &gt;&gt;= 1) &#123; h-&gt;heap[i] = h-&gt;heap[i &gt;&gt; 1]; &#125; h-&gt;heap[i] = x;&#125;/** * @brief 删除最小元素，下滤 * 上滤或者下滤过程类似于插入排序 * @param h * @param x */int deleteMin(HeapStruct* h)&#123; if (h-&gt;size == 0) &#123; printf(&quot;no element\\n&quot;); return 0; &#125; int i; int min = h-&gt;heap[1]; int child; int lastOne = h-&gt;heap[h-&gt;size]; for (i = 1; i * 2 &lt;= h-&gt;size;i = child) &#123; child = i * 2; /* 找到左右child中的最小者 */ if (child &lt; h-&gt;size &amp;&amp; h-&gt;heap[child + 1] &lt; h-&gt;heap[child]) &#123; ++child; &#125; /* 删除的时候，一定会有一个位置空出来， 使用左右子元素和最后一个元素三者间最小的元素去填充 */ if (lastOne &gt; h-&gt;heap[child]) &#123; h-&gt;heap[i] = h-&gt;heap[child]; &#125; else &#123; break; &#125; &#125; h-&gt;heap[i] = lastOne; --h-&gt;size; return min;&#125;int main(void)&#123; int array[] = &#123;3,4,1,2,5,7,8,6,5,9,10,5&#125;; HeapStruct* h = initialize(sizeof(array)/sizeof(int)); int i = 0; for (i = 0; i &lt; sizeof(array)/sizeof(int); ++i) &#123; insert(h, array[i]); &#125; for (i = 0; i &lt; sizeof(array)/sizeof(int); ++i) &#123; printf(&quot;%d,&quot;, h-&gt;heap[i]); &#125; printf(&quot;\\n&quot;); while (h-&gt;size &gt; 0) &#123; printf(&quot;%d &quot;, deleteMin(h)); &#125; printf(&quot;\\n&quot;); deinitialize(h); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://iengne.vercel.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"质数判断和筛质数","slug":"prime-number","date":"2022-04-29T09:03:37.000Z","updated":"2022-05-05T02:00:37.458Z","comments":true,"path":"2022/04/29/prime-number/","link":"","permalink":"https://iengne.vercel.app/2022/04/29/prime-number/","excerpt":"给定一定范围的自然数，找出里面所有的质数主要有2种方式： 遍历每一个数并判断是不是质数，如果是就存起来。 借助一定的算法直接筛选。","text":"给定一定范围的自然数，找出里面所有的质数主要有2种方式： 遍历每一个数并判断是不是质数，如果是就存起来。 借助一定的算法直接筛选。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;stdbool.h&quot;#include &quot;math.h&quot;/******************判断质数**********************//** * @brief 枚举法 * * 版本1：根据质数的定义，对于大于2的自然数n，从2开始到n-1看是否存在能整除n的数， * 如果存在，则是合数，否则为质数 * * 版本2：无需判断从2~n-1的所有数，只需要判断2~n的平方根的数是否能整除就行 * * 版本3：对于所有大于3的质数具有6n+1(n &gt;= 1)或者6n-1的性质 * */// 结合2和3的代码示例，时间复杂度O(sqrt(n))// leetcode中，计算从1到709486有几个质数，耗时28msbool isPrime3(int n)&#123; if (n == 1)&#123; return false; &#125; if (n == 2 || n == 3)&#123; return true; &#125; if (n % 6 != 1 &amp;&amp; n % 6 != 5)&#123; return false; &#125; int i; int j = sqrt(n); for (i = 5; i &lt;= j; i += 6)&#123; // 形如6k+1(k &gt;= 1)或者6k-1的合数，一定可以被6m+1或者6m-1的数所整除 // 因为合数肯定可以因式分解，而所有的质数都形如6m + 1 或者6m - 1(m &gt;=1) if (n % i == 0 || n % (i + 2) == 0)&#123; return false; &#125; &#125; printf(&quot;%d &quot;, n); return true;&#125;/** * @brief 分解质因数-短除法 * 版本1：要从最小的质数除起（依次除于质数2 3 5....)一直到n，时间复杂度为O(n) * * 版本2：n中最多只含有一个大于sqrt(n)的质因子。 * 证明：通过反证法：如果有两个大于sqrt(n)的因子，那么相乘会大于n，矛盾。证毕 * 于是我们发现最多只有一个大于sqrt(n)的因子，对其进行优化。先考虑比sqrt(n)小的，代码和质数的判定类似 * 最后如果n还是&gt;1，说明此时的n就是大于sqrt(n)的唯一质因子，输出即可，时间复杂度O(sqrt(n)) * 这种方法，运算次数太多，还不如枚举法 */bool divide1(int n)&#123; int s = 0; for(int i = 2; i &lt;= n; ++i) &#123; // 证明一下循环里面的i一定是一个质数：假如 i 是一个合数， // 那么它一定可以分解成多个质因子相乘的形式， // 这多个质因子同时也是 n 的质因子且比i要小， // 而比i小的数在之前的循环过程中一定是被条件除完了的，所以i不可能是合数，只可能是质数 if(n % i == 0)//i一定是质数 &#123; while(n % i == 0)//短除法分解质因数 &#123; n /= i; ++s;//统计质因数的个数 &#125; &#125; &#125; return s &gt; 1? false:true;&#125;// 使用此方法，leetcode中，计算从1到709486有几个质数，耗时408msbool divide2(int n)&#123; int s = 0; for(int i = 2; i &lt;= n / i; ++i) &#123; if(n % i == 0)//i一定是质数 &#123; //s = 0; while(n % i == 0)//短除法分解质因数 &#123; n /= i; ++s;//统计质因数的个数 &#125; //printf(&quot;%d %d\\n&quot;, i, s); &#125; &#125; //if(n &gt; 1) printf(&quot;%d %d\\n&quot;, n, 1);//当n没有变化的时候，输出本身和1 n &gt; 1? ++s:s; // n还是大于1的，说明此时的n就是一个质数，s需要加1 return s &gt; 1? false:true;&#125;int countPrimes(int n)&#123; int i = 0; int res = 0; for (i = 2; i &lt;= n; ++i)&#123; divide1(i)?++res:res; &#125; return res;&#125;///////////////////////////筛质数////////////////////////////** * 朴素筛法 * 枚举i：2~n，从前往后把每个数对应的倍数都删除掉，这样筛过之后，所有剩下的数都是质数 *///朴素筛法-O(nlogn)// leetcode n=709486时耗时28msint countPrimes1(int n)&#123; // 存储质数 int* primeNums = (int*)malloc(n * sizeof(int)); // 计数 int count = 0; // 标记 int* flag = (int*)calloc(n + 1, sizeof(int)); int i,j; for (i = 2; i &lt; n; ++i)&#123; if (!flag[i])&#123; primeNums[count++] = i; &#125; // 将所有i的倍数都标记，这些标记的数肯定是合数 for (j = i + i; j &lt; n; j += i)&#123; flag[j] = true; &#125; &#125; free(primeNums); free(flag); return count;&#125;/**埃氏筛法是对朴素筛法的一种优化方式，我们并不需要把2~n的每一个数的倍数都删掉，可以只把所有质数的倍数删掉！因为合数的倍数，肯定也是比这个合数小的质数的某个倍数时间复杂度：O(n * loglogn)，近似O(n) * // leetcode n = n=709486时耗时8ms */int countPrimes2(int n)&#123; // 存储质数 //int* primeNums = (int*)malloc(n * sizeof(int)); // 计数 int count = 0; // 标记 int* flag = (int*)calloc(n, sizeof(int)); int i,j; for (i = 2; i &lt; n; ++i)&#123; // 进入这个if条件的都是质数，合数都在之前的循环中被标记为true了 if (!flag[i])&#123; // primeNums[count++] = i; ++count; // 将所有i的倍数都标记，这些标记的数肯定是合数 for (j = i + i; j &lt; n; j += i)&#123; flag[j] = 1; &#125; &#125; &#125; //free(primeNums); free(flag); return count;&#125;/**线性（欧拉）筛法埃氏筛法的缺陷 ：对于一个合数，有可能被筛多次。例如 30 = 2 * 15 = 3 * 10 = 5*6……那么如何确保每个合数只被筛选一次呢？我们只要用它的最小质因子来筛选即可，这便是欧拉筛法。欧拉筛法的基本思想 ：在埃氏筛法的基础上，让每个合数只被它的最小质因子筛选一次，以达到不重复的目的。 */int countPrimes3(int n)&#123; // 存储质数 int* primeNums = (int*)malloc(n * sizeof(int)); // 计数 int count = 0; // 标记合数 int* flag = (int*)calloc(n, sizeof(int)); int i,j; for (i = 2; i &lt; n; ++i)&#123; // 将数从小到大遍历的过程中，没被标记的数一定是质数 if (!flag[i])&#123; primeNums[count++] = i; ++count; &#125; // 以下这组循环，意思是以一个固定的倍数i去乘以不同的质数，并加上0 == i % primeNums[j]判断来保证 // 这些数是以primeNums[j]为最小质因数的合数 for (j = 0; i * primeNums[j] &lt; n; ++j)&#123; // primeNums[]存放的是从小到大排列的质数，i在内循环中都是不变的， // i作为一个倍数去乘以质数来得到不同的合数。当j从0开始遍历的时候， // 一开始的一次或几次循环中，i * primeNums[j]得到的合数，肯定是以 // primeNums[j]为最小质因数的。那么这些数都可以打上标记。i % primeNums[j] == 0 // 是在判断primeNums[j]是不是i的最小质因数。当j继续增大， // 如果出现某个i0可以被某个primeNums[j0]整除，说明此时i0可以分解成 // primeNums[j0]和一个比primeNums[j0]大的质数的乘积，我们将这个比primeNums[j0]大 // 的数称为primeNums[j1]。此时， // i0 * primeNums[j0] = primeNums[j0] * primeNums[j1] * primeNums[j0](其中j1 &gt; j0)。 // primeNums[j0]的值还是i0 * primeNums[j0]这个合数的最小质因数，但是下一次循环， // 也就是i0 * primeNums[k0](其中k0 = j0 + 1)，却不是以primeNums[k0]为最小质因数的合数了， // 因为i0 * primeNums[k0] = primeNums[j0] * primeNums[j1] * primeNums[k0], // 这里最小的质数是primeNums[j0],i0已经可以被上一次循环的primeNums[j0]因式分解。 // 如果仍然标记flag[i0 * primeNums[k0]] = 1,会造成重复标记。因为 // 令i_ = primeNums[j1] * primeNums[k0] &gt; i0, i0 * primeNums[k0] = i_ * primeNums[j0], // 即当外层循环递增到i_时，又会标记一次i0 * primeNums[k0]这个合数。 // 所以当i % primeNums[j] == 0时，应该推出循环了。 flag[i * primeNums[j]] = 1; // j继续增大，会不会一直找不到primeNums[j]可以整除i,不可能，为什么？ // 因为小于等于i的质数都在primeNums中， // 如果i是合数，合数一定可以因式分解，一定存在小于i的质数能整除i， // 如果i是质数，那么i已经放在了primeNums中，正好是最后一个， // 质数当然可以被自己整除。 if ((0 == i % primeNums[j]))&#123; break; &#125; &#125; &#125; free(primeNums); free(flag); return count;&#125;int main(int argc, char** argv)&#123; int n = 709486; if (argc &gt; 1)&#123; n = atoi(argv[1]); &#125; printf(&quot;count:%d\\n&quot;, countPrimes2(n)); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://iengne.vercel.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://iengne.vercel.app/tags/%E6%95%B0%E5%AD%A6/"},{"name":"质数","slug":"质数","permalink":"https://iengne.vercel.app/tags/%E8%B4%A8%E6%95%B0/"}]},{"title":"AVL-tree","slug":"AVL-tree","date":"2022-04-29T08:56:56.000Z","updated":"2022-06-12T11:04:24.996Z","comments":true,"path":"2022/04/29/AVL-tree/","link":"","permalink":"https://iengne.vercel.app/2022/04/29/AVL-tree/","excerpt":"AVL树（Adelson-Velsky and Landis Tree）是计算机科学中最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。","text":"AVL树（Adelson-Velsky and Landis Tree）是计算机科学中最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。 查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409/** * @file AVLTree.c * @author your name (you@domain.com) * @brief 实现AVL树 * @version 0.1 * @date 2022-04-11 * * @copyright Copyright (c) 2022 * */#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;errno.h&quot;#include &quot;string.h&quot;#include &quot;math.h&quot;#include &lt;sys/time.h&gt;#ifndef _Search_Tree_H#define _Search_Tree_Hstruct TreeNode;typedef struct TreeNode TreeNode;typedef struct TreeNode* SearchTRee;typedef struct TreeNode* Position;#endiftypedef enum ERorateDir&#123; ROTATE_L = 1, ROTATE_R,&#125;ERorateDir;struct TreeNode &#123; int elem; int count; /**&lt; 一个节点相同元素计数 */ int height; ///&lt; 树的高度 struct TreeNode* left; struct TreeNode* right;&#125;;void releaseSTree(TreeNode* t)&#123; if (!t)&#123; TreeNode* left = (t)-&gt;left; TreeNode* right = (t)-&gt;right; free(t); releaseSTree(left); releaseSTree(right); &#125;&#125;/* 计算树的高度 */int height(Position root)&#123; if (!root) &#123; printf(&quot;Line:%d, error:node does not exist\\n&quot;, __LINE__); return -1; &#125; if (root-&gt;left &amp;&amp; root-&gt;right) &#123; return fmax(root-&gt;left-&gt;height, root-&gt;right-&gt;height) + 1; &#125; else if (root-&gt;left &amp;&amp; !root-&gt;right) &#123; return root-&gt;left-&gt;height + 1; &#125; else if (!root-&gt;left &amp;&amp; root-&gt;right) &#123; return root-&gt;right-&gt;height + 1; &#125; else &#123; return 0; &#125;&#125;/* 计算左右子树的高度差 */int height_lr_diff(Position root)&#123; if (root-&gt;right &amp;&amp; root-&gt;left) &#123; return root-&gt;left-&gt;height &gt; root-&gt;left-&gt;height? \\ root-&gt;left-&gt;height - root-&gt;right-&gt;height: \\ root-&gt;right-&gt;height - root-&gt;left-&gt;height; &#125; else if (root-&gt;left &amp;&amp; !root-&gt;right) &#123; return root-&gt;left-&gt;height + 1; &#125; else if (!root-&gt;left &amp;&amp; root-&gt;right) &#123; return root-&gt;right-&gt;height + 1; &#125; else &#123; return 0; &#125;&#125;/* 单旋转 */Position singleRotate(Position k, ERorateDir dir)&#123; Position k1; if (dir == ROTATE_L)&#123; k1 = k-&gt;left; k-&gt;left = k1-&gt;right; k1-&gt;right = k; &#125;else if (dir == ROTATE_R)&#123; k1 = k-&gt;right; k-&gt;right = k1-&gt;left; k1-&gt;left = k; &#125; k-&gt;height = height(k); k1-&gt;height = height(k1); return k1;&#125;/* L_R型双旋转 */Position doubleRotateWithLeft(Position k)&#123; k-&gt;left = singleRotate(k-&gt;left, ROTATE_R); return singleRotate(k, ROTATE_L);&#125;/* R-L型双旋转 */Position doubleRotateWithRight(Position k)&#123; k-&gt;right = singleRotate(k-&gt;right, ROTATE_L); return singleRotate(k, ROTATE_R);&#125;/** * @brief 插入操作，插入后做平衡调整 * * @param tree * @param x * @return TreeNode*，新树的root节点 */TreeNode* insert(TreeNode* tree, int x)&#123; if (!tree)&#123; tree = (TreeNode*)malloc(sizeof(TreeNode)); if (!tree)&#123; printf(&quot;error:out of memory\\n&quot;); return NULL; &#125; tree-&gt;elem = x; tree-&gt;count = 1; tree-&gt;height = 0; tree-&gt;left = NULL; tree-&gt;right = NULL; &#125;else &#123; int diff_height; if (x &lt; tree-&gt;elem)&#123; tree-&gt;left = insert(tree-&gt;left, x); diff_height = height_lr_diff(tree); /* 插入之后判断是否需要调整平衡 */ if (diff_height == 2)&#123; /* L-L型 */ if (x &lt; tree-&gt;left-&gt;elem)&#123; tree = singleRotate(tree, ROTATE_L); /* L-R型 */ &#125;else if (x &gt; tree-&gt;left-&gt;elem)&#123; tree = doubleRotateWithLeft(tree); &#125; &#125; &#125;else if (x &gt; tree-&gt;elem)&#123; tree-&gt;right = insert(tree-&gt;right, x); diff_height = height_lr_diff(tree); /* 插入之后判断是否需要调整平衡 */ if (diff_height == 2)&#123; /* R-R型 */ if (x &gt; tree-&gt;right-&gt;elem)&#123; tree = singleRotate(tree, ROTATE_R); /* R-L型 */ &#125;else if (x &lt; tree-&gt;right-&gt;elem)&#123; tree = doubleRotateWithRight(tree); &#125; &#125; &#125;else&#123; ++ tree-&gt;count; return tree; &#125; &#125; tree-&gt;height = height(tree); return tree;&#125;TreeNode* find(TreeNode* tree, int x)&#123; if (!tree)&#123; return NULL; &#125; if (x == tree-&gt;elem)&#123; return tree; &#125;else if (x &lt; tree-&gt;elem)&#123; return find(tree-&gt;left, x); &#125;else &#123; return find(tree-&gt;right, x); &#125;&#125;TreeNode* findMin(TreeNode* tree)&#123; if (!tree)&#123; return NULL; &#125; if (!tree-&gt;left)&#123; return tree; &#125;else &#123; return findMin(tree-&gt;left); &#125;&#125;TreeNode* findMax(TreeNode* tree)&#123; if (!tree)&#123; return NULL; &#125; if (!tree-&gt;right)&#123; return tree; &#125;else &#123; return findMax(tree-&gt;right); &#125;&#125;/** * @brief AVL树的删除，删除后需要做调整平衡 * * @param tree * @param x * @return TreeNode* ,新树的root节点 */TreeNode* delete(root, x)TreeNode* root;int x;&#123; if (!root) &#123; printf(&quot;Line:%d, error: node does not exist\\n&quot;, __LINE__); return NULL; &#125; int height_diff; if (x &lt; root-&gt;elem) &#123; root-&gt;left = delete(root-&gt;left, x); height_diff = height_lr_diff(root); /* 1.如果被删除的元素不是叶子节点，需要去高的子树中去找替代的叶子节点， 然后删除叶子节点。 2.如果本来要删除的就是叶子节点，那跟上面的后半部分动作一致。 所以只有叶子节点被删除之后才会需要调整 */ if (height_diff == 2) &#123; /* x是删除的元素,删除后O是最小不平衡子树的root O / \\ x o / o */ /* 这种情况必须用双旋转，单旋转不能改变深度 */ if (!root-&gt;right-&gt;right) &#123; root = doubleRotateWithRight(root); &#125; /* O O / \\ / \\ x o 或者 x o \\ / \\ o o o */ /* 单旋转 */ else &#123; root = singleRotate(root, ROTATE_R); &#125; &#125; &#125; else if (x &gt; root-&gt;elem) &#123; root-&gt;right = delete(root-&gt;right, x); height_diff = height_lr_diff(root); if (height_diff == 2) &#123; /* x是删除的元素,删除后O是最小不平衡子树的root O / \\ o x \\ o */ /* 这种情况必须用双旋转，单旋转不能改变深度 */ if (!root-&gt;left-&gt;left) &#123; root = doubleRotateWithLeft(root); &#125; /* O O / \\ / \\ o x 或者 o x / \\ / o o o */ else &#123; root = singleRotate(root, ROTATE_L); &#125; &#125; &#125; else &#123; /* 左右子树都存在 */ if (root-&gt;left &amp;&amp; root-&gt;right) &#123; if (root-&gt;count &gt; 1) &#123; --root-&gt;count; &#125; else &#123; // 从高的子树中找到元素替换将要删除的节点位置，保证左右子树是平衡的 if (root-&gt;left-&gt;height &gt; root-&gt;right-&gt;height) &#123; /* 在左子树中找到最大的值，也就是右子树是空的节点，将它移到将要删除的节点位置 */ TreeNode* tmp = findMax(root-&gt;left); root-&gt;elem = tmp-&gt;elem; root-&gt;count -= tmp-&gt;count; /* 删除移动了元素的节点 */ root-&gt;left = delete(root-&gt;left, tmp-&gt;elem); &#125; else &#123; /* 在右子树中找到最小的值，也就是左子树是空的节点，将它移到将要删除的节点位置 */ TreeNode* tmp = findMin(root-&gt;right); root-&gt;elem = tmp-&gt;elem; root-&gt;count -= tmp-&gt;count; /* 删除移动了元素的节点 */ root-&gt;right = delete(root-&gt;right, tmp-&gt;elem); &#125; &#125; &#125; /* 只存在一个子树,或者不存在子树 */ else &#123; TreeNode* tmpNode = root; if (!root-&gt;left) &#123; /* 如果两个子树都是空，将right给root也没问题，因为right就是NULL */ root = root-&gt;right; &#125; else if (!root-&gt;right) &#123; root = root-&gt;left; &#125; free(tmpNode); &#125; &#125; if (root) &#123; root-&gt;height = height(root); &#125; return root;&#125;/** * @brief 前序遍历 * * @param root * @param level */void pre_order_traverse(SearchTRee root, int level)&#123; if (root) &#123; printf(&quot;%d-%d &quot;, level, root-&gt;elem); pre_order_traverse(root-&gt;left, level + 1); pre_order_traverse(root-&gt;right, level + 1); &#125;&#125;int main(void)&#123; int arr[] = &#123;32,50,2,84,69,98,73,62,20,9&#125;; SearchTRee root = NULL; int i; for (i = 0; i &lt; sizeof(arr)/sizeof(int); ++i) &#123; root = insert(root, arr[i]); pre_order_traverse(root, 0); printf(&quot;\\n&quot;); &#125; pre_order_traverse(root, 0); printf(&quot;\\n&quot;); root = delete(root, 50); pre_order_traverse(root, 0); printf(&quot;\\n&quot;); root = delete(root, 32); pre_order_traverse(root, 0); printf(&quot;\\n&quot;); root = delete(root, 62); pre_order_traverse(root, 0); printf(&quot;\\n&quot;); releaseSTree(root); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://iengne.vercel.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"查找二叉树","slug":"查找二叉树","permalink":"https://iengne.vercel.app/tags/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"平衡查找二叉树","slug":"平衡查找二叉树","permalink":"https://iengne.vercel.app/tags/%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"实现伸展树","slug":"splay-tree","date":"2022-04-29T01:41:19.000Z","updated":"2022-04-29T08:56:36.272Z","comments":true,"path":"2022/04/29/splay-tree/","link":"","permalink":"https://iengne.vercel.app/2022/04/29/splay-tree/","excerpt":"伸展树（英语：Splay Tree）是一种能够自我平衡的二叉查找树，它能在均摊O(log n)的时间内完成基于伸展（Splay）操作的插入、查找、修改和删除操作。它是由丹尼尔·斯立特（Daniel Sleator）和罗伯特·塔扬在1985年发明的。","text":"伸展树（英语：Splay Tree）是一种能够自我平衡的二叉查找树，它能在均摊O(log n)的时间内完成基于伸展（Splay）操作的插入、查找、修改和删除操作。它是由丹尼尔·斯立特（Daniel Sleator）和罗伯特·塔扬在1985年发明的。 在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行调整，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。它的优势在于不需要记录用于平衡树的冗余信息。-— Wikipedia 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713/** * @file splay_tree_traverse_BFS_DFS.c * @author your name (you@domain.com) * @brief 实现伸展树,实现队列和栈用于广度优先遍历和深度优先遍历 * @version 0.1 * @date 2022-04-21 * * @copyright Copyright (c) 2022 * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;typedef struct BinTreeNode&#123; int val; int count; /**&lt; 相同元素计数 */ struct BinTreeNode* left; struct BinTreeNode* right;&#125; BinTreeNode;/********************************************************* * 使用链表实现stack用于深度优先搜索 ********************************************************/typedef struct ListNode&#123; BinTreeNode* bin_tree_node; struct ListNode *next;&#125; ListNode;typedef struct ListNode* Stack;int is_empty(Stack stack)&#123; return stack == NULL;&#125;int push_stack(Stack* stack, BinTreeNode* tree_node)&#123; ListNode* node = (ListNode*)malloc(sizeof(ListNode)); node-&gt;next = NULL; node-&gt;bin_tree_node = tree_node; if (!node) &#123; printf(&quot;out of memory\\n&quot;); return -1; &#125; if (!*stack) &#123; *stack = node; return 0; &#125; node-&gt;next = *stack; *stack = node; return 0;&#125;BinTreeNode* pop_stack(Stack* stack)&#123; if (*stack) &#123; ListNode* backup = *stack; BinTreeNode* ret = (*stack)-&gt;bin_tree_node; *stack = (*stack)-&gt;next; free(backup); return ret; &#125; else &#123; return NULL; &#125;&#125;void make_stack_empty(Stack* stack)&#123; while (stack) &#123; ListNode* backup; backup = *stack; *stack = (*stack)-&gt;next; free(backup); &#125;&#125;BinTreeNode* get_top_elem(Stack stack)&#123; if (stack) &#123; return stack-&gt;bin_tree_node; &#125;&#125;/**************************** * 实现队列用于广度优先算法 ***************************/typedef struct Queue&#123; ListNode* front; ListNode* rear;&#125; Queue;void enqueue(Queue* queue, BinTreeNode* tree_node)&#123; if (!queue) &#123; printf(&quot;error queue is NULL\\n&quot;); return; &#125; ListNode* node = (ListNode*)malloc(sizeof(ListNode)); node-&gt;bin_tree_node = tree_node; node-&gt;next = NULL; if (!queue-&gt;rear) &#123; queue-&gt;rear = node; queue-&gt;front = queue-&gt;rear; &#125; else &#123; queue-&gt;rear-&gt;next = node; queue-&gt;rear = node; &#125;&#125;BinTreeNode* dequeue(Queue* queue)&#123; if (!queue) &#123; printf(&quot;error: queue does not exist\\n&quot;); return NULL; &#125; if (!queue-&gt;front) &#123; printf(&quot;error: queue is empty\\n&quot;); return NULL; &#125; else &#123; ListNode* list_node = queue-&gt;front; BinTreeNode* tree_node = list_node-&gt;bin_tree_node; if (queue-&gt;front == queue-&gt;rear) &#123; queue-&gt;front = queue-&gt;rear = NULL; &#125; else &#123; queue-&gt;front = queue-&gt;front-&gt;next; &#125; free(list_node); return tree_node; &#125;&#125;/******************************************* * 实现伸展树 *******************************************/typedef struct BinTreeNode* SplayTree;typedef struct BinTreeNode* Position;/** * @brief 插入操作就跟二叉搜索树插入一样，不做平衡操作 * * @param splay_tree * @param x * @return SplayTree */void insert(SplayTree* root, int x)&#123; BinTreeNode* node = (BinTreeNode*)malloc(sizeof(BinTreeNode)); if (!node) &#123; return; &#125; node-&gt;val = x; node-&gt;count = 1; node-&gt;left = NULL; node-&gt;right = NULL; if (!*root) &#123; *root = node; return; &#125; SplayTree pos = *root; while (1) &#123; if (x &lt; pos-&gt;val) &#123; if (pos-&gt;left) &#123; pos = pos-&gt;left; &#125; else &#123; pos-&gt;left = node; break; &#125; &#125; else if (x &gt; pos-&gt;val) &#123; if (pos-&gt;right) &#123; pos = pos-&gt;right; &#125; else &#123; pos-&gt;right = node; break; &#125; &#125; else &#123; if (pos-&gt;val == x) &#123; ++pos-&gt;count; break; &#125; &#125; &#125;&#125;/** * @brief 二叉查找树的查找操作 * * @param root * @param x * @return Position */Position find_search_tree(SplayTree root, int x)&#123; if (!root) &#123; printf(&quot;error:not found\\n&quot;); return NULL; &#125; if (x &lt; root-&gt;val) &#123; return find_search_tree(root-&gt;left, x); &#125; else if (x &gt; root-&gt;val) &#123; return find_search_tree(root-&gt;right, x); &#125; else &#123; return root; &#125;&#125;Position find_max(SplayTree root)&#123; if (!root) &#123; return root; &#125; if (root-&gt;right) &#123; return root; &#125; else &#123; return find_max(root-&gt;right); &#125;&#125;Position find_min(SplayTree root)&#123; if (!root) &#123; return root; &#125; if (!root-&gt;left) &#123; return root; &#125; else &#123; return find_min(root-&gt;left); &#125;&#125;/** * @brief 删除元素，删除操作跟二叉查找树的删除一致 * 为了保持删除元素后的树依然是查找树，需要将删除节点的左子树的最大值 * 或者右子树中的最小值移动到删除的地方，移动有两种方案： * 1. 仅移动链表节点中的值 * 2. 移动链表的节点 * 这里使用第1种方案, 第2种有点麻烦 * @param root * @param x * @return Position */Position delete(SplayTree root, int x)&#123; if (!root) &#123; printf(&quot;error:not found\\n&quot;); return root; &#125; if (x &lt; root-&gt;val) &#123; root-&gt;left = delete(root-&gt;left, x); &#125; else if (x &gt; root-&gt;val) &#123; root-&gt;right = delete(root-&gt;right, x); &#125; else &#123; if (root-&gt;left &amp;&amp; root-&gt;right) &#123; if (root-&gt;count &gt;= 2) &#123; --root-&gt;count; &#125; else &#123; Position tmp = find_min(root-&gt;right); root-&gt;val = tmp-&gt;val; root-&gt;count = tmp-&gt;count; root-&gt;right = delete(root-&gt;right, tmp-&gt;val); &#125; &#125; else &#123; Position tmp = root; if (!root-&gt;left) &#123; root = root-&gt;right; &#125; else if (!root-&gt;right) &#123; root = root-&gt;left; &#125; free(tmp); &#125; &#125; return root;&#125;/** * @brief 清空树，释放内存 * * @param root * @return Position */Position delete_all(SplayTree root)&#123; if (root) &#123; if (root-&gt;left) &#123; root-&gt;left = delete_all(root-&gt;left); &#125; if (root-&gt;right) &#123; root-&gt;right = delete_all(root-&gt;right); &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; free(root); return NULL; &#125; &#125;&#125;Position splay_left_left(Position g, Position p, Position cur)&#123; g-&gt;left = p-&gt;right; p-&gt;left = cur-&gt;right; p-&gt;right = g; cur-&gt;right = p; return cur;&#125;Position splay_left_right(Position g, Position p, Position cur)&#123; /* cur跟p互换 */ p-&gt;right = cur-&gt;left; cur-&gt;left = p; g-&gt;left = cur; /* cur跟g互换 */ g-&gt;left = cur-&gt;right; cur-&gt;right = g; return cur;&#125;Position splay_right_left(Position g, Position p, Position cur)&#123; /* cur跟p互换 */ p-&gt;left = cur-&gt;right; cur-&gt;right = p; g-&gt;right = cur; /* cur跟g互换 */ g-&gt;left = cur-&gt;left; cur-&gt;left = g; return cur;&#125;Position splay_right_right(Position g, Position p, Position cur)&#123; g-&gt;right = p-&gt;left; p-&gt;right = cur-&gt;left; p-&gt;left = g; cur-&gt;left = p; return cur;&#125;Position rotate_left(Position p, Position cur)&#123; p-&gt;left = cur-&gt;right; cur-&gt;right = p; return cur;&#125;Position rotate_right(Position p, Position cur)&#123; p-&gt;right = cur-&gt;left; cur-&gt;left = p; return cur;&#125;/** * @brief 伸展树的查找操作要求将找到的元素伸展到根节点 * * @param cur_pos * @param x * @return Position */Position find(SplayTree cur_pos, int x)&#123; if (!cur_pos) &#123; return NULL; &#125; Stack stack = NULL; while (1) &#123; if (x &lt; cur_pos-&gt;val) &#123; if (cur_pos-&gt;left) &#123; push_stack(&amp;stack, cur_pos); cur_pos = cur_pos-&gt;left; &#125; else &#123; printf(&quot;error:not found\\n&quot;); return NULL; &#125; &#125; else if (x &gt; cur_pos-&gt;val) &#123; if (cur_pos-&gt;right) &#123; push_stack(&amp;stack, cur_pos); cur_pos = cur_pos-&gt;right; &#125; else &#123; printf(&quot;error:not found\\n&quot;); return NULL; &#125; &#125; else &#123; printf(&quot;find it\\n&quot;); Position p, q, r; p = pop_stack(&amp;stack); q = pop_stack(&amp;stack); r = pop_stack(&amp;stack); /* 找到元素后通过伸展将元素放到根节点*/ while (1) &#123; /* 栈里没有元素，那么cur_pos就是根节点 */ if (!p &amp;&amp; !q &amp;&amp; !r) &#123; break; &#125; /* 说明当前cur_pos变量保存的节点的父节点是根节点,旋转一次就行 */ if (p &amp;&amp; !q &amp;&amp; !r) &#123; if (p-&gt;left == cur_pos) &#123; cur_pos = rotate_right(p, cur_pos); &#125; else &#123; cur_pos = rotate_left(p, cur_pos); &#125; break; &#125; /* zig-zig模式 */ if (q-&gt;left == p &amp;&amp; p-&gt;left == cur_pos) &#123; cur_pos = splay_left_left(q, p ,cur_pos); &#125; else if (q-&gt;right == p &amp;&amp; p-&gt;right == cur_pos) &#123; cur_pos = splay_right_right(q, p ,cur_pos); &#125; /* zig-zag模式 */ else if (q-&gt;left == p &amp;&amp; p-&gt;right == cur_pos) &#123; cur_pos = splay_left_right(q, p ,cur_pos); &#125; else if (q-&gt;right == p &amp;&amp; p-&gt;left == cur_pos) &#123; cur_pos = splay_right_left(q, p, cur_pos); &#125; if (!r) &#123; break; &#125; if (r-&gt;left == q) &#123; r-&gt;left = cur_pos; &#125; else &#123; r-&gt;right = cur_pos; &#125; p = r; q = pop_stack(&amp;stack); r = pop_stack(&amp;stack); &#125; return cur_pos; &#125; &#125;&#125;/** * @brief 随机生成一棵二叉查找树 * * @param size * @return SplayTree */SplayTree make_random_bin_tree(int size)&#123; struct timeval tv; gettimeofday(&amp;tv, NULL); srand((unsigned int)(tv.tv_usec)); SplayTree tree = NULL; printf(&quot;[random:]&quot;); while (size--) &#123; int x = rand() % 100; printf(&quot;%d &quot;, x); insert(&amp;tree, x); &#125; printf(&quot;\\n&quot;); return tree;&#125;/** * @brief 深度优先遍历(后序遍历) * * @param root */void traverse_DFS(SplayTree root)&#123; Stack stack = NULL; int ret = push_stack(&amp;stack, root); if (ret &lt; 0) &#123; printf(&quot;push_stack error\\n&quot;); return; &#125; while (!is_empty(stack)) &#123; BinTreeNode* ret = pop_stack(&amp;stack); if (!ret) &#123; printf(&quot;error:ret is NULL\\n&quot;); &#125; printf(&quot;%d &quot;, ret-&gt;val); if (ret-&gt;right) &#123; push_stack(&amp;stack, ret-&gt;right); &#125; if (ret-&gt;left) &#123; push_stack(&amp;stack, ret-&gt;left); &#125; &#125;&#125;int is_empty_queue(Queue* queue)&#123; return queue-&gt;front == queue-&gt;rear &amp;&amp; queue-&gt;front == NULL;&#125;/** * @brief 广度优先遍历(层序遍历) * * @param root */void traverse_BFS(SplayTree root)&#123; Queue queue = &#123;0&#125;; enqueue(&amp;queue, root); int level = 0; while (!is_empty_queue(&amp;queue)) &#123; BinTreeNode* node = dequeue(&amp;queue); printf(&quot;%d &quot;, node-&gt;val); if (node-&gt;left) &#123; enqueue(&amp;queue, node-&gt;left); &#125; if (node-&gt;right) &#123; enqueue(&amp;queue, node-&gt;right); &#125; &#125;&#125;/** * @brief 前序遍历 * * @param root * @param level */void pre_order_traverse(SplayTree root, int level)&#123; if (root) &#123; printf(&quot;%d-%d &quot;, level, root-&gt;val); pre_order_traverse(root-&gt;left, level + 1); pre_order_traverse(root-&gt;right, level + 1); &#125;&#125;/** * @brief 中序遍历 * * @param root * @param level */void in_order_traverse(SplayTree root, int level)&#123; if (root) &#123; in_order_traverse(root-&gt;left, level + 1); printf(&quot;%d-%d &quot;, level, root-&gt;val); in_order_traverse(root-&gt;right, level + 1); &#125;&#125;/** * @brief 后序遍历 * * @param root * @param level */void post_order_traverse(SplayTree root, int level)&#123; if (root) &#123; post_order_traverse(root-&gt;left, level + 1); post_order_traverse(root-&gt;right, level + 1); printf(&quot;%d-%d-%p &quot;, level, root-&gt;val, root); &#125;&#125;int main(void)&#123; //SplayTree root = make_random_bin_tree(10); int arr[] = &#123;32,50,2,84,69,98,73,62,20,9&#125;; int i = 0; SplayTree root = NULL; for (i = 0; i &lt; sizeof(arr)/sizeof(int); ++i) &#123; insert(&amp;root, arr[i]); &#125; root = find(root, 73); printf(&quot;--%p--\\n&quot;, find_search_tree(root, 62)); delete(root, 50); printf(&quot;---------------------\\n&quot;); pre_order_traverse(root, 0); printf(&quot;\\n&quot;); in_order_traverse(root, 0); printf(&quot;\\n&quot;); post_order_traverse(root, 0); printf(&quot;\\n&quot;); traverse_DFS(root); printf(&quot;\\n&quot;); traverse_BFS(root); delete_all(root); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://iengne.vercel.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"伸展树","slug":"伸展树","permalink":"https://iengne.vercel.app/tags/%E4%BC%B8%E5%B1%95%E6%A0%91/"},{"name":"二叉查找树","slug":"二叉查找树","permalink":"https://iengne.vercel.app/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"name":"栈","slug":"栈","permalink":"https://iengne.vercel.app/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://iengne.vercel.app/tags/%E9%98%9F%E5%88%97/"}]},{"title":"C语言中复杂类型的声明","slug":"c-complex-declaration","date":"2022-04-28T09:42:59.000Z","updated":"2022-06-10T05:39:04.558Z","comments":true,"path":"2022/04/28/c-complex-declaration/","link":"","permalink":"https://iengne.vercel.app/2022/04/28/c-complex-declaration/","excerpt":"犹记得当第一次看见c的signal函数的原型的时候，懵逼了，这是个啥啊 123typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler);","text":"犹记得当第一次看见c的signal函数的原型的时候，懵逼了，这是个啥啊 123typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler); 现在知道了，借助typedef声明了一个函数指针类型取名叫sighandler_t，这个函数指针返回值是void，入参是int。然后声明了signal函数，signal函数的返回值是sighandler_t这个类型的函数指针。typedef可以帮我们简化复杂类型的声明，在不借助typedef的情况下，c语言应该怎么声明复杂的类型呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &quot;stdlib.h&quot;/** * 复习关于C语言复杂类型的声明定义 */int main(void)&#123; /** * c语言语法中，[]、()的优先级最高，[]、()写在标识符的右侧，*号和基本类型，如int,char,struct等 * 写在标识符左侧,对声明定义的解析是右左原则。 */ /** * 指针p指向一个有20个char类型元素的数组 */ char (*p)[20]; p=(char(*)[20])malloc(20); free(p); int a[20]; int (*p_a)[20] = &amp;a; /** * 二级指针就多加个* */ int (**pp_a)[20] = &amp;p_a; typedef int(*p_array)[]; p_array * p_c = &amp;p_a;// 跟int (**pp_a)[20] = &amp;p_a;等效 p_array** p_d = &amp;p_c; int *b[20]; int *(*p_b)[20] = &amp;b; int *(**p_e)[20] = &amp;p_b; /*************************************/ /** * 定义一个数组，数组有20个元素，每个元素是指向int类型的二级指针 */ int** f[20]; /** * 定义一个指针，该指针指向一个数组，该数组有20个元素，每个元素是指向int类型的二级指针 */ int** (*p_f)[20] = &amp;f; /** * 定义一个20个元素的数组g，该数组的每个元素是一个指针， * 该指针指向一个有10个元素的数组,该数组的元素是指向char* * 类型的指针 */ char *(*g[20])[10]; /** * 定义一个20个元素的数组，数组的每一个元素是一个指针，该指针是函数指针， * 该函数指针指向的函数，入参为int,返回值是int * */ int (*h[20])(int); /** * 定义一个指针指向二维int型数组 * */ int i[2][12]; int (*p_i)[][12] = &amp;i; int (*p_i1)[12] = i; // 数组名i代表的是以数组元素为类型的指向数组首地址的指针 /** * 定义一个函数指针func，指向的函数没有入参，返回值是一个指针， * 该指针指向一个二维数组，该二维数组的每一元素是有10个元素的一维数组， * 一维数组的元素是int*指针 */ int *(*(*func)(void))[][10]; /** * 定义一个函数指针func_a，指向的函数入参是int,返回值是函数指针， * 该函数指针指向的函数入参是int,返回值是int* * 1.首先是个指针,所以在左侧加*号，得到*func_a * 2.变成函数指针，入参是int，得到(*func_a)(int) * 3.返回值是函数指针，那么把2的结果作为一个整体看待，看作是标识符, * 再在左侧加*号，后边加(int),得到(*(*func_)(int))(int) * 4.返回值的函数指针指向的函数返回值是int*，所以再在左边加上int*， * 最后得到 int *(*(*func_a)(int))(int) */ int *(*(*func_a)(int))(int); /** * 定义一个数组指针pg，该指针指向一个20个元素的数组，该数组的元素是 * 函数指针，该函数指针指向的函数，入参是int,返回值是int */ int (*(*pg)[20])(int); pg = &amp;h; /** * 定义一个函数指针func_b，指向的函数入参是int，返回值是一个指针， * 该指针指向一个20个元素的数组，该数组的元素是函数指针， * 该函数指针指向的函数，入参是int,返回值是int. */ int (*(*(*func_b)(int b))[20])(int); /** * 定义一个数组指针ph,指向一个有20个元素的数组，该数组的元素是函数指针， * 该指针指向一个函数，该函数的入参是int,返回值是指针，该指针指向一个10 * 个元素的数组，该元素char * */ char* (*(*(*ph)[20])(int))[10]; /** * 定义一个函数指针func_d，入参是int,返回值是函数指针，该函数指针指向的函数 * 入参是short, 返回值是一个指向包含15个char*类型的数组的指针 */ char *(*(*(*func_d)(int))(short))[15]; return 0;&#125;","categories":[{"name":"开发日常","slug":"开发日常","permalink":"https://iengne.vercel.app/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://iengne.vercel.app/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"github fork 项目同步上游","slug":"fork-merge","date":"2022-01-13T08:52:25.000Z","updated":"2022-01-14T06:02:07.000Z","comments":true,"path":"2022/01/13/fork-merge/","link":"","permalink":"https://iengne.vercel.app/2022/01/13/fork-merge/","excerpt":"虽然github已经在网页上增加了fetch upstream功能，但如果有冲突，只能手动merge.以下记录一次手动合并的过程：","text":"虽然github已经在网页上增加了fetch upstream功能，但如果有冲突，只能手动merge.以下记录一次手动合并的过程： clone 自己fork的仓库12345678♥root-16:47:17-&gt;&gt;~/workspace# git clone git@github.com:iEngne/now-subconverter.gitCloning into &#x27;now-subconverter&#x27;...remote: Enumerating objects: 1514, done.remote: Counting objects: 100% (121/121), done.remote: Compressing objects: 100% (110/110), done.remote: Total 1514 (delta 24), reused 57 (delta 5), pack-reused 1393Receiving objects: 100% (1514/1514), 46.51 MiB | 991.00 KiB/s, done.Resolving deltas: 100% (636/636), done. 确认当前分支是否是要合并的分支，git brakch -a，如果不是切换到相应的分支。123♥root-17:11:23-&gt;&gt;~/workspace/now-subconverter# git branch -a* master remotes/origin/HEAD -&gt; origin/master 设置upstream.123456♥root-16:48:43-&gt;&gt;~/workspace/now-subconverter# git remote add upstream https://github.com/zhongfly/now-subconverter.git♥root-16:51:15-&gt;&gt;~/workspace/now-subconverter# git remote -vorigin git@github.com:iEngne/now-subconverter.git (fetch)origin git@github.com:iEngne/now-subconverter.git (push)upstream https://github.com/zhongfly/now-subconverter.git (fetch)upstream https://github.com/zhongfly/now-subconverter.git (push) 从远程取出upstream12345678♥root-16:51:20-&gt;&gt;~/workspace/now-subconverter# git fetch upstreamremote: Enumerating objects: 32, done.remote: Counting objects: 100% (32/32), done.remote: Compressing objects: 100% (20/20), done.remote: Total 26 (delta 15), reused 17 (delta 6), pack-reused 0Unpacking objects: 100% (26/26), done.From https://github.com/zhongfly/now-subconverter * [new branch] master -&gt; upstream/master 查看下分支情况，git branch -a12345♥root-17:29:13-&gt;&gt;~/workspace/now-subconverter# git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/master remotes/upstream/master 执行合并123456789♥root-17:31:27-&gt;&gt;~/workspace/now-subconverter# git merge upstream/masterwarning: Cannot merge binary files: subconverter/subconverter.exe (HEAD vs. upstream/master)Auto-merging subconverter/subconverter.exeCONFLICT (content): Merge conflict in subconverter/subconverter.exeAuto-merging subconverter/snippets/emoji.tomlCONFLICT (add/add): Merge conflict in subconverter/snippets/emoji.tomlAuto-merging subconverter/pref.example.tomlCONFLICT (add/add): Merge conflict in subconverter/pref.example.tomlAutomatic merge failed; fix conflicts and then commit the result. 查看冲突12345678910111213♥root-17:31:44-&gt;&gt;~/workspace/now-subconverter# git status# On branch master# You have unmerged paths.# (fix conflicts and run &quot;git commit&quot;)## Unmerged paths:# (use &quot;git add &lt;file&gt;...&quot; to mark resolution)## both added: subconverter/pref.example.toml# both added: subconverter/snippets/emoji.toml# both modified: subconverter/subconverter.exe#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 直接从GUI界面打开文件修改冲突，或者使用git mergetool命令从命令行打开merge工具，如果有装VIM默认调用vimdiff. 修改后commit和push就OK.","categories":[{"name":"开发日常","slug":"开发日常","permalink":"https://iengne.vercel.app/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"github","slug":"github","permalink":"https://iengne.vercel.app/tags/github/"}]},{"title":"vscode ssh 远程登录天坑,使用密钥后仍需要输入密码","slug":"vscode-ssh","date":"2022-01-12T06:02:07.000Z","updated":"2022-01-13T06:02:07.000Z","comments":true,"path":"2022/01/12/vscode-ssh/","link":"","permalink":"https://iengne.vercel.app/2022/01/12/vscode-ssh/","excerpt":"问题：使用ssh-keygen生成了密钥对后，把公钥直接重命名成authorized_keys拷贝到服务器~/.ssh目录，发现vscode ssh登录还是提示需要输入密码，还以为密钥对搞错了，反复重试都一样，这就费解了。","text":"问题：使用ssh-keygen生成了密钥对后，把公钥直接重命名成authorized_keys拷贝到服务器~/.ssh目录，发现vscode ssh登录还是提示需要输入密码，还以为密钥对搞错了，反复重试都一样，这就费解了。 解决 Make sure the permissions on the ~/.ssh directory and its contents are proper. When I first set up my ssh key auth, I didn’t have the ~/.ssh folder properly set up, and it yelled at me. Your home directory ~, your ~/.ssh directory and the ~/.ssh/authorized_keys file on the remote machine must be writable only by you: rwx------ and rwxr-xr-x are fine, but rwxrwx--- is no good¹, even if you are the only user in your group (if you prefer numeric modes: 700 or 755, not 775).If ~/.ssh or authorized_keys is a symbolic link, the canonical path (with symbolic links expanded) is checked. Your ~/.ssh/authorized_keys file (on the remote machine) must be readable (at least 400), but you’ll need it to be also writable (600) if you will add any more keys to it. Your private key file (on the local machine) must be readable and writable only by you: rw-------, i.e. 600. Also, if SELinux is set to enforcing, you may need to run restorecon -R -v ~/.ssh (see e.g. Ubuntu bug 965663 and Debian bug report #658675; this is patched in CentOS 6). ¹ Except on some distributions (Debian and derivatives) which have patched the code to allow group writability if you are the only user in your group. 原文链接:https://unix.stackexchange.com/questions/36540/why-am-i-still-getting-a-password-prompt-with-ssh-with-public-key-authentication 意思就是，一般情况下要求 authorized_keys 文件最好设置为只有所有者有读权限或者读写权限(400或者600)，其他情况可能导致不能访问。某些打了补丁的系统也允许当属组成员只有你一个时，authorized_keys设置属组写权限，也允许ssh登录。 果然我服务器authorized_keys权限是-rwxr--r--(744).我是通过samba把服务器目录共享到Windows的，拷贝过去默认变成了-rwxr--r-- 所以一句 1chmod 600 authorized_keys 解决","categories":[{"name":"开发日常","slug":"开发日常","permalink":"https://iengne.vercel.app/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://iengne.vercel.app/tags/linux/"},{"name":"vscode","slug":"vscode","permalink":"https://iengne.vercel.app/tags/vscode/"}]}],"categories":[{"name":"开发日常","slug":"开发日常","permalink":"https://iengne.vercel.app/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"},{"name":"瞎折腾","slug":"瞎折腾","permalink":"https://iengne.vercel.app/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://iengne.vercel.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://iengne.vercel.app/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"阿里云盘","slug":"阿里云盘","permalink":"https://iengne.vercel.app/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/"},{"name":"WebDAV","slug":"WebDAV","permalink":"https://iengne.vercel.app/tags/WebDAV/"},{"name":"数学","slug":"数学","permalink":"https://iengne.vercel.app/tags/%E6%95%B0%E5%AD%A6/"},{"name":"质数","slug":"质数","permalink":"https://iengne.vercel.app/tags/%E8%B4%A8%E6%95%B0/"},{"name":"查找二叉树","slug":"查找二叉树","permalink":"https://iengne.vercel.app/tags/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"平衡查找二叉树","slug":"平衡查找二叉树","permalink":"https://iengne.vercel.app/tags/%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"伸展树","slug":"伸展树","permalink":"https://iengne.vercel.app/tags/%E4%BC%B8%E5%B1%95%E6%A0%91/"},{"name":"二叉查找树","slug":"二叉查找树","permalink":"https://iengne.vercel.app/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"name":"栈","slug":"栈","permalink":"https://iengne.vercel.app/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://iengne.vercel.app/tags/%E9%98%9F%E5%88%97/"},{"name":"github","slug":"github","permalink":"https://iengne.vercel.app/tags/github/"},{"name":"linux","slug":"linux","permalink":"https://iengne.vercel.app/tags/linux/"},{"name":"vscode","slug":"vscode","permalink":"https://iengne.vercel.app/tags/vscode/"}]}